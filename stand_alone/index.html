
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Ecological Spatial Analysis - A python package to characterize the range dynamics and shifts of North American tree species.">
      
      
        <meta name="author" content="anytko">
      
      
        <link rel="canonical" href="https://anytko.github.io/ecospat/stand_alone/">
      
      
        <link rel="prev" href="../ecospat/">
      
      
        <link rel="next" href="../mapping/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.14">
    
    
      
        <title>stand alone module - ecospat</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Google+Sans:300,300i,400,400i,700,700i%7CRegular:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Google Sans";--md-code-font:"Regular"}</style>
      
    
    
      <link rel="stylesheet" href="../css/timeago.css">
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#stand-alone-module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="ecospat" class="md-header__button md-logo" aria-label="ecospat" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ecospat
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              stand alone module
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/anytko/ecospat" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ecospat" class="md-nav__button md-logo" aria-label="ecospat" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    ecospat
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/anytko/ecospat" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Contributing
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Changelog
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/anytko/ecospat/issues" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Report Issues
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/leaflet_base/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Leaflet base
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/folium_base/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Folium base
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/range_edges/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Range edges
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/range_movement/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Range movement
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/population_density/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Population density
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/persistence_raster/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Persistence raster
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/widgets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Widgets
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ecospat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ecospat module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    stand alone module
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    stand alone module
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions" class="md-nav__link">
    <span class="md-ellipsis">
      ecospat.stand_alone_functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_northward_shift" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_northward_shift()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_species_distribution" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_species_distribution()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_northward_change_rate" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_northward_change_rate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.cat_int_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      cat_int_mapping()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.categorize_species" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      clip_polygons_to_continent_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      collapse_and_calculate_centroids()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.convert_to_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      convert_to_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.count_points_per_category" class="md-nav__link">
    <span class="md-ellipsis">
      count_points_per_category()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.create_opacity_slider_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_opacity_slider_map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.extract_raster_means_single_species" class="md-nav__link">
    <span class="md-ellipsis">
      extract_raster_means_single_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_modern" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_modern()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_with_historic()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      full_propagule_pressure_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_species_code_if_exists" class="md-nav__link">
    <span class="md-ellipsis">
      get_species_code_if_exists()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_start_year_from_species" class="md-nav__link">
    <span class="md-ellipsis">
      get_start_year_from_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      make_dbscan_polygons_with_points_from_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_category_dataframes" class="md-nav__link">
    <span class="md-ellipsis">
      merge_category_dataframes()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="md-nav__link">
    <span class="md-ellipsis">
      prepare_gdf_for_rasterization()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_data_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_species_historical_range" class="md-nav__link">
    <span class="md-ellipsis">
      process_species_historical_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prune_by_year" class="md-nav__link">
    <span class="md-ellipsis">
      prune_by_year()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_match()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_world()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.recreate_layer" class="md-nav__link">
    <span class="md-ellipsis">
      recreate_layer()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      remove_lakes_and_plot_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_global" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_global()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_range" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.summarize_polygons_with_points" class="md-nav__link">
    <span class="md-ellipsis">
      summarize_polygons_with_points()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif_test()
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mapping/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ipyleaflet mapping module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../foliummap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    folium mapping module
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions" class="md-nav__link">
    <span class="md-ellipsis">
      ecospat.stand_alone_functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_northward_shift" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_northward_shift()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_species_distribution" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_species_distribution()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_northward_change_rate" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_northward_change_rate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.cat_int_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      cat_int_mapping()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.categorize_species" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      clip_polygons_to_continent_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      collapse_and_calculate_centroids()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.convert_to_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      convert_to_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.count_points_per_category" class="md-nav__link">
    <span class="md-ellipsis">
      count_points_per_category()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.create_opacity_slider_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_opacity_slider_map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.extract_raster_means_single_species" class="md-nav__link">
    <span class="md-ellipsis">
      extract_raster_means_single_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_modern" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_modern()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_with_historic()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      full_propagule_pressure_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_species_code_if_exists" class="md-nav__link">
    <span class="md-ellipsis">
      get_species_code_if_exists()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_start_year_from_species" class="md-nav__link">
    <span class="md-ellipsis">
      get_start_year_from_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      make_dbscan_polygons_with_points_from_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_category_dataframes" class="md-nav__link">
    <span class="md-ellipsis">
      merge_category_dataframes()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="md-nav__link">
    <span class="md-ellipsis">
      prepare_gdf_for_rasterization()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_data_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_species_historical_range" class="md-nav__link">
    <span class="md-ellipsis">
      process_species_historical_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prune_by_year" class="md-nav__link">
    <span class="md-ellipsis">
      prune_by_year()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_match()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_world()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.recreate_layer" class="md-nav__link">
    <span class="md-ellipsis">
      recreate_layer()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      remove_lakes_and_plot_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_global" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_global()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_range" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.summarize_polygons_with_points" class="md-nav__link">
    <span class="md-ellipsis">
      summarize_polygons_with_points()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif_test()
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                



                  


  
  


<h1 id="stand-alone-module">stand alone module<a class="headerlink" href="#stand-alone-module" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="ecospat.stand_alone_functions"></a>
    <div class="doc doc-contents first">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.analyze_northward_shift" class="doc doc-heading">
<code class="highlight language-python"><span class="n">analyze_northward_shift</span><span class="p">(</span><span class="n">gdf_hist</span><span class="p">,</span> <span class="n">gdf_new</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.analyze_northward_shift" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Wrapper function that collapses categories and computes the rate of northward shift
in km/year between historical and modern GeoDataFrames.</p>
      <ul>
<li>gdf_hist: Historical GeoDataFrame with 'category' column and polygon geometries</li>
<li>gdf_new: Modern GeoDataFrame with 'category' column and polygon geometries</li>
<li>species_name: Name of the species to determine the starting year</li>
<li>end_year: The final year of modern data (default is 2025)</li>
</ul>
      <ul>
<li>DataFrame with each category's northward change and rate of change</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">analyze_northward_shift</span><span class="p">(</span><span class="n">gdf_hist</span><span class="p">,</span> <span class="n">gdf_new</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function that collapses categories and computes the rate of northward shift</span>
<span class="sd">    in km/year between historical and modern GeoDataFrames.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf_hist: Historical GeoDataFrame with &#39;category&#39; column and polygon geometries</span>
<span class="sd">    - gdf_new: Modern GeoDataFrame with &#39;category&#39; column and polygon geometries</span>
<span class="sd">    - species_name: Name of the species to determine the starting year</span>
<span class="sd">    - end_year: The final year of modern data (default is 2025)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - DataFrame with each category&#39;s northward change and rate of change</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Collapse and calculate centroids</span>
    <span class="n">hist_centroids</span> <span class="o">=</span> <span class="n">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf_hist</span><span class="p">)</span>
    <span class="n">new_centroids</span> <span class="o">=</span> <span class="n">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf_new</span><span class="p">)</span>

    <span class="c1"># Step 2: Calculate northward movement</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_northward_change_rate</span><span class="p">(</span>
        <span class="n">hist_gdf</span><span class="o">=</span><span class="n">hist_centroids</span><span class="p">,</span>
        <span class="n">new_gdf</span><span class="o">=</span><span class="n">new_centroids</span><span class="p">,</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.analyze_species_distribution" class="doc doc-heading">
<code class="highlight language-python"><span class="n">analyze_species_distribution</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">record_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.analyze_species_distribution" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches and processes both modern and historic GBIF data for a given species.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>record_limit</code></td>
        <td><code>int</code></td>
        <td><p>Max number of records to fetch from GBIF.</p></td>
        <td><code>100</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>The most recent year to fetch modern data for.</p></td>
        <td><code>2025</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Tuple</code></td>
      <td><p>(classified_modern_polygons, classified_historic_polygons)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">analyze_species_distribution</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">record_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches and processes both modern and historic GBIF data for a given species.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        species_name (str): Scientific name of the species.</span>
<span class="sd">        record_limit (int): Max number of records to fetch from GBIF.</span>
<span class="sd">        end_year (int): The most recent year to fetch modern data for.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple: (classified_modern_polygons, classified_historic_polygons)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start year not found for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
    <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">fetch_gbif_data_with_historic</span><span class="p">(</span>
        <span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">record_limit</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Modern records (&gt;= </span><span class="si">{</span><span class="n">start_year</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;modern&quot;</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Historic records (&lt; </span><span class="si">{</span><span class="n">start_year</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;historic&quot;</span><span class="p">]))</span>

    <span class="n">modern_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;modern&quot;</span><span class="p">]</span>  <span class="c1"># This is a list of dictionaries</span>
    <span class="n">historic_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;historic&quot;</span><span class="p">]</span>

    <span class="n">historic_gdf</span> <span class="o">=</span> <span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">historic_data</span><span class="p">)</span>
    <span class="n">modern_gdf</span> <span class="o">=</span> <span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">modern_data</span><span class="p">)</span>

    <span class="c1"># Let the pipeline dynamically determine the year range</span>
    <span class="n">classified_modern</span> <span class="o">=</span> <span class="n">process_gbif_data_pipeline</span><span class="p">(</span>
        <span class="n">modern_gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span> <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span>
    <span class="p">)</span>
    <span class="n">classified_historic</span> <span class="o">=</span> <span class="n">process_gbif_data_pipeline</span><span class="p">(</span>
        <span class="n">historic_gdf</span><span class="p">,</span> <span class="n">is_modern</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span>
    <span class="p">)</span>

    <span class="n">classified_modern</span> <span class="o">=</span> <span class="n">calculate_density</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">)</span>
    <span class="n">classified_historic</span> <span class="o">=</span> <span class="n">calculate_density</span><span class="p">(</span><span class="n">classified_historic</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">classified_modern</span><span class="p">,</span> <span class="n">classified_historic</span>
</code></pre></div>
        </details>
    </div>

  </div>







  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.calculate_northward_change_rate" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_northward_change_rate</span><span class="p">(</span><span class="n">hist_gdf</span><span class="p">,</span> <span class="n">new_gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.calculate_northward_change_rate" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Compare centroids within each group/category in two GeoDataFrames and calculate:
- The northward change in kilometers
- The rate of northward change in km per year</p>
      <ul>
<li>hist_gdf: GeoDataFrame with historical centroids (1 centroid per category)</li>
<li>new_gdf: GeoDataFrame with new centroids (1 centroid per category)</li>
<li>species_name: Name of the species to determine start year</li>
<li>end_year: The final year of the new data (default 2025)</li>
</ul>
      <ul>
<li>A DataFrame with category, northward change in km, and rate of northward change in km/year</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">calculate_northward_change_rate</span><span class="p">(</span><span class="n">hist_gdf</span><span class="p">,</span> <span class="n">new_gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare centroids within each group/category in two GeoDataFrames and calculate:</span>
<span class="sd">    - The northward change in kilometers</span>
<span class="sd">    - The rate of northward change in km per year</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - hist_gdf: GeoDataFrame with historical centroids (1 centroid per category)</span>
<span class="sd">    - new_gdf: GeoDataFrame with new centroids (1 centroid per category)</span>
<span class="sd">    - species_name: Name of the species to determine start year</span>
<span class="sd">    - end_year: The final year of the new data (default 2025)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - A DataFrame with category, northward change in km, and rate of northward change in km/year</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Dynamically get the starting year based on species</span>
    <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">))</span>

    <span class="c1"># Calculate the time difference in years</span>
    <span class="n">years_elapsed</span> <span class="o">=</span> <span class="n">end_year</span> <span class="o">-</span> <span class="n">start_year</span>

    <span class="c1"># Merge the two GeoDataFrames on the &#39;category&#39; column</span>
    <span class="n">merged_gdf</span> <span class="o">=</span> <span class="n">hist_gdf</span><span class="p">[[</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">new_gdf</span><span class="p">[[</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_hist&quot;</span><span class="p">,</span> <span class="s2">&quot;_new&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># List to store the changes</span>
    <span class="n">changes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">merged_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span>
        <span class="n">centroid_hist</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_hist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
        <span class="n">centroid_new</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_new&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>

        <span class="c1"># Latitude difference</span>
        <span class="n">northward_change_lat</span> <span class="o">=</span> <span class="n">centroid_new</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid_hist</span><span class="o">.</span><span class="n">y</span>
        <span class="n">northward_change_km</span> <span class="o">=</span> <span class="n">northward_change_lat</span> <span class="o">*</span> <span class="mf">111.32</span>
        <span class="n">northward_rate_km_per_year</span> <span class="o">=</span> <span class="n">northward_change_km</span> <span class="o">/</span> <span class="n">years_elapsed</span>

        <span class="n">changes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
                <span class="s2">&quot;northward_change_km&quot;</span><span class="p">:</span> <span class="n">northward_change_km</span><span class="p">,</span>
                <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">:</span> <span class="n">northward_rate_km_per_year</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">changes</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.cat_int_mapping" class="doc doc-heading">
<code class="highlight language-python"><span class="n">cat_int_mapping</span><span class="p">(</span><span class="n">preped_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.cat_int_mapping" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Copies the input GeoDataFrame, maps the 'category' column to integers,
and transforms the CRS to EPSG:4326.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>preped_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame with a 'category' column.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>Transformed GeoDataFrame with a new 'category_int' column and EPSG:4326 CRS.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cat_int_mapping</span><span class="p">(</span><span class="n">preped_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies the input GeoDataFrame, maps the &#39;category&#39; column to integers,</span>
<span class="sd">    and transforms the CRS to EPSG:4326.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        preped_gdf (GeoDataFrame): Input GeoDataFrame with a &#39;category&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: Transformed GeoDataFrame with a new &#39;category_int&#39; column and EPSG:4326 CRS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">category_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Core&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Leading&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Trailing&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Relict&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">preped_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category_int&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">category_map</span><span class="p">)</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.categorize_species" class="doc doc-heading">
<code class="highlight language-python"><span class="n">categorize_species</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.categorize_species" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Categorizes species into movement groups based on leading, core, and trailing rates.
Handles both full (3-edge) and partial (2-edge) data cases.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>A DataFrame with columns ['species', 'category', 'northward_rate_km_per_year']</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>Categorized movement results with leading/core/trailing rates.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">categorize_species</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Categorizes species into movement groups based on leading, core, and trailing rates.</span>
<span class="sd">    Handles both full (3-edge) and partial (2-edge) data cases.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pd.DataFrame): A DataFrame with columns [&#39;species&#39;, &#39;category&#39;, &#39;northward_rate_km_per_year&#39;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Categorized movement results with leading/core/trailing rates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">species_name</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">species_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">species_name</span><span class="p">]</span>

        <span class="c1"># Extract available rates</span>
        <span class="n">leading</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;leading&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;core&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;trailing&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">leading</span> <span class="o">=</span> <span class="n">leading</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leading</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="n">trailing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Count how many components are not None</span>
        <span class="n">num_known</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">leading</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">trailing</span><span class="p">])</span>

        <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;uncategorized&quot;</span>  <span class="c1"># default</span>

        <span class="c1"># ======= Full Data (3 values) =======</span>
        <span class="k">if</span> <span class="n">num_known</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;positive moving together&quot;</span>
            <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;negative moving together&quot;</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;reabsorption&quot;</span>

            <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;stability&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pulling apart&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;reabsorption&quot;</span>

        <span class="c1"># ======= Partial Data (2 values) =======</span>
        <span class="k">elif</span> <span class="n">num_known</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Only leading and core</span>
            <span class="k">if</span> <span class="n">leading</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely stable&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely positive moving together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely negative moving together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>

            <span class="c1"># Only core and trailing</span>
            <span class="k">elif</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely stable&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely moving together&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely moving together&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>

        <span class="c1"># ======= Final Append =======</span>
        <span class="n">categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;leading&quot;</span><span class="p">:</span> <span class="n">leading</span><span class="p">,</span>
                <span class="s2">&quot;core&quot;</span><span class="p">:</span> <span class="n">core</span><span class="p">,</span>
                <span class="s2">&quot;trailing&quot;</span><span class="p">:</span> <span class="n">trailing</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.classify_range_edges" class="doc doc-heading">
<code class="highlight language-python"><span class="n">classify_range_edges</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.classify_range_edges" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Classifies polygons into leading (poleward), core, and trailing (equatorward)
edges within each cluster based on distance from the centroid of the largest polygon within each cluster.
Includes longitudinal relict detection.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>A GeoDataFrame with 'geometry' and 'cluster' columns.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>The original GeoDataFrame with a new 'category' column.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify_range_edges</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies polygons into leading (poleward), core, and trailing (equatorward)</span>
<span class="sd">    edges within each cluster based on distance from the centroid of the largest polygon within each cluster.</span>
<span class="sd">    Includes longitudinal relict detection.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        gdf (GeoDataFrame): A GeoDataFrame with &#39;geometry&#39; and &#39;cluster&#39; columns.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: The original GeoDataFrame with a new &#39;category&#39; column.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure CRS is in EPSG:3395 (meters)</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Compute centroids and extract coordinates</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span>  <span class="c1"># Compute area</span>

    <span class="c1"># Find the centroid of the largest polygon within each cluster</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_largest_polygon_centroid</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">largest_polygon</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">largest_polygon</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="n">cluster_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_largest_polygon_centroid</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Classify polygons within each cluster based on latitude and longitude distance</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_within_cluster</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">cluster_centroid</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cluster_lat</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">y</span>
        <span class="n">cluster_lon</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">x</span>

        <span class="n">largest_polygon_area</span> <span class="o">=</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span>

        <span class="c1"># Define long_value based on area size</span>
        <span class="k">if</span> <span class="n">largest_polygon_area</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># for very large polygons, allow 10% longitude diff</span>
        <span class="c1"># elif largest_polygon_area &gt; 200:</span>
        <span class="c1"># long_value = 1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># very small polygons, strict 1% longitude diff</span>

        <span class="c1"># Then calculate thresholds</span>
        <span class="n">lat_threshold_01</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_05</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_02</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lon_threshold_01</span> <span class="o">=</span> <span class="n">long_value</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lon</span><span class="p">)</span>  <span class="c1"># 5% of longitude</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">classify</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lat</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lon</span>

            <span class="c1"># Relict by latitude</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (0.01 latitude)&quot;</span>
            <span class="c1"># Relict by longitude</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon_diff</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lon_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (longitude)&quot;</span>
            <span class="c1"># Leading edge (poleward, high latitudes)</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.99)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.95)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.9)&quot;</span>
            <span class="c1"># Trailing edge (equatorward, low latitudes)</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.05)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.1)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;core&quot;</span>

        <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_gdf</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify_within_cluster</span><span class="p">)</span>

    <span class="c1"># Drop temporary columns</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.classify_range_edges_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">classify_range_edges_gbif</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.classify_range_edges_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Classifies polygons into leading (poleward), core, and trailing (equatorward)
edges within each cluster based on distance from the centroid of the largest polygon within each cluster.
Includes longitudinal relict detection.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>A GeoDataFrame with columns 'geometry' and 'cluster', and potentially repeated geometries.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>The original GeoDataFrame with a new 'category' column merged in.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify_range_edges_gbif</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies polygons into leading (poleward), core, and trailing (equatorward)</span>
<span class="sd">    edges within each cluster based on distance from the centroid of the largest polygon within each cluster.</span>
<span class="sd">    Includes longitudinal relict detection.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (GeoDataFrame): A GeoDataFrame with columns &#39;geometry&#39; and &#39;cluster&#39;, and potentially repeated geometries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: The original GeoDataFrame with a new &#39;category&#39; column merged in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add unique ID for reliable merging</span>
    <span class="n">df_original</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">})</span>

    <span class="c1"># Subset to unique geometry-cluster pairs with ID</span>
    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_original</span><span class="p">[[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Ensure proper CRS</span>
    <span class="k">if</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Calculate centroids, lat/lon, area</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span>

    <span class="c1"># Get centroid of largest polygon in each cluster</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_largest_polygon_centroid</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">largest_polygon</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">largest_polygon</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="n">cluster_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">unique_geoms</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_largest_polygon_centroid</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Classify within clusters</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_within_cluster</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">cluster_centroid</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cluster_lat</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">y</span>
        <span class="n">cluster_lon</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">x</span>

        <span class="n">largest_polygon_area</span> <span class="o">=</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">largest_polygon_area</span> <span class="o">&gt;</span> <span class="mi">150000</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="k">elif</span> <span class="n">largest_polygon_area</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="c1"># long_value = 0.15</span>

        <span class="n">lat_threshold_01</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_05</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_02</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lon_threshold_01</span> <span class="o">=</span> <span class="n">long_value</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lon</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">classify</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lat</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lon</span>

            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (0.01 latitude)&quot;</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon_diff</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lon_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (longitude)&quot;</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.99)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.95)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.9)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.05)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.1)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;core&quot;</span>

        <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_gdf</span>

    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="n">classify_within_cluster</span>
    <span class="p">)</span>

    <span class="c1"># Prepare final mapping table and merge</span>
    <span class="n">category_map</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">]]</span>
    <span class="n">df_final</span> <span class="o">=</span> <span class="n">df_original</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">category_map</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_final</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">clip_polygons_to_continent_gbif</span><span class="p">(</span><span class="n">input_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Clips the polygon geometry associated with each point to the North American continent.
Preserves one row per original point.</p>
      <ul>
<li>input_gdf: GeoDataFrame with columns ['point_geometry', 'year', 'geometry'].</li>
</ul>
      <ul>
<li>GeoDataFrame with same number of rows but clipped geometries.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">clip_polygons_to_continent_gbif</span><span class="p">(</span><span class="n">input_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clips the polygon geometry associated with each point to the North American continent.</span>
<span class="sd">    Preserves one row per original point.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - input_gdf: GeoDataFrame with columns [&#39;point_geometry&#39;, &#39;year&#39;, &#39;geometry&#39;].</span>

<span class="sd">    Returns:</span>
<span class="sd">    - GeoDataFrame with same number of rows but clipped geometries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">box</span>

    <span class="c1"># Load continent polygons (land areas)</span>
    <span class="n">land_url</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/land.geojson&quot;</span>
    <span class="p">)</span>
    <span class="n">continents_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">land_url</span><span class="p">)</span>

    <span class="c1"># Ensure valid geometries</span>
    <span class="n">input_gdf</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="p">[</span><span class="n">input_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>
    <span class="n">continents_gdf</span> <span class="o">=</span> <span class="n">continents_gdf</span><span class="p">[</span><span class="n">continents_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>

    <span class="c1"># Reproject if needed</span>
    <span class="k">if</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">continents_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
        <span class="n">input_gdf</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">continents_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Step 1: Assign unique polygon IDs for shared geometries</span>
    <span class="n">input_gdf</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">input_gdf</span><span class="p">[</span><span class="s2">&quot;poly_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="c1"># Step 2: Clip only unique polygons</span>
    <span class="n">unique_polygons</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)[</span>
        <span class="p">[</span><span class="s2">&quot;poly_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">unique_polygons</span><span class="p">,</span> <span class="n">continents_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>

    <span class="c1"># Step 3: Clip again to North America bounding box</span>
    <span class="n">na_bbox</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">-</span><span class="mf">178.2</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">,</span> <span class="o">-</span><span class="mf">49.0</span><span class="p">,</span> <span class="mf">83.3</span><span class="p">)</span>
    <span class="n">na_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">na_bbox</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">input_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">clipped</span><span class="p">,</span> <span class="n">na_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>

    <span class="c1"># Step 4: Collapse fragments back into one geometry per poly_id</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">clipped</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;poly_id&quot;</span><span class="p">)</span>

    <span class="c1"># Step 5: Merge clipped polygons back to original data</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">clipped</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
        <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;poly_id&quot;</span><span class="p">,</span>
        <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_clipped&quot;</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Use clipped geometry if available</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;geometry_clipped&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry_clipped&quot;</span><span class="p">,</span> <span class="s2">&quot;poly_id&quot;</span><span class="p">])</span>

    <span class="c1"># Ensure it&#39;s still a GeoDataFrame with correct CRS</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">input_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="doc doc-heading">
<code class="highlight language-python"><span class="n">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Collapses subgroups in the 'category' column into broader groups and calculates
the centroid for each category.</p>
      <ul>
<li>gdf: GeoDataFrame with a 'category' column and polygon geometries.</li>
</ul>
      <ul>
<li>GeoDataFrame with one centroid per collapsed category.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collapses subgroups in the &#39;category&#39; column into broader groups and calculates</span>
<span class="sd">    the centroid for each category.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf: GeoDataFrame with a &#39;category&#39; column and polygon geometries.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - GeoDataFrame with one centroid per collapsed category.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Standardize &#39;category&#39; names</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># Step 2: Collapse specific subgroups</span>
    <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># Step 3: Calculate centroids per collapsed category</span>
    <span class="n">centroids_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">category</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">):</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">unary_union</span><span class="o">.</span><span class="n">centroid</span>
        <span class="n">centroids_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">centroid</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">centroids_data</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.convert_to_gdf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">euc_data</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.convert_to_gdf" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Converts raw GBIF occurrence data into a cleaned GeoDataFrame,
including geometry, year, and basisOfRecord.</p>
      <ul>
<li>euc_data (list): List of occurrence records (dicts) from GBIF.</li>
</ul>
      <ul>
<li>gpd.GeoDataFrame: Cleaned GeoDataFrame with lat/lon as geometry.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">convert_to_gdf</span><span class="p">(</span><span class="n">euc_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts raw GBIF occurrence data into a cleaned GeoDataFrame,</span>
<span class="sd">    including geometry, year, and basisOfRecord.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - euc_data (list): List of occurrence records (dicts) from GBIF.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - gpd.GeoDataFrame: Cleaned GeoDataFrame with lat/lon as geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">euc_data</span><span class="p">:</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;year&quot;</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;basisOfRecord&quot;</span><span class="p">)</span>
        <span class="n">scientific_name</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;scientificName&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">event_date</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eventDate&quot;</span><span class="p">)</span>
        <span class="n">species</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scientific_name</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="n">scientific_name</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species</span><span class="p">,</span>
                    <span class="s2">&quot;decimalLatitude&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span>
                    <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span>
                    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                    <span class="s2">&quot;eventDate&quot;</span><span class="p">:</span> <span class="n">event_date</span><span class="p">,</span>
                    <span class="s2">&quot;basisOfRecord&quot;</span><span class="p">:</span> <span class="n">basis</span><span class="p">,</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^0-9\-]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d</span><span class="si">{4}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">])</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.count_points_per_category" class="doc doc-heading">
<code class="highlight language-python"><span class="n">count_points_per_category</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.count_points_per_category" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Standardizes category labels and counts how many points fall into each simplified category.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>The original DataFrame with a 'category' column.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>A DataFrame showing total points per simplified category.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_points_per_category</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standardizes category labels and counts how many points fall into each simplified category.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pd.DataFrame): The original DataFrame with a &#39;category&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame showing total points per simplified category.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Standardize the categories</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># Count the number of points per simplified category</span>
    <span class="n">category_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)[</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">category_counts</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="s2">&quot;n_points&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">category_counts</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.create_opacity_slider_map" class="doc doc-heading">
<code class="highlight language-python"><span class="n">create_opacity_slider_map</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.create_opacity_slider_map" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create a new map that overlays map2 on map1 with a year slider,
fading opacity between the two. Original maps are unaffected.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_opacity_slider_map</span><span class="p">(</span>
    <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new map that overlays map2 on map1 with a year slider,</span>
<span class="sd">    fading opacity between the two. Original maps are unaffected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize new map</span>
    <span class="n">swipe_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">)</span>

    <span class="c1"># Re-add tile layers from both maps</span>
    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">map1</span><span class="o">.</span><span class="n">layers</span> <span class="o">+</span> <span class="n">map2</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
            <span class="n">swipe_map</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">))</span>

    <span class="c1"># Recreate and add overlay layers from both maps</span>
    <span class="n">overlay_layers_1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">overlay_layers_2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">map1</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_layer</span> <span class="o">=</span> <span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="n">overlay_layers_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
                <span class="n">swipe_map</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">map2</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_layer</span> <span class="o">=</span> <span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="n">overlay_layers_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
                <span class="n">swipe_map</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="c1"># Get year range</span>
    <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">))</span>
    <span class="n">end_year</span> <span class="o">=</span> <span class="n">end_year</span>
    <span class="n">year_range</span> <span class="o">=</span> <span class="n">end_year</span> <span class="o">-</span> <span class="n">start_year</span>

    <span class="c1"># Create year slider with static labels</span>
    <span class="n">slider</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;80%&quot;</span><span class="p">),</span>
        <span class="n">readout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">slider_box</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">start_year</span><span class="p">),</span> <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)),</span>
            <span class="n">slider</span><span class="p">,</span>
            <span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">end_year</span><span class="p">),</span> <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Update opacity when slider changes</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_opacity</span><span class="p">(</span><span class="n">change</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">change</span><span class="p">[</span><span class="s2">&quot;new&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_year</span><span class="p">)</span> <span class="o">/</span> <span class="n">year_range</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">overlay_layers_1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">):</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="o">**</span><span class="n">layer</span><span class="o">.</span><span class="n">style</span><span class="p">,</span>
                    <span class="s2">&quot;opacity&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="p">,</span>
                    <span class="s2">&quot;fillOpacity&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">overlay_layers_2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">):</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">layer</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="s2">&quot;opacity&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span> <span class="s2">&quot;fillOpacity&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">}</span>

    <span class="n">slider</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">update_opacity</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
    <span class="n">update_opacity</span><span class="p">({</span><span class="s2">&quot;new&quot;</span><span class="p">:</span> <span class="n">start_year</span><span class="p">})</span>  <span class="c1"># Initialize</span>

    <span class="k">return</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">([</span><span class="n">swipe_map</span><span class="p">,</span> <span class="n">slider_box</span><span class="p">])</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.extract_raster_means_single_species" class="doc doc-heading">
<code class="highlight language-python"><span class="n">extract_raster_means_single_species</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.extract_raster_means_single_species" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      
      <ul>
<li>total_df: DataFrame with species-wide averages</li>
<li>category_df: DataFrame with category-level averages</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_raster_means_single_species</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    gdf: GeoDataFrame with polygons (for a single species)</span>
<span class="sd">    species_name: string, the species name to assign to the output</span>

<span class="sd">    Returns:</span>
<span class="sd">    - total_df: DataFrame with species-wide averages</span>
<span class="sd">    - category_df: DataFrame with category-level averages</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Hardcoded GitHub raw URLs for rasters</span>
    <span class="n">raster_urls</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;precipitation(mm)&quot;</span><span class="p">:</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/avg_precip.tif&quot;</span><span class="p">,</span>
        <span class="s2">&quot;temperature(c)&quot;</span><span class="p">:</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/avg_temp.tif&quot;</span><span class="p">,</span>
        <span class="s2">&quot;elevation(m)&quot;</span><span class="p">:</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/elev.tif&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># -------- Species-wide average --------</span>
    <span class="n">row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">raster_urls</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="c1"># Get zonal stats</span>
                    <span class="n">stats</span> <span class="o">=</span> <span class="n">zonal_stats</span><span class="p">(</span>
                        <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">affine</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                        <span class="n">nodata</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
                        <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

                    <span class="c1"># If zonal stats don&#39;t return valid values, use centroid fallback</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;No valid zonal stats for </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">, falling back to centroid method...&quot;</span>
                        <span class="p">)</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
                            <span class="n">centroid</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span>
                            <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">]</span>
                            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                    <span class="c1"># Ensure values are not empty before calculating the mean</span>
                    <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                            <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                        <span class="p">)</span>  <span class="c1"># Ensure the result is a float</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># If no valid values, assign None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>  <span class="c1"># [minx, miny, maxx, maxy]</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitudinal_difference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span>
    <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitudinal_difference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span>

    <span class="n">total_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">row</span><span class="p">])</span>

    <span class="c1"># -------- Normalize and collapse category labels --------</span>
    <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
            <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
            <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
            <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
            <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
            <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># -------- Category-level averages --------</span>
    <span class="n">category_rows</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span><span class="p">]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
            <span class="p">}</span>  <span class="c1"># Reinitialize row here to avoid overwriting</span>
            <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">raster_urls</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                    <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
                    <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                            <span class="c1"># Get zonal stats</span>
                            <span class="n">stats</span> <span class="o">=</span> <span class="n">zonal_stats</span><span class="p">(</span>
                                <span class="n">subset</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                                <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                <span class="n">affine</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                                <span class="n">nodata</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
                                <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

                            <span class="c1"># If zonal stats don&#39;t return valid values, use centroid fallback</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
                                <span class="c1"># print(f&quot;No valid zonal stats for category &#39;{category}&#39; and {var_name}, falling back to centroid method...&quot;)</span>
                                <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">subset</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
                                    <span class="n">centroid</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span>
                                    <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                                    <span class="n">value</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">]</span>
                                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                            <span class="c1"># Ensure values are not empty before calculating the mean</span>
                            <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
                                <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                                    <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                                <span class="p">)</span>  <span class="c1"># Ensure the result is a float</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># If no valid values, assign None</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2"> for category &#39;</span><span class="si">{</span><span class="n">category</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">category_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

    <span class="n">category_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">category_rows</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total_df</span><span class="p">,</span> <span class="n">category_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_gbif_data" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_gbif_data</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_gbif_data" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches occurrence data from GBIF for a specified species, returning up to a specified limit.</p>
      <ul>
<li>species_name (str): The scientific name of the species to query from GBIF.</li>
<li>limit (int, optional): The maximum number of occurrence records to retrieve.
        Defaults to 2000.</li>
</ul>
      <ul>
<li>list[dict]: A list of occurrence records (as dictionaries) containing GBIF data.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_gbif_data</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches occurrence data from GBIF for a specified species, returning up to a specified limit.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - species_name (str): The scientific name of the species to query from GBIF.</span>
<span class="sd">    - limit (int, optional): The maximum number of occurrence records to retrieve.</span>
<span class="sd">            Defaults to 2000.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - list[dict]: A list of occurrence records (as dictionaries) containing GBIF data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initialize the offset to 0</span>
    <span class="n">page_limit</span> <span class="o">=</span> <span class="mi">300</span>  <span class="c1"># GBIF API maximum limit per request</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="c1"># Fetch the data for the current page</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">occurrences</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
            <span class="n">scientificName</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
            <span class="n">hasGeospatialIssue</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">page_limit</span><span class="p">,</span>  <span class="c1"># Fetch up to 300 records per request</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>  <span class="c1"># Adjust offset for pagination</span>
            <span class="n">hasCoordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Only include records with coordinates</span>
        <span class="p">)</span>

        <span class="c1"># Add the fetched data to the list</span>
        <span class="n">all_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">])</span>

        <span class="c1"># If we have enough data, break out of the loop</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Otherwise, increment the offset for the next page of results</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">page_limit</span>  <span class="c1"># Increase by 300 each time since that&#39;s the max page size</span>

    <span class="c1"># Trim the list to exactly the new_limit size if needed</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>

    <span class="c1"># print(f&quot;Fetched {len(all_data)} records (trimmed to requested limit)&quot;)</span>
    <span class="k">return</span> <span class="n">all_data</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_gbif_data_modern" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_gbif_data_modern</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_gbif_data_modern" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches modern occurrence data from GBIF for a specified species between given years.
Works backward from end_year to start_year until the limit is reached.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_gbif_data_modern</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches modern occurrence data from GBIF for a specified species between given years.</span>
<span class="sd">    Works backward from end_year to start_year until the limit is reached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">page_limit</span> <span class="o">=</span> <span class="mi">300</span>
    <span class="n">consecutive_empty_years</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">end_year</span><span class="p">,</span> <span class="n">start_year</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">year_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">occurrences</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="n">scientificName</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
                <span class="n">hasCoordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">hasGeospatialIssue</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">page_limit</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">year_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">page_limit</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">offset</span> <span class="o">+=</span> <span class="n">page_limit</span>

        <span class="k">if</span> <span class="n">year_data</span><span class="p">:</span>
            <span class="n">all_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">year_data</span><span class="p">)</span>
            <span class="n">consecutive_empty_years</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">consecutive_empty_years</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">all_data</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">consecutive_empty_years</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No data found for 5 consecutive years before </span><span class="si">{</span><span class="n">year</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="si">}</span><span class="s2">. Stopping early.&quot;</span>
            <span class="p">)</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">all_data</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_gbif_data_with_historic</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches both modern and historic occurrence data from GBIF for a specified species.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit</code></td>
        <td><code>int</code></td>
        <td><p>Max number of records to fetch for each (modern and historic).</p></td>
        <td><code>2000</code></td>
      </tr>
      <tr>
        <td><code>start_year</code></td>
        <td><code>int</code></td>
        <td><p>The earliest year for modern data and latest year for historic data.</p></td>
        <td><code>1971</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>The most recent year to fetch from.</p></td>
        <td><code>2025</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dict</code></td>
      <td><p>{
    'modern': [...],  # from start_year + 1 to end_year
    'historic': [...] # from start_year backwards to ~1960
}</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_gbif_data_with_historic</span><span class="p">(</span>
    <span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches both modern and historic occurrence data from GBIF for a specified species.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        species_name (str): Scientific name of the species.</span>
<span class="sd">        limit (int): Max number of records to fetch for each (modern and historic).</span>
<span class="sd">        start_year (int): The earliest year for modern data and latest year for historic data.</span>
<span class="sd">        end_year (int): The most recent year to fetch from.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: {</span>
<span class="sd">            &#39;modern&#39;: [...],  # from start_year + 1 to end_year</span>
<span class="sd">            &#39;historic&#39;: [...] # from start_year backwards to ~1960</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modern</span> <span class="o">=</span> <span class="n">fetch_gbif_data_modern</span><span class="p">(</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
        <span class="n">start_year</span><span class="o">=</span><span class="n">start_year</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">historic</span> <span class="o">=</span> <span class="n">fetch_historic_records</span><span class="p">(</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
        <span class="n">year</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>  <span class="c1"># avoid overlap with modern</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;modern&quot;</span><span class="p">:</span> <span class="n">modern</span><span class="p">,</span> <span class="s2">&quot;historic&quot;</span><span class="p">:</span> <span class="n">historic</span><span class="p">}</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="doc doc-heading">
<code class="highlight language-python"><span class="n">full_propagule_pressure_pipeline</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">,</span> <span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Full wrapper pipeline to compute propagule pressure from input data.</p>
<div class="admonition steps">
<p class="admonition-title">Steps</p>
<ol>
<li>Merge category dataframes.</li>
<li>Prepare GeoDataFrame for rasterization.</li>
<li>Map category strings to integers.</li>
<li>Rasterize to show and save versions.</li>
<li>Compute propagule pressure for both rasters.</li>
</ol>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>classified_modern</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame with spatial features and categories.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>northward_rate_df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>Contains northward movement rate per point or cell.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>change</code></td>
        <td><code>DataFrame</code></td>
        <td><p>Contains rate of change per point or cell.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>(pressure_show, pressure_save), both as 2D numpy arrays</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">full_propagule_pressure_pipeline</span><span class="p">(</span>
    <span class="n">classified_modern</span><span class="p">,</span> <span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Full wrapper pipeline to compute propagule pressure from input data.</span>

<span class="sd">    Steps:</span>
<span class="sd">        1. Merge category dataframes.</span>
<span class="sd">        2. Prepare GeoDataFrame for rasterization.</span>
<span class="sd">        3. Map category strings to integers.</span>
<span class="sd">        4. Rasterize to show and save versions.</span>
<span class="sd">        5. Compute propagule pressure for both rasters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        classified_modern (GeoDataFrame): GeoDataFrame with spatial features and categories.</span>
<span class="sd">        northward_rate_df (DataFrame): Contains northward movement rate per point or cell.</span>
<span class="sd">        change (DataFrame): Contains rate of change per point or cell.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (pressure_show, pressure_save), both as 2D numpy arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Merge data</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">merge_category_dataframes</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>

    <span class="c1"># Step 2: Prepare for rasterization</span>
    <span class="n">preped_gdf</span> <span class="o">=</span> <span class="n">prepare_gdf_for_rasterization</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">,</span> <span class="n">merged</span><span class="p">)</span>

    <span class="c1"># Step 3: Map category to integers</span>
    <span class="n">preped_gdf_new</span> <span class="o">=</span> <span class="n">cat_int_mapping</span><span class="p">(</span>
        <span class="n">preped_gdf</span>
    <span class="p">)</span>  <span class="c1"># assumes this was renamed from cat_int_mapping</span>

    <span class="c1"># Step 4: Rasterize</span>
    <span class="n">value_columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;density&quot;</span><span class="p">,</span>
        <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rate of Change&quot;</span><span class="p">,</span>
        <span class="s2">&quot;category_int&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">raster_show</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">show_bounds</span> <span class="o">=</span> <span class="n">rasterize_multiband_gdf_match</span><span class="p">(</span>
        <span class="n">preped_gdf_new</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span>
    <span class="p">)</span>
    <span class="n">raster_save</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">save_bounds</span> <span class="o">=</span> <span class="n">rasterize_multiband_gdf_world</span><span class="p">(</span>
        <span class="n">preped_gdf_new</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span>
    <span class="p">)</span>

    <span class="c1"># Step 5: Compute propagule pressure</span>
    <span class="n">pressure_show</span> <span class="o">=</span> <span class="n">compute_propagule_pressure_range</span><span class="p">(</span><span class="n">raster_show</span><span class="p">)</span>
    <span class="n">pressure_save</span> <span class="o">=</span> <span class="n">compute_propagule_pressure_range</span><span class="p">(</span><span class="n">raster_save</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pressure_show</span><span class="p">,</span> <span class="n">pressure_save</span><span class="p">,</span> <span class="n">show_bounds</span><span class="p">,</span> <span class="n">save_bounds</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.get_species_code_if_exists" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_species_code_if_exists</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.get_species_code_if_exists" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Converts species name to 8-letter key and checks if it exists in REFERENCES.
Returns the code if found, else returns False.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_species_code_if_exists</span><span class="p">(</span><span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts species name to 8-letter key and checks if it exists in REFERENCES.</span>
<span class="sd">    Returns the code if found, else returns False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">REFERENCES</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.get_start_year_from_species" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.get_start_year_from_species" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Converts species name to 8-letter key and looks up the start year in REFERENCES.
If the key is not found, returns 'NA'.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts species name to 8-letter key and looks up the start year in REFERENCES.</span>
<span class="sd">    If the key is not found, returns &#39;NA&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">REFERENCES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;NA&quot;</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.008</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">lat_min</span><span class="o">=</span><span class="mf">6.6</span><span class="p">,</span> <span class="n">lat_max</span><span class="o">=</span><span class="mf">83.3</span><span class="p">,</span> <span class="n">lon_min</span><span class="o">=-</span><span class="mf">178.2</span><span class="p">,</span> <span class="n">lon_max</span><span class="o">=-</span><span class="mf">49.0</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Performs DBSCAN clustering on a GeoDataFrame and returns a GeoDataFrame of
polygons representing clusters with associated points and years.</p>
      <ul>
<li>gdf (GeoDataFrame): Input GeoDataFrame with 'decimalLatitude', 'decimalLongitude', and 'year' columns.</li>
<li>eps (float): Maximum distance between two samples for one to be considered as in the neighborhood of the other.</li>
<li>min_samples (int): The number of samples in a neighborhood for a point to be considered as a core point.</li>
<li>lat_min, lat_max, lon_min, lon_max (float): Bounding box for filtering points. Default values are set to the extent of North America.</li>
</ul>
      <ul>
<li>expanded_gdf (GeoDataFrame): GeoDataFrame of cluster polygons with retained point geometries and years.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="mf">0.008</span><span class="p">,</span>
    <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">lat_min</span><span class="o">=</span><span class="mf">6.6</span><span class="p">,</span>
    <span class="n">lat_max</span><span class="o">=</span><span class="mf">83.3</span><span class="p">,</span>
    <span class="n">lon_min</span><span class="o">=-</span><span class="mf">178.2</span><span class="p">,</span>
    <span class="n">lon_max</span><span class="o">=-</span><span class="mf">49.0</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs DBSCAN clustering on a GeoDataFrame and returns a GeoDataFrame of</span>
<span class="sd">    polygons representing clusters with associated points and years.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf (GeoDataFrame): Input GeoDataFrame with &#39;decimalLatitude&#39;, &#39;decimalLongitude&#39;, and &#39;year&#39; columns.</span>
<span class="sd">    - eps (float): Maximum distance between two samples for one to be considered as in the neighborhood of the other.</span>
<span class="sd">    - min_samples (int): The number of samples in a neighborhood for a point to be considered as a core point.</span>
<span class="sd">    - lat_min, lat_max, lon_min, lon_max (float): Bounding box for filtering points. Default values are set to the extent of North America.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - expanded_gdf (GeoDataFrame): GeoDataFrame of cluster polygons with retained point geometries and years.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;decimalLatitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="s2">&quot;decimalLongitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;GeoDataFrame must contain &#39;decimalLatitude&#39; and &#39;decimalLongitude&#39; columns.&quot;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Clean and filter</span>
    <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data</span><span class="p">[[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;eventDate&quot;</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
        <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lat_min</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lat_max</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lon_min</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;haversine&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">labels_</span>

    <span class="n">gdf_points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]),</span>
        <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">cluster_polygons</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cluster_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">gdf_points</span><span class="p">[</span><span class="n">gdf_points</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">valid_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">cluster_points</span> <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">MultiPoint</span><span class="p">(</span><span class="n">valid_points</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
                    <span class="n">hull_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">corner_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">hull_coords</span><span class="p">]</span>
                    <span class="n">corner_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">corner_points</span> <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">valid_points</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">corner_points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">hull</span> <span class="o">=</span> <span class="n">MultiPoint</span><span class="p">(</span><span class="n">corner_points</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span>
                <span class="n">cluster_polygons</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating convex hull for cluster </span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">expanded_rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">cluster_polygon</span> <span class="ow">in</span> <span class="n">cluster_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">gdf_points</span><span class="p">[</span><span class="n">gdf_points</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cluster_points</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">cluster_polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="n">point</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span>
                <span class="n">cluster_polygon</span>
            <span class="p">):</span>
                <span class="n">expanded_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;polygon_geometry&quot;</span><span class="p">:</span> <span class="n">cluster_polygon</span><span class="p">,</span>
                        <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;eventDate&quot;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">],</span>
                    <span class="p">}</span>
                <span class="p">)</span>

    <span class="n">expanded_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="n">expanded_rows</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;polygon_geometry&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">expanded_rows</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Set &#39;geometry&#39; column as active geometry column explicitly</span>
    <span class="n">expanded_gdf</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Drop &#39;polygon_geometry&#39; as it&#39;s no longer needed</span>
    <span class="n">expanded_gdf</span> <span class="o">=</span> <span class="n">expanded_gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;polygon_geometry&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">expanded_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.merge_category_dataframes" class="doc doc-heading">
<code class="highlight language-python"><span class="n">merge_category_dataframes</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.merge_category_dataframes" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Merges three category-level dataframes on the 'category' column and returns the merged result.
Standardizes 'category' casing to title case before merging.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_category_dataframes</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges three category-level dataframes on the &#39;category&#39; column and returns the merged result.</span>
<span class="sd">    Standardizes &#39;category&#39; casing to title case before merging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="c1"># Standardize &#39;category&#39; column</span>
    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="p">[</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">]:</span>
        <span class="k">if</span> <span class="s2">&quot;Category&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Category&quot;</span><span class="p">:</span> <span class="s2">&quot;category&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>

    <span class="c1"># Merge dataframes</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">northward_rate_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">change</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>

    <span class="c1"># Drop duplicated species columns if they exist</span>
    <span class="k">if</span> <span class="s2">&quot;species_x&quot;</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;species_y&quot;</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;species_x&quot;</span><span class="p">,</span> <span class="s2">&quot;species_y&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">cols_to_keep</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;species&quot;</span><span class="p">,</span>
        <span class="s2">&quot;category&quot;</span><span class="p">,</span>
        <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rate of Change&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols_to_keep</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">merged_df</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="doc doc-heading">
<code class="highlight language-python"><span class="n">prepare_gdf_for_rasterization</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">df_values</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Merge polygon-level GeoDataFrame with range-level category values,
and remove duplicate polygons.</p>
      <ul>
<li>gdf: GeoDataFrame with polygons and category/density</li>
<li>df_values: DataFrame with category, northward_rate_km_per_year, Rate of Change</li>
</ul>
      <ul>
<li>GeoDataFrame with merged attributes and unique geometries</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prepare_gdf_for_rasterization</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">df_values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge polygon-level GeoDataFrame with range-level category values,</span>
<span class="sd">    and remove duplicate polygons.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf: GeoDataFrame with polygons and category/density</span>
<span class="sd">    - df_values: DataFrame with category, northward_rate_km_per_year, Rate of Change</span>

<span class="sd">    Returns:</span>
<span class="sd">    - GeoDataFrame with merged attributes and unique geometries</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Standardize category column casing</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
    <span class="n">df_values</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_values</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>

    <span class="c1"># Merge based on &#39;category&#39;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_values</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Optional: handle missing Rate of Change or movement values</span>
    <span class="n">merged</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s2">&quot;Rate of Change&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Select relevant columns</span>
    <span class="n">relevant_columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
        <span class="s2">&quot;category&quot;</span><span class="p">,</span>
        <span class="s2">&quot;density&quot;</span><span class="p">,</span>
        <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rate of Change&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">final_gdf</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="n">relevant_columns</span><span class="p">]</span>

    <span class="c1"># Drop duplicate geometries</span>
    <span class="n">final_gdf</span> <span class="o">=</span> <span class="n">final_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_gbif_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_gbif_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">,</span> <span class="n">columns_to_keep</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;species&#39;</span><span class="p">,</span> <span class="s1">&#39;decimalLatitude&#39;</span><span class="p">,</span> <span class="s1">&#39;decimalLongitude&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;basisOfRecord&#39;</span><span class="p">])</span></code>


<a href="#ecospat.stand_alone_functions.process_gbif_csv" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Processes a GBIF download CSV, filters and cleans it, and returns a dictionary
of species-specific GeoDataFrames (in memory only).</p>
      <ul>
<li>csv_path (str): Path to the GBIF CSV download (tab-separated).</li>
<li>columns_to_keep (list): List of columns to retain from the CSV.</li>
</ul>
      <ul>
<li>dict: Keys are species names (with underscores), values are GeoDataFrames.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_gbif_csv</span><span class="p">(</span>
    <span class="n">csv_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">columns_to_keep</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;species&quot;</span><span class="p">,</span>
        <span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;basisOfRecord&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a GBIF download CSV, filters and cleans it, and returns a dictionary</span>
<span class="sd">    of species-specific GeoDataFrames (in memory only).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - csv_path (str): Path to the GBIF CSV download (tab-separated).</span>
<span class="sd">    - columns_to_keep (list): List of columns to retain from the CSV.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - dict: Keys are species names (with underscores), values are GeoDataFrames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Load the CSV file</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Filter columns</span>
    <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">columns_to_keep</span><span class="p">]</span>

    <span class="c1"># Group by species</span>
    <span class="n">species_grouped</span> <span class="o">=</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;species&quot;</span><span class="p">)</span>

    <span class="c1"># Prepare output dictionary</span>
    <span class="n">species_gdfs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">species_grouped</span><span class="p">:</span>
        <span class="n">species_key</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="c1"># Clean the data</span>
        <span class="n">group_cleaned</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">group_cleaned</span> <span class="o">=</span> <span class="n">group_cleaned</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
            <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Convert to GeoDataFrame</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">group_cleaned</span><span class="p">,</span>
            <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span>
                <span class="n">group_cleaned</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">],</span> <span class="n">group_cleaned</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add to dictionary</span>
        <span class="n">species_gdfs</span><span class="p">[</span><span class="n">species_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span>

    <span class="k">return</span> <span class="n">species_gdfs</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_gbif_data_pipeline" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_gbif_data_pipeline</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">year_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Processes GBIF occurrence data through a series of spatial filtering and classification steps.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GBIF occurrence data.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species. Required if year_range is not given.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>is_modern</code></td>
        <td><code>bool</code></td>
        <td><p>Whether the data is modern. If False, the pruning by year is skipped.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>year_range</code></td>
        <td><code>tuple or None</code></td>
        <td><p>Start and end years for pruning (only used for modern data).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>The end year for pruning modern data, default is 2025.</p></td>
        <td><code>2025</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>Classified polygons.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_gbif_data_pipeline</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">year_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes GBIF occurrence data through a series of spatial filtering and classification steps.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        gdf (GeoDataFrame): Input GBIF occurrence data.</span>
<span class="sd">        species_name (str): Scientific name of the species. Required if year_range is not given.</span>
<span class="sd">        is_modern (bool): Whether the data is modern. If False, the pruning by year is skipped.</span>
<span class="sd">        year_range (tuple or None): Start and end years for pruning (only used for modern data).</span>
<span class="sd">        end_year (int): The end year for pruning modern data, default is 2025.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: Classified polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">is_modern</span> <span class="ow">and</span> <span class="n">year_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">species_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;species_name must be provided if year_range is not.&quot;</span><span class="p">)</span>

        <span class="c1"># Get start year from species data if available, otherwise use a default</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start year not found for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

        <span class="c1"># Use the provided end_year if available, otherwise default to 2025</span>
        <span class="n">year_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_year</span><span class="p">,</span> <span class="n">end_year</span><span class="p">)</span>

    <span class="c1"># Step 1: Create DBSCAN polygons</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="n">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>

    <span class="c1"># Step 2: Optionally prune by year for modern data</span>
    <span class="k">if</span> <span class="n">is_modern</span><span class="p">:</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="n">prune_by_year</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">year_range</span><span class="p">)</span>

    <span class="c1"># Step 3: Merge and remap</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merge_and_remap_polygons</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Step 4: Remove lakes</span>
    <span class="n">unique_polys_no_lakes</span> <span class="o">=</span> <span class="n">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">)</span>

    <span class="c1"># Step 5: Clip to continents</span>
    <span class="n">clipped_polys</span> <span class="o">=</span> <span class="n">clip_polygons_to_continent_gbif</span><span class="p">(</span><span class="n">unique_polys_no_lakes</span><span class="p">)</span>

    <span class="c1"># Step 6: Assign cluster ID and large polygon</span>
    <span class="n">assigned_poly</span><span class="p">,</span> <span class="n">large_poly</span> <span class="o">=</span> <span class="n">assign_polygon_clusters_gbif_test</span><span class="p">(</span><span class="n">clipped_polys</span><span class="p">)</span>

    <span class="c1"># Step 7: Classify edges</span>
    <span class="n">classified_poly</span> <span class="o">=</span> <span class="n">classify_range_edges_gbif</span><span class="p">(</span><span class="n">assigned_poly</span><span class="p">,</span> <span class="n">large_poly</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">classified_poly</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_species_historical_range" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_species_historical_range</span><span class="p">(</span><span class="n">new_map</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.process_species_historical_range" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Wrapper function to process species range and classification using the HistoricalMap instance.
Performs the following operations:
1. Retrieves the species code using the species name.
2. Loads the historic data for the species.
3. Removes lakes from the species range.
4. Merges touching polygons.
5. Clusters and classifies the polygons.
6. Updates the polygon categories.</p>
      <ul>
<li>new_map (HistoricalMap): The map object that contains the species' historical data.</li>
<li>species_name (str): The name of the species to process.</li>
</ul>
      <ul>
<li>updated_polygon: The updated polygon with classification and category information.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_species_historical_range</span><span class="p">(</span><span class="n">new_map</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to process species range and classification using the HistoricalMap instance.</span>
<span class="sd">    Performs the following operations:</span>
<span class="sd">    1. Retrieves the species code using the species name.</span>
<span class="sd">    2. Loads the historic data for the species.</span>
<span class="sd">    3. Removes lakes from the species range.</span>
<span class="sd">    4. Merges touching polygons.</span>
<span class="sd">    5. Clusters and classifies the polygons.</span>
<span class="sd">    6. Updates the polygon categories.</span>

<span class="sd">    Args:</span>
<span class="sd">    - new_map (HistoricalMap): The map object that contains the species&#39; historical data.</span>
<span class="sd">    - species_name (str): The name of the species to process.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - updated_polygon: The updated polygon with classification and category information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Get the species code</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">get_species_code_if_exists</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">code</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Species code not found for </span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Step 2: Load historic data</span>
    <span class="n">new_map</span><span class="o">.</span><span class="n">load_historic_data</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="c1"># Step 3: Remove lakes from the species range</span>
    <span class="n">range_no_lakes</span> <span class="o">=</span> <span class="n">new_map</span><span class="o">.</span><span class="n">remove_lakes</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">gdfs</span><span class="p">[</span><span class="n">code</span><span class="p">])</span>

    <span class="c1"># Step 4: Merge touching polygons</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merge_touching_groups</span><span class="p">(</span><span class="n">range_no_lakes</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>

    <span class="c1"># Step 5: Cluster and classify polygons</span>
    <span class="n">clustered_polygons</span><span class="p">,</span> <span class="n">largest_polygons</span> <span class="o">=</span> <span class="n">assign_polygon_clusters</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">)</span>
    <span class="n">classified_polygons</span> <span class="o">=</span> <span class="n">classify_range_edges</span><span class="p">(</span><span class="n">clustered_polygons</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">)</span>

    <span class="c1"># Step 6: Update the polygon categories</span>
    <span class="n">updated_polygon</span> <span class="o">=</span> <span class="n">update_polygon_categories</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">,</span> <span class="n">classified_polygons</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_polygon</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.prune_by_year" class="doc doc-heading">
<code class="highlight language-python"><span class="n">prune_by_year</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.prune_by_year" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Prune a DataFrame to only include rows where 'year' is between start_year and end_year (inclusive).</p>
      <ul>
<li>df: pandas.DataFrame or geopandas.GeoDataFrame with a 'year' column</li>
<li>start_year: int, start of the year range (default 1971)</li>
<li>end_year: int, end of the year range (default 2025)</li>
</ul>
      <ul>
<li>pruned DataFrame</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prune_by_year</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prune a DataFrame to only include rows where &#39;year&#39; is between start_year and end_year (inclusive).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - df: pandas.DataFrame or geopandas.GeoDataFrame with a &#39;year&#39; column</span>
<span class="sd">    - start_year: int, start of the year range (default 1971)</span>
<span class="sd">    - end_year: int, end of the year range (default 2025)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - pruned DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;year&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataFrame must have a &#39;year&#39; column.&quot;</span><span class="p">)</span>

    <span class="n">pruned_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_year</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_year</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">pruned_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="doc doc-heading">
<code class="highlight language-python"><span class="n">rasterize_multiband_gdf_match</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution.</p>
      <ul>
<li>gdf: GeoDataFrame with polygon geometries and numeric value_columns</li>
<li>value_columns: list of column names to rasterize into bands</li>
<li>bounds: bounding box (minx, miny, maxx, maxy). If None, computed from gdf.</li>
<li>resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</li>
</ul>
      <ul>
<li>3D numpy array (bands, height, width)</li>
<li>affine transform</li>
<li>bounds used for rasterization</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rasterize_multiband_gdf_match</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf: GeoDataFrame with polygon geometries and numeric value_columns</span>
<span class="sd">    - value_columns: list of column names to rasterize into bands</span>
<span class="sd">    - bounds: bounding box (minx, miny, maxx, maxy). If None, computed from gdf.</span>
<span class="sd">    - resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - 3D numpy array (bands, height, width)</span>
<span class="sd">    - affine transform</span>
<span class="sd">    - bounds used for rasterization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.features</span><span class="w"> </span><span class="kn">import</span> <span class="n">rasterize</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_bounds</span>

    <span class="c1"># Calculate bounds if not given</span>
    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>  <span class="c1"># (minx, miny, maxx, maxy)</span>

    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="c1"># Calculate the width and height of the raster</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>  <span class="c1"># number of cells in the x-direction</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>  <span class="c1"># number of cells in the y-direction</span>

    <span class="c1"># Create the transform based on bounds and resolution</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value_columns</span><span class="p">:</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">])]</span>
        <span class="n">raster</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span>

    <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shape: (bands, height, width)</span>
    <span class="k">return</span> <span class="n">stacked</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="doc doc-heading">
<code class="highlight language-python"><span class="n">rasterize_multiband_gdf_world</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution
covering the entire world.</p>
      <ul>
<li>gdf: GeoDataFrame with polygon geometries and numeric value_columns</li>
<li>value_columns: list of column names to rasterize into bands</li>
<li>resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</li>
</ul>
      <ul>
<li>3D numpy array (bands, height, width)</li>
<li>affine transform</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rasterize_multiband_gdf_world</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution</span>
<span class="sd">    covering the entire world.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf: GeoDataFrame with polygon geometries and numeric value_columns</span>
<span class="sd">    - value_columns: list of column names to rasterize into bands</span>
<span class="sd">    - resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - 3D numpy array (bands, height, width)</span>
<span class="sd">    - affine transform</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.features</span><span class="w"> </span><span class="kn">import</span> <span class="n">rasterize</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_bounds</span>

    <span class="c1"># Define the bounds of the entire world</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">90</span>

    <span class="c1"># Calculate the width and height of the raster based on the resolution</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>  <span class="c1"># number of cells in the x-direction</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>  <span class="c1"># number of cells in the y-direction</span>

    <span class="c1"># Create the transform based on the world bounds and new resolution</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value_columns</span><span class="p">:</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">])]</span>
        <span class="n">raster</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span>
                <span class="n">height</span><span class="p">,</span>
                <span class="n">width</span><span class="p">,</span>
            <span class="p">),</span>  <span class="c1"># Ensure this matches the calculated height and width</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># Fill areas outside the polygons with NaN</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span>

    <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shape: (bands, height, width)</span>
    <span class="k">return</span> <span class="n">stacked</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.recreate_layer" class="doc doc-heading">
<code class="highlight language-python"><span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.recreate_layer" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Safely recreate a common ipyleaflet layer (e.g., GeoJSON) from its core properties
to avoid modifying the original object.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Safely recreate a common ipyleaflet layer (e.g., GeoJSON) from its core properties</span>
<span class="sd">    to avoid modifying the original object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">GeoJSON</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">GeoJSON</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">style</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="n">hover_style</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">hover_style</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="n">name</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TileLayer</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Layer type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="si">}</span><span class="s2"> not supported in recreate_layer.&quot;</span>
        <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">polygons_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Removes lake polygons from range polygons and retains all rows in the original data,
updating the geometry where lakes intersect with polygons.</p>
      <ul>
<li>polygons_gdf: GeoDataFrame of range polygons.</li>
</ul>
      <ul>
<li>Updated GeoDataFrame with lakes removed from intersecting polygons.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">polygons_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes lake polygons from range polygons and retains all rows in the original data,</span>
<span class="sd">    updating the geometry where lakes intersect with polygons.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - polygons_gdf: GeoDataFrame of range polygons.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - Updated GeoDataFrame with lakes removed from intersecting polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load lakes GeoDataFrame</span>
    <span class="n">lakes_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/lakes_na.geojson&quot;</span>
    <span class="n">lakes_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">lakes_url</span><span class="p">)</span>

    <span class="c1"># Ensure geometries are valid</span>
    <span class="n">polygons_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="p">[</span><span class="n">polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>
    <span class="n">lakes_gdf</span> <span class="o">=</span> <span class="n">lakes_gdf</span><span class="p">[</span><span class="n">lakes_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>

    <span class="c1"># Ensure CRS matches before performing spatial operations</span>
    <span class="k">if</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">lakes_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CRS mismatch! Transforming </span><span class="si">{</span><span class="n">polygons_gdf</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">lakes_gdf</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">polygons_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">lakes_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Add an ID column to identify unique polygons (group points by shared polygons)</span>
    <span class="n">polygons_gdf</span><span class="p">[</span><span class="s2">&quot;unique_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="c1"># Deduplicate the range polygons by geometry and add ID to unique polygons</span>
    <span class="n">unique_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
    <span class="n">unique_gdf</span><span class="p">[</span><span class="s2">&quot;unique_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
        <span class="s2">&quot;geometry&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>  <span class="c1"># Assign shared unique IDs</span>

    <span class="c1"># Clip the unique polygons with the lake polygons (difference operation)</span>
    <span class="n">polygons_no_lakes_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">unique_gdf</span><span class="p">,</span> <span class="n">lakes_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;difference&quot;</span><span class="p">)</span>

    <span class="c1"># Merge the modified unique polygons back with the original GeoDataFrame using &#39;unique_id&#39;</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">polygons_no_lakes_gdf</span><span class="p">[[</span><span class="s2">&quot;unique_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;unique_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Now update the geometry column with the new geometries from the modified polygons</span>
    <span class="n">merged_polygons</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_polygons</span><span class="p">[</span><span class="s2">&quot;geometry_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
        <span class="n">merged_polygons</span><span class="p">[</span><span class="s2">&quot;geometry_x&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Drop the temporary columns that were used for merging</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merged_polygons</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry_y&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry_x&quot;</span><span class="p">,</span> <span class="s2">&quot;unique_id&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Ensure the resulting DataFrame is still a GeoDataFrame</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="c1"># Set CRS correctly</span>
    <span class="n">merged_polygons</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">polygons_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Return the updated GeoDataFrame</span>
    <span class="k">return</span> <span class="n">merged_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_raster_to_downloads_global" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_raster_to_downloads_global</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_raster_to_downloads_global" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Saves a NumPy raster array as a GeoTIFF to the user's Downloads folder.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>array</code></td>
        <td><code>ndarray</code></td>
        <td><p>The raster data to save.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bounds</code></td>
        <td><code>tuple</code></td>
        <td><p>Bounding box in the format (minx, miny, maxx, maxy).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species</code></td>
        <td><code>str</code></td>
        <td><p>The species name to use in the output filename.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_raster_to_downloads_global</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves a NumPy raster array as a GeoTIFF to the user&#39;s Downloads folder.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        array (ndarray): The raster data to save.</span>
<span class="sd">        bounds (tuple): Bounding box in the format (minx, miny, maxx, maxy).</span>
<span class="sd">        species (str): The species name to use in the output filename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Clean filename</span>
        <span class="n">clean_species</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">clean_species</span><span class="si">}</span><span class="s2">_persistence_raster_global.tif&quot;</span>

        <span class="c1"># Determine Downloads path</span>
        <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Generate raster transform</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span>
            <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Write to GeoTIFF</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">downloads_path</span><span class="p">,</span>
            <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># print(f&quot;Raster successfully saved to: {downloads_path}&quot;)</span>
        <span class="k">return</span> <span class="n">downloads_path</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving raster: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_raster_to_downloads_range" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_raster_to_downloads_range</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_raster_to_downloads_range" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Saves a NumPy raster array as a GeoTIFF to the user's Downloads folder.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>array</code></td>
        <td><code>ndarray</code></td>
        <td><p>The raster data to save.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bounds</code></td>
        <td><code>tuple</code></td>
        <td><p>Bounding box in the format (minx, miny, maxx, maxy).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species</code></td>
        <td><code>str</code></td>
        <td><p>The species name to use in the output filename.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_raster_to_downloads_range</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves a NumPy raster array as a GeoTIFF to the user&#39;s Downloads folder.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        array (ndarray): The raster data to save.</span>
<span class="sd">        bounds (tuple): Bounding box in the format (minx, miny, maxx, maxy).</span>
<span class="sd">        species (str): The species name to use in the output filename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Clean filename</span>
        <span class="n">clean_species</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">clean_species</span><span class="si">}</span><span class="s2">_persistence_raster.tif&quot;</span>

        <span class="c1"># Determine Downloads path</span>
        <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Generate raster transform</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span>
            <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Write to GeoTIFF</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">downloads_path</span><span class="p">,</span>
            <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># print(f&quot;Raster successfully saved to: {downloads_path}&quot;)</span>
        <span class="k">return</span> <span class="n">downloads_path</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving raster: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.summarize_polygons_with_points" class="doc doc-heading">
<code class="highlight language-python"><span class="n">summarize_polygons_with_points</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.summarize_polygons_with_points" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Summarizes number of points per unique polygon (geometry_id), retaining one row per polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>A DataFrame where each row represents a point with associated polygon metadata.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gpd.GeoDataFrame</code></td>
      <td><p>A summarized GeoDataFrame with one row per unique polygon and geometry set.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">summarize_polygons_with_points</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summarizes number of points per unique polygon (geometry_id), retaining one row per polygon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pd.DataFrame): A DataFrame where each row represents a point with associated polygon metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gpd.GeoDataFrame: A summarized GeoDataFrame with one row per unique polygon and geometry set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Group by geometry_id and aggregate</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">agg</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>  <span class="c1"># keep one polygon geometry</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>  <span class="c1"># assume category is the same within a polygon</span>
                <span class="s2">&quot;AREA&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>  <span class="c1"># optional: keep AREA of the polygon</span>
                <span class="s2">&quot;cluster&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>  <span class="c1"># optional: keep cluster ID</span>
                <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span>  <span class="c1"># count how many points fall in this polygon</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;n_points&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">summary_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.update_polygon_categories_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">update_polygon_categories_gbif</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Updates polygon categories based on overlaps with island states and closest large polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>largest_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of largest polygons with 'geometry' and 'category'.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>classified_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Output from classify_range_edges_gbif with 'geom_id' and 'category'.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>island_states_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of island state geometries.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>classified_polygons_gdf with updated 'category' values for overlapping polygons.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_polygon_categories_gbif</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates polygon categories based on overlaps with island states and closest large polygon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        largest_polygons_gdf (GeoDataFrame): GeoDataFrame of largest polygons with &#39;geometry&#39; and &#39;category&#39;.</span>
<span class="sd">        classified_polygons_gdf (GeoDataFrame): Output from classify_range_edges_gbif with &#39;geom_id&#39; and &#39;category&#39;.</span>
<span class="sd">        island_states_gdf (GeoDataFrame): GeoDataFrame of island state geometries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: classified_polygons_gdf with updated &#39;category&#39; values for overlapping polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>

    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="c1"># Ensure all CRS match</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">or</span> <span class="s2">&quot;EPSG:3395&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Convert list of Series to DataFrame</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">)</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">largest_polygons_gdf</span><span class="p">,</span>
            <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>  <span class="c1"># or whatever CRS you&#39;re using</span>
        <span class="p">)</span>

    <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="n">unique_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polygons</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Merge back geom_id to the full dataframe</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">unique_polygons</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Spatial join to find overlapping polygons with island states</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
        <span class="n">classified_polygons_gdf</span><span class="p">,</span> <span class="n">island_states_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span>
    <span class="p">)</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">)</span>

    <span class="c1"># Compute centroids for distance matching</span>
    <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>

    <span class="c1"># Extract coordinates</span>
    <span class="n">overlapping_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Compute distances and find nearest large polygon</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">overlapping_centroids</span><span class="p">,</span> <span class="n">largest_centroids</span><span class="p">)</span>
    <span class="n">closest_indices</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Assign nearest large polygon&#39;s category</span>
    <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">closest_indices</span><span class="p">][</span>
        <span class="s2">&quot;category&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Update classified polygons using &#39;geom_id&#39;</span>
    <span class="n">updated_classified_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">update_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">updated_classified_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">update_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_classified_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="doc doc-heading">
<code class="highlight language-python"><span class="n">update_polygon_categories_gbif_test</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Updates polygon categories based on overlaps with island states and nearest large polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>largest_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of largest polygons with 'geometry' and 'category'.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>classified_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of smaller polygons (one row per point) with potential duplicate geometries.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>classified_polygons_gdf with updated 'category' values for overlapping polygons.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_polygon_categories_gbif_test</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates polygon categories based on overlaps with island states and nearest large polygon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        largest_polygons_gdf (GeoDataFrame): GeoDataFrame of largest polygons with &#39;geometry&#39; and &#39;category&#39;.</span>
<span class="sd">        classified_polygons_gdf (GeoDataFrame): GeoDataFrame of smaller polygons (one row per point) with potential duplicate geometries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: classified_polygons_gdf with updated &#39;category&#39; values for overlapping polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>

    <span class="c1"># Load island states</span>
    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="c1"># Ensure all CRS match</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">or</span> <span class="s2">&quot;EPSG:3395&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">)</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span>
        <span class="p">)</span>

    <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;core&quot;</span>

    <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Assign unique ID per unique geometry</span>
    <span class="n">unique_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polygons</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Merge geom_id back to full dataframe</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">unique_polygons</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Find overlaps with island states</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
        <span class="n">classified_polygons_gdf</span><span class="p">,</span> <span class="n">island_states_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span>
    <span class="p">)</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Compute centroids</span>
    <span class="n">overlapping_centroids</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>

    <span class="c1"># Compute distances between centroids</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span>
        <span class="n">overlapping_centroids</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="n">largest_centroids</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">closest_indices</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Assign categories from nearest large polygon</span>
    <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">closest_indices</span><span class="p">][</span>
        <span class="s2">&quot;category&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Update the categories in the original dataframe</span>
    <span class="n">update_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">updated_classified_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">updated_classified_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">update_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_classified_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago" title="May 13, 2025 21:56:25"><span class="timeago" datetime="2025-05-13T21:56:25+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="May 13, 2025 21:56:25">2025-05-13</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago" title="May 13, 2025 21:56:25"><span class="timeago" datetime="2025-05-13T21:56:25+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="May 13, 2025 21:56:25">2025-05-13</span>
  </span>

    
    
    
  </aside>





                

              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 - 2024 Alivia Nytko
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.tracking", "navigation.top", "search.highlight", "search.share"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.13a4f30d.min.js"></script>
      
        <script src="../js/timeago.min.js"></script>
      
        <script src="../js/timeago_mkdocs_material.js"></script>
      
    
  </body>
</html>