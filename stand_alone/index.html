
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Ecological Spatial Analysis - A python package to characterize the range dynamics and shifts of North American tree species.">
      
      
        <meta name="author" content="anytko">
      
      
        <link rel="canonical" href="https://anytko.github.io/ecospat/stand_alone/">
      
      
        <link rel="prev" href="../ecospat/">
      
      
        <link rel="next" href="../mapping/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.18">
    
    
      
        <title>stand alone module - ecospat</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Google+Sans:300,300i,400,400i,700,700i%7CRegular:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Google Sans";--md-code-font:"Regular"}</style>
      
    
    
      <link rel="stylesheet" href="../css/timeago.css">
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#stand-alone-module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="ecospat" class="md-header__button md-logo" aria-label="ecospat" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ecospat
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              stand alone module
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/anytko/ecospat" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ecospat" class="md-nav__button md-logo" aria-label="ecospat" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    ecospat
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/anytko/ecospat" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Contributing
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Changelog
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/anytko/ecospat/issues" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Report Issues
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/leaflet_base/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Leaflet base
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/folium_base/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Folium base
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/range_edges/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Range edges
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/range_movement/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Range movement
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/population_density/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Population density
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/persistence_raster/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Persistence raster
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/individual_persistence/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Individual persistence
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/widgets.ipynb" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    None
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ecospat/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ecospat module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    stand alone module
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    stand alone module
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions" class="md-nav__link">
    <span class="md-ellipsis">
      ecospat.stand_alone_functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_northward_shift" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_northward_shift()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_species_distribution" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_species_distribution()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_species_distribution_south" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_species_distribution_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.assign_polygon_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      assign_polygon_clusters()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.assign_polygon_clusters_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      assign_polygon_clusters_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.assign_polygon_clusters_gbif_test" class="md-nav__link">
    <span class="md-ellipsis">
      assign_polygon_clusters_gbif_test()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_density" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_density()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_northward_change_rate" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_northward_change_rate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_rate_of_change_first_last" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_rate_of_change_first_last()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.cat_int_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      cat_int_mapping()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.categorize_species" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.categorize_species_south" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_species_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges_gbif_south" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges_gbif_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      clip_polygons_to_continent_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      collapse_and_calculate_centroids()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.compute_individual_persistence" class="md-nav__link">
    <span class="md-ellipsis">
      compute_individual_persistence()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.compute_propagule_pressure_range" class="md-nav__link">
    <span class="md-ellipsis">
      compute_propagule_pressure_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.convert_to_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      convert_to_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.count_points_per_category" class="md-nav__link">
    <span class="md-ellipsis">
      count_points_per_category()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.create_interactive_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_interactive_map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.create_opacity_slider_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_opacity_slider_map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.extract_raster_means_single_species" class="md-nav__link">
    <span class="md-ellipsis">
      extract_raster_means_single_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_modern" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_modern()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_with_historic()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_historic_records" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_historic_records()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      full_propagule_pressure_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_species_code_if_exists" class="md-nav__link">
    <span class="md-ellipsis">
      get_species_code_if_exists()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_start_year_from_species" class="md-nav__link">
    <span class="md-ellipsis">
      get_start_year_from_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      make_dbscan_polygons_with_points_from_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_and_remap_polygons" class="md-nav__link">
    <span class="md-ellipsis">
      merge_and_remap_polygons()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_category_dataframes" class="md-nav__link">
    <span class="md-ellipsis">
      merge_category_dataframes()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_touching_groups" class="md-nav__link">
    <span class="md-ellipsis">
      merge_touching_groups()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prepare_data" class="md-nav__link">
    <span class="md-ellipsis">
      prepare_data()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="md-nav__link">
    <span class="md-ellipsis">
      prepare_gdf_for_rasterization()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_data_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline_south" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_data_pipeline_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_species_historical_range" class="md-nav__link">
    <span class="md-ellipsis">
      process_species_historical_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prune_by_year" class="md-nav__link">
    <span class="md-ellipsis">
      prune_by_year()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_match()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_world()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.recreate_layer" class="md-nav__link">
    <span class="md-ellipsis">
      recreate_layer()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      remove_lakes_and_plot_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_historic_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_historic_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_individual_persistence_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_individual_persistence_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_modern_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_modern_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_global" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_global()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_range" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_results_as_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_results_as_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.summarize_polygons_for_point_plot" class="md-nav__link">
    <span class="md-ellipsis">
      summarize_polygons_for_point_plot()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.summarize_polygons_with_points" class="md-nav__link">
    <span class="md-ellipsis">
      summarize_polygons_with_points()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif_test()
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mapping/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ipyleaflet mapping module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../foliummap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    folium mapping module
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions" class="md-nav__link">
    <span class="md-ellipsis">
      ecospat.stand_alone_functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_northward_shift" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_northward_shift()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_species_distribution" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_species_distribution()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.analyze_species_distribution_south" class="md-nav__link">
    <span class="md-ellipsis">
      analyze_species_distribution_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.assign_polygon_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      assign_polygon_clusters()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.assign_polygon_clusters_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      assign_polygon_clusters_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.assign_polygon_clusters_gbif_test" class="md-nav__link">
    <span class="md-ellipsis">
      assign_polygon_clusters_gbif_test()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_density" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_density()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_northward_change_rate" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_northward_change_rate()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.calculate_rate_of_change_first_last" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_rate_of_change_first_last()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.cat_int_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      cat_int_mapping()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.categorize_species" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.categorize_species_south" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_species_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.classify_range_edges_gbif_south" class="md-nav__link">
    <span class="md-ellipsis">
      classify_range_edges_gbif_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      clip_polygons_to_continent_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      collapse_and_calculate_centroids()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.compute_individual_persistence" class="md-nav__link">
    <span class="md-ellipsis">
      compute_individual_persistence()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.compute_propagule_pressure_range" class="md-nav__link">
    <span class="md-ellipsis">
      compute_propagule_pressure_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.convert_to_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      convert_to_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.count_points_per_category" class="md-nav__link">
    <span class="md-ellipsis">
      count_points_per_category()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.create_interactive_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_interactive_map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.create_opacity_slider_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_opacity_slider_map()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.extract_raster_means_single_species" class="md-nav__link">
    <span class="md-ellipsis">
      extract_raster_means_single_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_modern" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_modern()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_gbif_data_with_historic()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.fetch_historic_records" class="md-nav__link">
    <span class="md-ellipsis">
      fetch_historic_records()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      full_propagule_pressure_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_species_code_if_exists" class="md-nav__link">
    <span class="md-ellipsis">
      get_species_code_if_exists()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.get_start_year_from_species" class="md-nav__link">
    <span class="md-ellipsis">
      get_start_year_from_species()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="md-nav__link">
    <span class="md-ellipsis">
      make_dbscan_polygons_with_points_from_gdf()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_and_remap_polygons" class="md-nav__link">
    <span class="md-ellipsis">
      merge_and_remap_polygons()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_category_dataframes" class="md-nav__link">
    <span class="md-ellipsis">
      merge_category_dataframes()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.merge_touching_groups" class="md-nav__link">
    <span class="md-ellipsis">
      merge_touching_groups()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prepare_data" class="md-nav__link">
    <span class="md-ellipsis">
      prepare_data()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="md-nav__link">
    <span class="md-ellipsis">
      prepare_gdf_for_rasterization()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_data_pipeline()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline_south" class="md-nav__link">
    <span class="md-ellipsis">
      process_gbif_data_pipeline_south()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.process_species_historical_range" class="md-nav__link">
    <span class="md-ellipsis">
      process_species_historical_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.prune_by_year" class="md-nav__link">
    <span class="md-ellipsis">
      prune_by_year()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_match()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="md-nav__link">
    <span class="md-ellipsis">
      rasterize_multiband_gdf_world()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.recreate_layer" class="md-nav__link">
    <span class="md-ellipsis">
      recreate_layer()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      remove_lakes_and_plot_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_historic_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_historic_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_individual_persistence_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_individual_persistence_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_modern_gbif_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_modern_gbif_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_global" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_global()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_raster_to_downloads_range" class="md-nav__link">
    <span class="md-ellipsis">
      save_raster_to_downloads_range()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.save_results_as_csv" class="md-nav__link">
    <span class="md-ellipsis">
      save_results_as_csv()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.summarize_polygons_for_point_plot" class="md-nav__link">
    <span class="md-ellipsis">
      summarize_polygons_for_point_plot()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.summarize_polygons_with_points" class="md-nav__link">
    <span class="md-ellipsis">
      summarize_polygons_with_points()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif()
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="md-nav__link">
    <span class="md-ellipsis">
      update_polygon_categories_gbif_test()
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                



                  


  
  


<h1 id="stand-alone-module">stand alone module<a class="headerlink" href="#stand-alone-module" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="ecospat.stand_alone_functions"></a>
    <div class="doc doc-contents first">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.analyze_northward_shift" class="doc doc-heading">
<code class="highlight language-python"><span class="n">analyze_northward_shift</span><span class="p">(</span><span class="n">gdf_hist</span><span class="p">,</span> <span class="n">gdf_new</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.analyze_northward_shift" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Wrapper function that collapses categories and computes the rate of northward shift
in km/year between historical and modern GeoDataFrames.</p>
      <ul>
<li>gdf_hist: Historical GeoDataFrame with 'category' column and polygon geometries</li>
<li>gdf_new: Modern GeoDataFrame with 'category' column and polygon geometries</li>
<li>species_name: Name of the species to determine the starting year</li>
<li>end_year: The final year of modern data (default is 2025)</li>
</ul>
      <ul>
<li>DataFrame with each category's northward change and rate of change</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">analyze_northward_shift</span><span class="p">(</span>
    <span class="n">gdf_hist</span><span class="p">,</span> <span class="n">gdf_new</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function that collapses categories and computes the rate of northward shift</span>
<span class="sd">    in km/year between historical and modern GeoDataFrames.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf_hist: Historical GeoDataFrame with &#39;category&#39; column and polygon geometries</span>
<span class="sd">    - gdf_new: Modern GeoDataFrame with &#39;category&#39; column and polygon geometries</span>
<span class="sd">    - species_name: Name of the species to determine the starting year</span>
<span class="sd">    - end_year: The final year of modern data (default is 2025)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - DataFrame with each category&#39;s northward change and rate of change</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Collapse and calculate centroids</span>
    <span class="n">gdf_hist</span> <span class="o">=</span> <span class="n">gdf_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gdf_new</span> <span class="o">=</span> <span class="n">gdf_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">hist_centroids</span> <span class="o">=</span> <span class="n">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf_hist</span><span class="p">)</span>
    <span class="n">new_centroids</span> <span class="o">=</span> <span class="n">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf_new</span><span class="p">)</span>

    <span class="c1"># Step 2: Calculate northward movement</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_northward_change_rate</span><span class="p">(</span>
        <span class="n">hist_gdf</span><span class="o">=</span><span class="n">hist_centroids</span><span class="p">,</span>
        <span class="n">new_gdf</span><span class="o">=</span><span class="n">new_centroids</span><span class="p">,</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">user_start_year</span><span class="o">=</span><span class="n">user_start_year</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.analyze_species_distribution" class="doc doc-heading">
<code class="highlight language-python"><span class="n">analyze_species_distribution</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">record_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;north_america&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.analyze_species_distribution" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches and processes modern and historic GBIF occurrence data for a given species,
producing classified polygons with density estimates.</p>
<p>The function:
    1. Determines the start year that separates modern vs. historic records
       (using internal lookups or a user-provided fallback).
    2. Fetches GBIF occurrence data with optional basisOfRecord filtering.
    3. Converts raw records into GeoDataFrames for spatial processing.
    4. Runs the GBIF processing pipeline to create, merge, prune, and classify polygons.
    5. Computes density estimates for both modern and historic polygons.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species to analyze.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>record_limit</code></td>
        <td><code>int, default=100</code></td>
        <td><p>Maximum number of occurrence records to fetch from GBIF.</p></td>
        <td><code>100</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int, default=2025</code></td>
        <td><p>Most recent year for modern data. Used if no explicit year range is provided.</p></td>
        <td><code>2025</code></td>
      </tr>
      <tr>
        <td><code>user_start_year</code></td>
        <td><code>int</code></td>
        <td><p>Fallback start year if the species-specific year cannot be determined.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>basisOfRecord</code></td>
        <td><code>str or list</code></td>
        <td><p>GBIF basisOfRecord filter (e.g., "OBSERVATION", "PRESERVED_SPECIMEN").
If None, no filter is applied.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>continent</code></td>
        <td><code>str, default=&#34;north_america&#34;</code></td>
        <td><p>Continent filter used for clipping polygons.</p></td>
        <td><code>&#39;north_america&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>classified_modern (GeoDataFrame): Classified polygons from modern records, including density estimates.
    classified_historic (GeoDataFrame): Classified polygons from historic records, including density estimates.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If the start year cannot be determined internally and <code>user_start_year</code> is not provided.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">analyze_species_distribution</span><span class="p">(</span>
    <span class="n">species_name</span><span class="p">,</span>
    <span class="n">record_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span>
    <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;north_america&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches and processes modern and historic GBIF occurrence data for a given species,</span>
<span class="sd">    producing classified polygons with density estimates.</span>

<span class="sd">    The function:</span>
<span class="sd">        1. Determines the start year that separates modern vs. historic records</span>
<span class="sd">           (using internal lookups or a user-provided fallback).</span>
<span class="sd">        2. Fetches GBIF occurrence data with optional basisOfRecord filtering.</span>
<span class="sd">        3. Converts raw records into GeoDataFrames for spatial processing.</span>
<span class="sd">        4. Runs the GBIF processing pipeline to create, merge, prune, and classify polygons.</span>
<span class="sd">        5. Computes density estimates for both modern and historic polygons.</span>

<span class="sd">    Args:</span>
<span class="sd">        species_name (str): Scientific name of the species to analyze.</span>
<span class="sd">        record_limit (int, default=100): Maximum number of occurrence records to fetch from GBIF.</span>
<span class="sd">        end_year (int, default=2025): Most recent year for modern data. Used if no explicit year range is provided.</span>
<span class="sd">        user_start_year (int, optional): Fallback start year if the species-specific year cannot be determined.</span>
<span class="sd">        basisOfRecord (str or list, optional): GBIF basisOfRecord filter (e.g., &quot;OBSERVATION&quot;, &quot;PRESERVED_SPECIMEN&quot;).</span>
<span class="sd">            If None, no filter is applied.</span>
<span class="sd">        continent (str, default=&quot;north_america&quot;): Continent filter used for clipping polygons.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            classified_modern (GeoDataFrame): Classified polygons from modern records, including density estimates.</span>
<span class="sd">            classified_historic (GeoDataFrame): Classified polygons from historic records, including density estimates.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the start year cannot be determined internally and `user_start_year` is not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bounding_boxes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;north_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;europe&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">},</span>
        <span class="s2">&quot;asia&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
        <span class="c1"># South America split at equator</span>
        <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">55</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="c1"># Africa split at equator</span>
        <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;oceania&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounding_boxes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent &#39;</span><span class="si">{</span><span class="n">continent</span><span class="si">}</span><span class="s2">&#39; not recognized. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">bounding_boxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounding_boxes</span><span class="p">[</span><span class="n">continent</span><span class="p">]</span>

    <span class="n">lat_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span>
    <span class="n">lat_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">]</span>
    <span class="n">lon_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span>
    <span class="n">lon_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]</span>

    <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
        <span class="c1"># If missing, check if the user provided one</span>
        <span class="k">if</span> <span class="n">user_start_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_start_year</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Start year not found internally for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and no user start year was provided.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span>
        <span class="n">continent_call</span> <span class="o">=</span> <span class="s2">&quot;south_america&quot;</span>
    <span class="k">elif</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span>
        <span class="n">continent_call</span> <span class="o">=</span> <span class="s2">&quot;africa&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">continent_call</span> <span class="o">=</span> <span class="n">continent</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">fetch_gbif_data_with_historic</span><span class="p">(</span>
        <span class="n">species_name</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">record_limit</span><span class="p">,</span>
        <span class="n">start_year</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">basisOfRecord</span><span class="o">=</span><span class="n">basisOfRecord</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent_call</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Modern records (&gt;= </span><span class="si">{</span><span class="n">start_year</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;modern&quot;</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Historic records (&lt; </span><span class="si">{</span><span class="n">start_year</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;historic&quot;</span><span class="p">]))</span>

    <span class="n">modern_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;modern&quot;</span><span class="p">]</span>
    <span class="n">historic_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;historic&quot;</span><span class="p">]</span>

    <span class="n">historic_gdf</span> <span class="o">=</span> <span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">historic_data</span><span class="p">)</span>
    <span class="n">modern_gdf</span> <span class="o">=</span> <span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">modern_data</span><span class="p">)</span>

    <span class="c1"># Let the pipeline dynamically determine the year range</span>
    <span class="n">classified_modern</span> <span class="o">=</span> <span class="n">process_gbif_data_pipeline</span><span class="p">(</span>
        <span class="n">modern_gdf</span><span class="p">,</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">user_start_year</span><span class="o">=</span><span class="n">user_start_year</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">classified_historic</span> <span class="o">=</span> <span class="n">process_gbif_data_pipeline</span><span class="p">(</span>
        <span class="n">historic_gdf</span><span class="p">,</span>
        <span class="n">is_modern</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">user_start_year</span><span class="o">=</span><span class="n">user_start_year</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">classified_modern</span> <span class="o">=</span> <span class="n">calculate_density</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">)</span>
    <span class="n">classified_historic</span> <span class="o">=</span> <span class="n">calculate_density</span><span class="p">(</span><span class="n">classified_historic</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">classified_modern</span><span class="p">,</span> <span class="n">classified_historic</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.analyze_species_distribution_south" class="doc doc-heading">
<code class="highlight language-python"><span class="n">analyze_species_distribution_south</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">record_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;oceania&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.analyze_species_distribution_south" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches and processes GBIF occurrence data for a species in a southern
hemisphere context, separating modern and historic records, classifying
spatial polygons, and computing density estimates.</p>
<p>This function determines the species' historic vs. modern cutoff year
(with optional user override), applies spatial and temporal filters,
converts the data to GeoDataFrames, and runs the GBIF processing pipeline.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>record_limit</code></td>
        <td><code>int</code></td>
        <td><p>Maximum number of records to fetch from GBIF.
Default is 100.</p></td>
        <td><code>100</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>Most recent year to include in modern records.
Default is 2025.</p></td>
        <td><code>2025</code></td>
      </tr>
      <tr>
        <td><code>user_start_year</code></td>
        <td><code>int or None</code></td>
        <td><p>User-specified cutoff year for
separating historic and modern records, used if no internal start
year can be determined. Default is None.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>basisOfRecord</code></td>
        <td><code>str, list, or None</code></td>
        <td><p>Basis-of-record filter for GBIF data
(e.g., "PRESERVED_SPECIMEN", "OBSERVATION"). Default is None (no filtering).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>continent</code></td>
        <td><code>str</code></td>
        <td><p>Continent identifier used for filtering and
processing logic. Default is "oceania".</p></td>
        <td><code>&#39;oceania&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple[GeoDataFrame, GeoDataFrame]</code></td>
      <td><ul>
<li>classified_modern: GeoDataFrame of classified modern records with
      density information.<ul>
<li>classified_historic: GeoDataFrame of classified historic records with
  density information.</li>
</ul>
</li>
</ul></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If the species' start year cannot be determined internally
and <code>user_start_year</code> is not provided.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">analyze_species_distribution_south</span><span class="p">(</span>
    <span class="n">species_name</span><span class="p">,</span>
    <span class="n">record_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span>
    <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;oceania&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches and processes GBIF occurrence data for a species in a southern</span>
<span class="sd">    hemisphere context, separating modern and historic records, classifying</span>
<span class="sd">    spatial polygons, and computing density estimates.</span>

<span class="sd">    This function determines the species&#39; historic vs. modern cutoff year</span>
<span class="sd">    (with optional user override), applies spatial and temporal filters,</span>
<span class="sd">    converts the data to GeoDataFrames, and runs the GBIF processing pipeline.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        species_name (str): Scientific name of the species.</span>
<span class="sd">        record_limit (int, optional): Maximum number of records to fetch from GBIF.</span>
<span class="sd">            Default is 100.</span>
<span class="sd">        end_year (int, optional): Most recent year to include in modern records.</span>
<span class="sd">            Default is 2025.</span>
<span class="sd">        user_start_year (int or None, optional): User-specified cutoff year for</span>
<span class="sd">            separating historic and modern records, used if no internal start</span>
<span class="sd">            year can be determined. Default is None.</span>
<span class="sd">        basisOfRecord (str, list, or None, optional): Basis-of-record filter for GBIF data</span>
<span class="sd">            (e.g., &quot;PRESERVED_SPECIMEN&quot;, &quot;OBSERVATION&quot;). Default is None (no filtering).</span>
<span class="sd">        continent (str, optional): Continent identifier used for filtering and</span>
<span class="sd">            processing logic. Default is &quot;oceania&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[GeoDataFrame, GeoDataFrame]:</span>
<span class="sd">            - classified_modern: GeoDataFrame of classified modern records with</span>
<span class="sd">              density information.</span>
<span class="sd">            - classified_historic: GeoDataFrame of classified historic records with</span>
<span class="sd">              density information.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the species&#39; start year cannot be determined internally</span>
<span class="sd">            and `user_start_year` is not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bounding_boxes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;north_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;europe&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">},</span>
        <span class="s2">&quot;asia&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
        <span class="c1"># South America split at equator</span>
        <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">55</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="c1"># Africa split at equator</span>
        <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;oceania&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounding_boxes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent &#39;</span><span class="si">{</span><span class="n">continent</span><span class="si">}</span><span class="s2">&#39; not recognized. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">bounding_boxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounding_boxes</span><span class="p">[</span><span class="n">continent</span><span class="p">]</span>

    <span class="n">lat_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span>
    <span class="n">lat_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">]</span>
    <span class="n">lon_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span>
    <span class="n">lon_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]</span>

    <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
        <span class="c1"># If missing, check if the user provided one</span>
        <span class="k">if</span> <span class="n">user_start_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_start_year</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Start year not found internally for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and no user start year was provided.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span>
        <span class="n">continent_call</span> <span class="o">=</span> <span class="s2">&quot;south_america&quot;</span>
    <span class="k">elif</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span>
        <span class="n">continent_call</span> <span class="o">=</span> <span class="s2">&quot;africa&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">continent_call</span> <span class="o">=</span> <span class="n">continent</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">fetch_gbif_data_with_historic</span><span class="p">(</span>
        <span class="n">species_name</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">record_limit</span><span class="p">,</span>
        <span class="n">start_year</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">basisOfRecord</span><span class="o">=</span><span class="n">basisOfRecord</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent_call</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Modern records (&gt;= </span><span class="si">{</span><span class="n">start_year</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;modern&quot;</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Historic records (&lt; </span><span class="si">{</span><span class="n">start_year</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;historic&quot;</span><span class="p">]))</span>

    <span class="n">modern_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;modern&quot;</span><span class="p">]</span>
    <span class="n">historic_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;historic&quot;</span><span class="p">]</span>

    <span class="n">historic_gdf</span> <span class="o">=</span> <span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">historic_data</span><span class="p">)</span>
    <span class="n">modern_gdf</span> <span class="o">=</span> <span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">modern_data</span><span class="p">)</span>

    <span class="c1"># Let the pipeline dynamically determine the year range</span>
    <span class="n">classified_modern</span> <span class="o">=</span> <span class="n">process_gbif_data_pipeline_south</span><span class="p">(</span>
        <span class="n">modern_gdf</span><span class="p">,</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">user_start_year</span><span class="o">=</span><span class="n">user_start_year</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">classified_historic</span> <span class="o">=</span> <span class="n">process_gbif_data_pipeline_south</span><span class="p">(</span>
        <span class="n">historic_gdf</span><span class="p">,</span>
        <span class="n">is_modern</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">user_start_year</span><span class="o">=</span><span class="n">user_start_year</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">classified_modern</span> <span class="o">=</span> <span class="n">calculate_density</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">)</span>
    <span class="n">classified_historic</span> <span class="o">=</span> <span class="n">calculate_density</span><span class="p">(</span><span class="n">classified_historic</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">classified_modern</span><span class="p">,</span> <span class="n">classified_historic</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.assign_polygon_clusters" class="doc doc-heading">
<code class="highlight language-python"><span class="n">assign_polygon_clusters</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.assign_polygon_clusters" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Assigns cluster IDs to polygons based on size, spatial proximity, and exclusion of island-state polygons.</p>
<p>The function identifies the largest polygons that do not intersect or touch
island-state polygons as initial cluster seeds. Remaining polygons are then
assigned to clusters based on proximity to these largest polygons.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>polygon_gdf</code></td>
        <td><code>geopandas.GeoDataFrame</code></td>
        <td><p>A GeoDataFrame containing polygon geometries
and an 'AREA' column representing the size of each polygon.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>A tuple containing:
    - geopandas.GeoDataFrame: The original GeoDataFrame with an added 'cluster' column.
    - list: A list of GeoSeries representing the largest polygons used as cluster seeds.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assign_polygon_clusters</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns cluster IDs to polygons based on size, spatial proximity, and exclusion of island-state polygons.</span>

<span class="sd">    The function identifies the largest polygons that do not intersect or touch</span>
<span class="sd">    island-state polygons as initial cluster seeds. Remaining polygons are then</span>
<span class="sd">    assigned to clusters based on proximity to these largest polygons.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon_gdf (geopandas.GeoDataFrame): A GeoDataFrame containing polygon geometries</span>
<span class="sd">            and an &#39;AREA&#39; column representing the size of each polygon.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - geopandas.GeoDataFrame: The original GeoDataFrame with an added &#39;cluster&#39; column.</span>
<span class="sd">            - list: A list of GeoSeries representing the largest polygons used as cluster seeds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>

    <span class="c1"># Read the GeoJSON from the URL</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="n">range_test</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Step 1: Reproject if necessary</span>
    <span class="k">if</span> <span class="n">range_test</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
        <span class="n">range_test</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="n">range_test</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;AREA&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">largest_polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Add the first polygon as part of num_largest with cluster 0</span>
    <span class="n">first_polygon</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Check if the first polygon intersects or touches any island-state polygons</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="n">largest_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_polygon</span><span class="p">)</span>
        <span class="n">largest_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Step 2: Loop through the remaining polygons and check area and proximity</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_test</span><span class="p">)):</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Calculate the area difference between the largest polygon and the current polygon</span>
        <span class="n">area_difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">])</span>

        <span class="c1"># Set the polygon threshold dynamically based on the area difference</span>
        <span class="k">if</span> <span class="n">area_difference</span> <span class="o">&gt;</span> <span class="mi">600</span><span class="p">:</span>
            <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="k">elif</span> <span class="n">area_difference</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.005</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.2</span>

        <span class="c1"># Check if the polygon&#39;s area is greater than or equal to the threshold</span>
        <span class="k">if</span> <span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">polygon_threshold</span> <span class="o">*</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]:</span>

            <span class="c1"># Check if the polygon intersects or touches any island-state polygons</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Calculate the distance between the polygon&#39;s centroid and all existing centroids in largest_centroids</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="n">largest_centroids</span><span class="p">:</span>
                <span class="n">lat_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">lon_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

                <span class="c1"># If both latitude and longitude difference is below the threshold, this polygon is close</span>
                <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">lon_diff</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat_diff</span><span class="p">,</span> <span class="n">lon_diff</span><span class="p">))</span>

            <span class="c1"># Check if the polygon is not within proximity threshold</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">distances</span><span class="p">:</span>
                <span class="c1"># Add to num_largest polygons if it&#39;s not within proximity and meets the area condition</span>
                <span class="n">largest_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                <span class="n">largest_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
                <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c1"># Step 3: Assign clusters to the remaining polygons based on proximity to largest polygons</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">range_test</span><span class="p">)):</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># If the polygon is part of num_largest, it gets its own cluster (already assigned)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">largest_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">largest_polygon</span> <span class="ow">in</span> <span class="n">largest_polygons</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Find the closest centroid in largest_centroids</span>
        <span class="n">closest_centroid_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">largest_centroids</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lat_diff</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">lon_diff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="n">closest_centroid_idx</span> <span class="o">=</span> <span class="n">j</span>

        <span class="c1"># Assign the closest cluster</span>
        <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_centroid_idx</span><span class="p">)</span>

    <span class="c1"># Add the clusters as a new column to the GeoDataFrame</span>
    <span class="n">range_test</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusters</span>

    <span class="k">return</span> <span class="n">range_test</span><span class="p">,</span> <span class="n">largest_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.assign_polygon_clusters_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">assign_polygon_clusters_gbif</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.assign_polygon_clusters_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Assigns polygons in a GeoDataFrame to clusters based on size, proximity,
and geographic isolation, while ignoring polygons that intersect or touch
predefined island states. Also identifies the largest polygon in each cluster.</p>
<p>The function simplifies geometries, calculates polygon areas,
and iteratively assigns clusters using centroid distances.
Polygons with similar centroids within thresholds are grouped together.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>polygon_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame containing polygon geometries
in a geographic CRS (EPSG:4326). Must contain at least the 'geometry' column.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>A tuple containing:
    - GeoDataFrame: The input polygons with an additional 'cluster' column
      indicating the assigned cluster ID for each polygon.
    - list: A list of GeoSeries representing the largest polygon from each cluster.</p></td>
    </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>Polygons intersecting or touching islands (from a predefined GeoJSON) are ignored
  when determining largest polygons.</li>
<li>Clustering is based on centroid proximity, with a threshold of 5 degrees for
  latitude and longitude differences.</li>
<li>Areas are calculated in square kilometers after transforming to EPSG:3395.</li>
<li>The returned GeoDataFrame is transformed back to EPSG:4326.</li>
</ul>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assign_polygon_clusters_gbif</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns polygons in a GeoDataFrame to clusters based on size, proximity,</span>
<span class="sd">    and geographic isolation, while ignoring polygons that intersect or touch</span>
<span class="sd">    predefined island states. Also identifies the largest polygon in each cluster.</span>

<span class="sd">    The function simplifies geometries, calculates polygon areas,</span>
<span class="sd">    and iteratively assigns clusters using centroid distances.</span>
<span class="sd">    Polygons with similar centroids within thresholds are grouped together.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon_gdf (GeoDataFrame): Input GeoDataFrame containing polygon geometries</span>
<span class="sd">            in a geographic CRS (EPSG:4326). Must contain at least the &#39;geometry&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - GeoDataFrame: The input polygons with an additional &#39;cluster&#39; column</span>
<span class="sd">              indicating the assigned cluster ID for each polygon.</span>
<span class="sd">            - list: A list of GeoSeries representing the largest polygon from each cluster.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Polygons intersecting or touching islands (from a predefined GeoJSON) are ignored</span>
<span class="sd">          when determining largest polygons.</span>
<span class="sd">        - Clustering is based on centroid proximity, with a threshold of 5 degrees for</span>
<span class="sd">          latitude and longitude differences.</span>
<span class="sd">        - Areas are calculated in square kilometers after transforming to EPSG:3395.</span>
<span class="sd">        - The returned GeoDataFrame is transformed back to EPSG:4326.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>

    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="c1"># Simplify geometries to avoid precision issues (optional)</span>
    <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="n">range_test</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Transform to CRS for area calculation</span>
    <span class="k">if</span> <span class="n">range_test</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
        <span class="n">range_test</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="n">range_test</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="mf">1e6</span>
    <span class="n">range_test</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;AREA&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">largest_polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">first_polygon</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="n">largest_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_polygon</span><span class="p">)</span>
        <span class="n">largest_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_test</span><span class="p">)):</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">area_difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">])</span>

        <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="c1"># if area_difference &gt; 10000:</span>
        <span class="c1"># polygon_threshold = 0.2</span>
        <span class="c1"># else:</span>
        <span class="c1"># polygon_threshold = 0.5</span>

        <span class="k">if</span> <span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">polygon_threshold</span> <span class="o">*</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="n">largest_centroids</span><span class="p">:</span>
                <span class="n">lat_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">lon_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">lon_diff</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat_diff</span><span class="p">,</span> <span class="n">lon_diff</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">distances</span><span class="p">:</span>
                <span class="n">largest_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                <span class="n">largest_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
                <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Assign clusters to all polygons</span>
    <span class="n">assigned_clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">range_test</span><span class="p">)):</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Use a tolerance when checking for geometry equality</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">equals_exact</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">largest_polygons</span>
        <span class="p">):</span>
            <span class="n">assigned_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">idx</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">lp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">equals_exact</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">)</span>
                <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">closest_centroid_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">largest_centroids</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lat_diff</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">lon_diff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="n">closest_centroid_idx</span> <span class="o">=</span> <span class="n">j</span>

        <span class="n">assigned_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_centroid_idx</span><span class="p">)</span>

    <span class="n">range_test</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assigned_clusters</span>

    <span class="c1"># Return to the original CRS</span>
    <span class="n">range_test</span> <span class="o">=</span> <span class="n">range_test</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">range_test</span><span class="p">,</span> <span class="n">largest_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.assign_polygon_clusters_gbif_test" class="doc doc-heading">
<code class="highlight language-python"><span class="n">assign_polygon_clusters_gbif_test</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.assign_polygon_clusters_gbif_test" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Assigns cluster IDs to polygons based on their size and spatial proximity to core zones of admixture, excluding islands.</p>
<p>This function:
  - Simplifies polygon geometries to avoid precision issues.
  - Generates a unique ID for each polygon using an MD5 hash of its geometry.
  - Calculates polygon areas in square kilometers.
  - Identifies the largest polygons as cluster centers or core zones, avoiding polygons on islands.
  - Assigns other polygons to the nearest cluster based on centroid distance.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>polygon_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>A GeoDataFrame containing polygon geometries to cluster.
                        Must have a 'geometry' column.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><ul>
<li>GeoDataFrame: The original GeoDataFrame with two new columns:
        * "geometry_id": Unique ID for each polygon.
        * "cluster": Assigned cluster ID.
        * "AREA": Polygon area in km².<ul>
<li>list: A list of the largest polygons used as cluster centers (GeoSeries rows).</li>
</ul>
</li>
</ul></td>
    </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>Polygons that intersect or touch islands (from a predefined island GeoJSON) are excluded from cluster centers.</li>
<li>Thresholds for selecting large polygons as cluster centers are dynamic based on the area of the largest polygon.</li>
<li>CRS of the returned GeoDataFrame is EPSG:4326.</li>
</ul>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assign_polygon_clusters_gbif_test</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns cluster IDs to polygons based on their size and spatial proximity to core zones of admixture, excluding islands.</span>

<span class="sd">    This function:</span>
<span class="sd">      - Simplifies polygon geometries to avoid precision issues.</span>
<span class="sd">      - Generates a unique ID for each polygon using an MD5 hash of its geometry.</span>
<span class="sd">      - Calculates polygon areas in square kilometers.</span>
<span class="sd">      - Identifies the largest polygons as cluster centers or core zones, avoiding polygons on islands.</span>
<span class="sd">      - Assigns other polygons to the nearest cluster based on centroid distance.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon_gdf (GeoDataFrame): A GeoDataFrame containing polygon geometries to cluster.</span>
<span class="sd">                                    Must have a &#39;geometry&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            - GeoDataFrame: The original GeoDataFrame with two new columns:</span>
<span class="sd">                * &quot;geometry_id&quot;: Unique ID for each polygon.</span>
<span class="sd">                * &quot;cluster&quot;: Assigned cluster ID.</span>
<span class="sd">                * &quot;AREA&quot;: Polygon area in km².</span>
<span class="sd">            - list: A list of the largest polygons used as cluster centers (GeoSeries rows).</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Polygons that intersect or touch islands (from a predefined island GeoJSON) are excluded from cluster centers.</span>
<span class="sd">        - Thresholds for selecting large polygons as cluster centers are dynamic based on the area of the largest polygon.</span>
<span class="sd">        - CRS of the returned GeoDataFrame is EPSG:4326.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>

    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="c1"># Simplify to avoid precision issues (optional)</span>
    <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Create a unique ID for each geometry (by hashing WKT string)</span>
    <span class="n">polygon_gdf</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">wkb</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Subset unique polygons</span>
    <span class="n">unique_polys</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Calculate area (in meters^2)</span>
    <span class="k">if</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
        <span class="n">unique_polys</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>
    <span class="n">unique_polys</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="mf">1e6</span>
    <span class="n">unique_polys</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;AREA&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Start clustering</span>
    <span class="n">largest_polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cluster_ids</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">first_polygon</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="n">largest_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_polygon</span><span class="p">)</span>
        <span class="n">largest_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="n">cluster_ids</span><span class="p">[</span><span class="n">first_polygon</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_polys</span><span class="p">)):</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cluster_ids</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># polygon_threshold = 0.3  # Default threshold</span>

        <span class="c1"># Dynamically set threshold based on size of largest polygon</span>
        <span class="k">if</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">500000</span><span class="p">:</span>
            <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="k">elif</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">150000</span><span class="p">:</span>
            <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">polygon_threshold</span> <span class="o">=</span> <span class="mf">0.3</span>

        <span class="k">if</span> <span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">polygon_threshold</span> <span class="o">*</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">centroid</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
            <span class="n">too_close</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">largest_centroids</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">too_close</span><span class="p">:</span>
                <span class="n">new_cluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">)</span>
                <span class="n">largest_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                <span class="n">largest_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>
                <span class="n">cluster_ids</span><span class="p">[</span><span class="n">polygon</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_cluster</span>

    <span class="c1"># Assign remaining polygons to nearest cluster</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">geom_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">geom_id</span> <span class="ow">in</span> <span class="n">cluster_ids</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">largest_centroids</span>
        <span class="p">]</span>
        <span class="n">cluster_ids</span><span class="p">[</span><span class="n">geom_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>

    <span class="c1"># Map clusters back to full polygon_gdf</span>
    <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cluster_ids</span><span class="p">)</span>

    <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="n">unique_polys</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Return to original CRS</span>
    <span class="n">polygon_gdf</span> <span class="o">=</span> <span class="n">polygon_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">polygon_gdf</span><span class="p">,</span> <span class="n">largest_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.calculate_density" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_density</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.calculate_density" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Calculate point density per polygon in a GeoDataFrame.</p>
<p>This function counts the number of points associated with each unique polygon and computes the density as points per square kilometer based on the area each polygon. The result is added as a new 'density' column.</p>
      <p>df : pandas.DataFrame or geopandas.GeoDataFrame
    Input DataFrame containing:
    - 'geometry_id': identifier for each polygon
    - 'AREA': area of the polygon in km²
    - Other columns are preserved</p>
      <p>pandas.DataFrame
    Input DataFrame with an additional column:
    - 'density': number of points per km² for each polygon</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">calculate_density</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate point density per polygon in a GeoDataFrame.</span>

<span class="sd">    This function counts the number of points associated with each unique polygon and computes the density as points per square kilometer based on the area each polygon. The result is added as a new &#39;density&#39; column.</span>

<span class="sd">    Args:</span>
<span class="sd">    df : pandas.DataFrame or geopandas.GeoDataFrame</span>
<span class="sd">        Input DataFrame containing:</span>
<span class="sd">        - &#39;geometry_id&#39;: identifier for each polygon</span>
<span class="sd">        - &#39;AREA&#39;: area of the polygon in km²</span>
<span class="sd">        - Other columns are preserved</span>

<span class="sd">    Returns:</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        Input DataFrame with an additional column:</span>
<span class="sd">        - &#39;density&#39;: number of points per km² for each polygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Count number of points per unique polygon (using geometry_id)</span>
    <span class="n">point_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;point_count&quot;</span><span class="p">)</span>

    <span class="c1"># Merge point counts back into original dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">point_counts</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate density: points per km²</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;point_count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;point_count&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.calculate_northward_change_rate" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_northward_change_rate</span><span class="p">(</span><span class="n">hist_gdf</span><span class="p">,</span> <span class="n">new_gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.calculate_northward_change_rate" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Compare centroids within each group/category in two GeoDataFrames and calculate:
- The northward change in kilometers
- The rate of northward change in km per year</p>
      <ul>
<li>hist_gdf: GeoDataFrame with historical centroids (1 centroid per category)</li>
<li>new_gdf: GeoDataFrame with new centroids (1 centroid per category)</li>
<li>species_name: Name of the species to determine start year</li>
<li>end_year: The final year of the new data (default 2025)</li>
</ul>
      <ul>
<li>A DataFrame with category, northward change in km, and rate of northward change in km/year</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">calculate_northward_change_rate</span><span class="p">(</span>
    <span class="n">hist_gdf</span><span class="p">,</span> <span class="n">new_gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare centroids within each group/category in two GeoDataFrames and calculate:</span>
<span class="sd">    - The northward change in kilometers</span>
<span class="sd">    - The rate of northward change in km per year</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - hist_gdf: GeoDataFrame with historical centroids (1 centroid per category)</span>
<span class="sd">    - new_gdf: GeoDataFrame with new centroids (1 centroid per category)</span>
<span class="sd">    - species_name: Name of the species to determine start year</span>
<span class="sd">    - end_year: The final year of the new data (default 2025)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - A DataFrame with category, northward change in km, and rate of northward change in km/year</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Dynamically get the starting year based on species</span>
    <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">user_start_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_start_year</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start year not found for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

    <span class="c1"># Calculate the time difference in years</span>
    <span class="n">years_elapsed</span> <span class="o">=</span> <span class="n">end_year</span> <span class="o">-</span> <span class="n">start_year</span>

    <span class="c1"># Merge the two GeoDataFrames on the &#39;category&#39; column</span>
    <span class="n">merged_gdf</span> <span class="o">=</span> <span class="n">hist_gdf</span><span class="p">[[</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">new_gdf</span><span class="p">[[</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_hist&quot;</span><span class="p">,</span> <span class="s2">&quot;_new&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># List to store the changes</span>
    <span class="n">changes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">merged_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span>
        <span class="n">centroid_hist</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_hist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
        <span class="n">centroid_new</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_new&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>

        <span class="c1"># Latitude difference</span>
        <span class="n">northward_change_lat</span> <span class="o">=</span> <span class="n">centroid_new</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid_hist</span><span class="o">.</span><span class="n">y</span>
        <span class="n">northward_change_km</span> <span class="o">=</span> <span class="n">northward_change_lat</span> <span class="o">*</span> <span class="mf">111.32</span>
        <span class="n">northward_rate_km_per_year</span> <span class="o">=</span> <span class="n">northward_change_km</span> <span class="o">/</span> <span class="n">years_elapsed</span>

        <span class="n">changes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
                <span class="s2">&quot;northward_change_km&quot;</span><span class="p">:</span> <span class="n">northward_change_km</span><span class="p">,</span>
                <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">:</span> <span class="n">northward_rate_km_per_year</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">changes</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.calculate_rate_of_change_first_last" class="doc doc-heading">
<code class="highlight language-python"><span class="n">calculate_rate_of_change_first_last</span><span class="p">(</span><span class="n">historical_df</span><span class="p">,</span> <span class="n">modern_df</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">custom_end_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.calculate_rate_of_change_first_last" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Calculate the rate of change in category percentages for a species between
the earliest (historical) and latest (modern) time periods.</p>
<p>This function collapses detailed categories into broader ones, aligns the
historical and modern time periods, calculates percentages of individuals in each category
per period, and computes the rate of change over time.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>historical_df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>A DataFrame containing historical occurrence records for the species.
Must include a "category" column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>modern_df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>A DataFrame containing modern occurrence records for the species.
Must include a "category" column and an "eventDate" column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>The species for which the rate of change is calculated.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>custom_end_year</code></td>
        <td><code>int</code></td>
        <td><p>User-specified end year for the modern time period. Defaults to None,
in which case the latest year in modern_df or the current year is used.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>user_start_year</code></td>
        <td><code>int</code></td>
        <td><p>User-specified start year if the species start year cannot be determined.
Defaults to None.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>A DataFrame with one row per collapsed category containing:
    - 'collapsed_category': The broader category name.
    - 'start_time_period': The time period of the historical data.
    - 'end_time_period': The time period of the modern data.
    - 'rate_of_change_first_last': The calculated rate of change in
      percentage per year between the two periods.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If the species start year cannot be determined and no
        user_start_year is provided.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>The function collapses detailed categories using a predefined mapping:
    "leading (0.99)", "leading (0.95)", "leading (0.9)" → "leading"
    "trailing (0.1)", "trailing (0.05)" → "trailing"
    "relict (0.01 latitude)", "relict (longitude)" → "relict"</li>
<li>Percentages are calculated per collapsed category relative to the
  total count of that category across both periods.</li>
</ul>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">calculate_rate_of_change_first_last</span><span class="p">(</span>
    <span class="n">historical_df</span><span class="p">,</span> <span class="n">modern_df</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">custom_end_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the rate of change in category percentages for a species between</span>
<span class="sd">    the earliest (historical) and latest (modern) time periods.</span>

<span class="sd">    This function collapses detailed categories into broader ones, aligns the</span>
<span class="sd">    historical and modern time periods, calculates percentages of individuals in each category</span>
<span class="sd">    per period, and computes the rate of change over time.</span>

<span class="sd">    Args:</span>
<span class="sd">        historical_df (pd.DataFrame):</span>
<span class="sd">            A DataFrame containing historical occurrence records for the species.</span>
<span class="sd">            Must include a &quot;category&quot; column.</span>
<span class="sd">        modern_df (pd.DataFrame):</span>
<span class="sd">            A DataFrame containing modern occurrence records for the species.</span>
<span class="sd">            Must include a &quot;category&quot; column and an &quot;eventDate&quot; column.</span>
<span class="sd">        species_name (str):</span>
<span class="sd">            The species for which the rate of change is calculated.</span>
<span class="sd">        custom_end_year (int, optional):</span>
<span class="sd">            User-specified end year for the modern time period. Defaults to None,</span>
<span class="sd">            in which case the latest year in modern_df or the current year is used.</span>
<span class="sd">        user_start_year (int, optional):</span>
<span class="sd">            User-specified start year if the species start year cannot be determined.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with one row per collapsed category containing:</span>
<span class="sd">            - &#39;collapsed_category&#39;: The broader category name.</span>
<span class="sd">            - &#39;start_time_period&#39;: The time period of the historical data.</span>
<span class="sd">            - &#39;end_time_period&#39;: The time period of the modern data.</span>
<span class="sd">            - &#39;rate_of_change_first_last&#39;: The calculated rate of change in</span>
<span class="sd">              percentage per year between the two periods.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the species start year cannot be determined and no</span>
<span class="sd">                    user_start_year is provided.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function collapses detailed categories using a predefined mapping:</span>
<span class="sd">            &quot;leading (0.99)&quot;, &quot;leading (0.95)&quot;, &quot;leading (0.9)&quot; → &quot;leading&quot;</span>
<span class="sd">            &quot;trailing (0.1)&quot;, &quot;trailing (0.05)&quot; → &quot;trailing&quot;</span>
<span class="sd">            &quot;relict (0.01 latitude)&quot;, &quot;relict (longitude)&quot; → &quot;relict&quot;</span>
<span class="sd">        - Percentages are calculated per collapsed category relative to the</span>
<span class="sd">          total count of that category across both periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="c1"># Mapping of detailed categories to collapsed ones</span>
    <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Apply mapping to both dataframes</span>
    <span class="n">historical_df</span><span class="p">[</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">historical_df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">category_mapping</span>
    <span class="p">)</span>
    <span class="n">modern_df</span><span class="p">[</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">modern_df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># Get species start year and define start time period</span>

    <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">user_start_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_start_year</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start year not found for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

    <span class="n">first_period_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_year</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
    <span class="n">first_period_end</span> <span class="o">=</span> <span class="n">start_year</span>
    <span class="n">adjusted_first_period</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">first_period_start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">first_period_end</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Define end time period</span>
    <span class="n">current_year</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">.</span><span class="n">year</span>
    <span class="n">modern_df</span><span class="p">[</span><span class="s2">&quot;event_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
        <span class="n">modern_df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span>
    <span class="n">last_event_year</span> <span class="o">=</span> <span class="n">modern_df</span><span class="p">[</span><span class="s2">&quot;event_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">custom_end_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">last_period_end</span> <span class="o">=</span> <span class="n">custom_end_year</span>
        <span class="n">last_period_start</span> <span class="o">=</span> <span class="n">custom_end_year</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">last_period_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">last_event_year</span><span class="p">,</span> <span class="n">current_year</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">last_period_end</span> <span class="o">=</span> <span class="n">current_year</span>

    <span class="n">adjusted_last_period</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_period_start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">last_period_end</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Add time_period to each dataframe</span>
    <span class="n">historical_df</span> <span class="o">=</span> <span class="n">historical_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">historical_df</span><span class="p">[</span><span class="s2">&quot;time_period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_first_period</span>
    <span class="n">modern_df</span> <span class="o">=</span> <span class="n">modern_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">modern_df</span><span class="p">[</span><span class="s2">&quot;time_period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_last_period</span>

    <span class="c1"># Combine for grouped calculations</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">historical_df</span><span class="p">,</span> <span class="n">modern_df</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Drop missing categories or time_periods</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">,</span> <span class="s2">&quot;time_period&quot;</span><span class="p">])</span>

    <span class="c1"># Group and calculate percentages</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">combined_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">,</span> <span class="s2">&quot;time_period&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">total_counts</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">)[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
    <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;percentage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">total_counts</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="c1"># Calculate rate of change between the two periods</span>
    <span class="n">rate_of_change_first_last</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">cat_data</span> <span class="o">=</span> <span class="n">grouped</span><span class="p">[</span><span class="n">grouped</span><span class="p">[</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span><span class="p">]</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="n">cat_data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;time_period&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">adjusted_first_period</span> <span class="ow">in</span> <span class="n">periods</span><span class="o">.</span><span class="n">index</span>
            <span class="ow">and</span> <span class="n">adjusted_last_period</span> <span class="ow">in</span> <span class="n">periods</span><span class="o">.</span><span class="n">index</span>
        <span class="p">):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">periods</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adjusted_first_period</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">periods</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adjusted_last_period</span><span class="p">]</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">last</span><span class="p">[</span><span class="s2">&quot;percentage&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">first</span><span class="p">[</span><span class="s2">&quot;percentage&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">last_period_end</span> <span class="o">-</span> <span class="n">first_period_start</span>
            <span class="p">)</span>
            <span class="n">rate_of_change_first_last</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;collapsed_category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
                    <span class="s2">&quot;start_time_period&quot;</span><span class="p">:</span> <span class="n">adjusted_first_period</span><span class="p">,</span>
                    <span class="s2">&quot;end_time_period&quot;</span><span class="p">:</span> <span class="n">adjusted_last_period</span><span class="p">,</span>
                    <span class="s2">&quot;rate_of_change_first_last&quot;</span><span class="p">:</span> <span class="n">rate</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rate_of_change_first_last</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.cat_int_mapping" class="doc doc-heading">
<code class="highlight language-python"><span class="n">cat_int_mapping</span><span class="p">(</span><span class="n">preped_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.cat_int_mapping" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Copies the input GeoDataFrame, maps the 'category' column to integers,
and transforms the CRS to EPSG:4326.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>preped_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame with a 'category' column.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>Transformed GeoDataFrame with a new 'category_int' column and EPSG:4326 CRS.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cat_int_mapping</span><span class="p">(</span><span class="n">preped_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies the input GeoDataFrame, maps the &#39;category&#39; column to integers,</span>
<span class="sd">    and transforms the CRS to EPSG:4326.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        preped_gdf (GeoDataFrame): Input GeoDataFrame with a &#39;category&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: Transformed GeoDataFrame with a new &#39;category_int&#39; column and EPSG:4326 CRS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">category_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Core&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Leading&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Trailing&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Relict&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">preped_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category_int&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">category_map</span><span class="p">)</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.categorize_species" class="doc doc-heading">
<code class="highlight language-python"><span class="n">categorize_species</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.categorize_species" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Categorizes species into movement groups based on leading, core, and trailing rates.</p>
<p>This function examines northward movement rates (km/year) for different range edges: leading edge, core, and trailing edge. It handles cases where
all three edges are present or only two edges are available.
Each species is assigned a movement category based on the combination of these rates.</p>
<p>Categories include:
    - "poleward expansion together"
    - "contracting together"
    - "pull apart"
    - "reabsorption"
    - "stability"
    - "likely moving together"
    - "likely stable"
    - "likely pull apart"
    - "likely reabsorption"
    - "uncategorized"</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Input DataFrame containing species movement data. Must include:
- 'species' (str): Name of the species
- 'category' (str): Edge category, e.g., 'leading', 'core', or 'trailing'
- 'northward_rate_km_per_year' (float): Northward movement rate for that edge</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>A DataFrame with one row per species, including:
    - 'species': Species name
    - 'leading': Leading edge rate (float or None)
    - 'core': Core rate (float or None)
    - 'trailing': Trailing edge rate (float or None)
    - 'category': Assigned movement category (str)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">categorize_species</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Categorizes species into movement groups based on leading, core, and trailing rates.</span>

<span class="sd">    This function examines northward movement rates (km/year) for different range edges: leading edge, core, and trailing edge. It handles cases where</span>
<span class="sd">    all three edges are present or only two edges are available.</span>
<span class="sd">    Each species is assigned a movement category based on the combination of these rates.</span>

<span class="sd">    Categories include:</span>
<span class="sd">        - &quot;poleward expansion together&quot;</span>
<span class="sd">        - &quot;contracting together&quot;</span>
<span class="sd">        - &quot;pull apart&quot;</span>
<span class="sd">        - &quot;reabsorption&quot;</span>
<span class="sd">        - &quot;stability&quot;</span>
<span class="sd">        - &quot;likely moving together&quot;</span>
<span class="sd">        - &quot;likely stable&quot;</span>
<span class="sd">        - &quot;likely pull apart&quot;</span>
<span class="sd">        - &quot;likely reabsorption&quot;</span>
<span class="sd">        - &quot;uncategorized&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): Input DataFrame containing species movement data. Must include:</span>
<span class="sd">            - &#39;species&#39; (str): Name of the species</span>
<span class="sd">            - &#39;category&#39; (str): Edge category, e.g., &#39;leading&#39;, &#39;core&#39;, or &#39;trailing&#39;</span>
<span class="sd">            - &#39;northward_rate_km_per_year&#39; (float): Northward movement rate for that edge</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with one row per species, including:</span>
<span class="sd">            - &#39;species&#39;: Species name</span>
<span class="sd">            - &#39;leading&#39;: Leading edge rate (float or None)</span>
<span class="sd">            - &#39;core&#39;: Core rate (float or None)</span>
<span class="sd">            - &#39;trailing&#39;: Trailing edge rate (float or None)</span>
<span class="sd">            - &#39;category&#39;: Assigned movement category (str)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">species_name</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">species_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">species_name</span><span class="p">]</span>

        <span class="c1"># Extract available rates</span>
        <span class="n">leading</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;leading&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;core&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;trailing&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">leading</span> <span class="o">=</span> <span class="n">leading</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leading</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="n">trailing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">leading</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">leading</span><span class="p">)</span> <span class="k">if</span> <span class="n">leading</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">core</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="k">if</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">trailing</span><span class="p">)</span> <span class="k">if</span> <span class="n">trailing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Count how many components are not None</span>
        <span class="n">num_known</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">leading</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">trailing</span><span class="p">])</span>

        <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;uncategorized&quot;</span>

        <span class="c1"># ======= Full Data (3 values) =======</span>
        <span class="k">if</span> <span class="n">num_known</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;poleward expansion together&quot;</span>
            <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;contracting together&quot;</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;reabsorption&quot;</span>

            <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;stability&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pulling apart&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;reabsorption&quot;</span>

            <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>

        <span class="c1"># ======= Partial Data (2 values) =======</span>
        <span class="k">elif</span> <span class="n">num_known</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Only leading and core</span>
            <span class="k">if</span> <span class="n">leading</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely stable&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>

            <span class="c1"># Only core and trailing</span>
            <span class="k">elif</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely stable&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>

        <span class="c1"># ======= Final Append =======</span>
        <span class="n">categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;leading&quot;</span><span class="p">:</span> <span class="n">leading</span><span class="p">,</span>
                <span class="s2">&quot;core&quot;</span><span class="p">:</span> <span class="n">core</span><span class="p">,</span>
                <span class="s2">&quot;trailing&quot;</span><span class="p">:</span> <span class="n">trailing</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.categorize_species_south" class="doc doc-heading">
<code class="highlight language-python"><span class="n">categorize_species_south</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.categorize_species_south" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Categorizes species into movement groups based on leading, core, and trailing rates.</p>
<p>In the southern hemisphere, poleward movement corresponds to <strong>southward</strong> shifts.
This function examines movement rates (km/year) for different range edges
(leading, core, trailing). It supports cases where all three edges are present
or only two edges are available. Each species is assigned a movement category
based on the combination of these rates.</p>
<p>Categories include:
    - "poleward expansion together"
    - "contracting together"
    - "pull apart"
    - "reabsorption"
    - "stability"
    - "likely moving together"
    - "likely stable"
    - "likely pull apart"
    - "likely reabsorption"
    - "uncategorized"</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Input DataFrame containing species movement data. Must include:
- 'species' (str): Species name.
- 'category' (str): Edge category, e.g., 'leading', 'core', or 'trailing'.
- 'northward_rate_km_per_year' (float): Signed movement rate for that edge.
  Positive values = northward shifts, negative values = southward shifts.
  In the southern hemisphere, <strong>poleward corresponds to negative values</strong>.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>A DataFrame with one row per species, including:
    - 'species': Species name.
    - 'leading': Leading edge rate (float or None).
    - 'core': Core rate (float or None).
    - 'trailing': Trailing edge rate (float or None).
    - 'category': Assigned movement category (str).</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">categorize_species_south</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Categorizes species into movement groups based on leading, core, and trailing rates.</span>

<span class="sd">    In the southern hemisphere, poleward movement corresponds to **southward** shifts.</span>
<span class="sd">    This function examines movement rates (km/year) for different range edges</span>
<span class="sd">    (leading, core, trailing). It supports cases where all three edges are present</span>
<span class="sd">    or only two edges are available. Each species is assigned a movement category</span>
<span class="sd">    based on the combination of these rates.</span>

<span class="sd">    Categories include:</span>
<span class="sd">        - &quot;poleward expansion together&quot;</span>
<span class="sd">        - &quot;contracting together&quot;</span>
<span class="sd">        - &quot;pull apart&quot;</span>
<span class="sd">        - &quot;reabsorption&quot;</span>
<span class="sd">        - &quot;stability&quot;</span>
<span class="sd">        - &quot;likely moving together&quot;</span>
<span class="sd">        - &quot;likely stable&quot;</span>
<span class="sd">        - &quot;likely pull apart&quot;</span>
<span class="sd">        - &quot;likely reabsorption&quot;</span>
<span class="sd">        - &quot;uncategorized&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): Input DataFrame containing species movement data. Must include:</span>
<span class="sd">            - &#39;species&#39; (str): Species name.</span>
<span class="sd">            - &#39;category&#39; (str): Edge category, e.g., &#39;leading&#39;, &#39;core&#39;, or &#39;trailing&#39;.</span>
<span class="sd">            - &#39;northward_rate_km_per_year&#39; (float): Signed movement rate for that edge.</span>
<span class="sd">              Positive values = northward shifts, negative values = southward shifts.</span>
<span class="sd">              In the southern hemisphere, **poleward corresponds to negative values**.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with one row per species, including:</span>
<span class="sd">            - &#39;species&#39;: Species name.</span>
<span class="sd">            - &#39;leading&#39;: Leading edge rate (float or None).</span>
<span class="sd">            - &#39;core&#39;: Core rate (float or None).</span>
<span class="sd">            - &#39;trailing&#39;: Trailing edge rate (float or None).</span>
<span class="sd">            - &#39;category&#39;: Assigned movement category (str).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">species_name</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">species_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">species_name</span><span class="p">]</span>

        <span class="c1"># Extract available rates</span>
        <span class="n">leading</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;leading&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;core&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="n">species_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">species_data</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;trailing&quot;</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">leading</span> <span class="o">=</span> <span class="n">leading</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leading</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">trailing</span> <span class="o">=</span> <span class="n">trailing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trailing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Count how many components are not None</span>
        <span class="n">num_known</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">leading</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">trailing</span><span class="p">])</span>

        <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;uncategorized&quot;</span>

        <span class="k">if</span> <span class="n">num_known</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;contracting together&quot;</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span>
                <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span>
                <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;poleward expansion together&quot;</span>

            <span class="k">elif</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;reabsorption&quot;</span>

            <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;stability&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;reabsorption&quot;</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;pull apart&quot;</span>

            <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">leading</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>

        <span class="k">elif</span> <span class="n">num_known</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Only leading and core</span>
            <span class="k">if</span> <span class="n">leading</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely stable&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">leading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">leading</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>

            <span class="c1"># Only core and trailing</span>
            <span class="k">elif</span> <span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely stable&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely poleward expansion together&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely contracting together&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>
                <span class="k">elif</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">core</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">trailing</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely reabsorption&quot;</span>
                <span class="k">elif</span> <span class="n">core</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">trailing</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;likely pull apart&quot;</span>

        <span class="c1"># ======= Final Append =======</span>
        <span class="n">categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;leading&quot;</span><span class="p">:</span> <span class="n">leading</span><span class="p">,</span>
                <span class="s2">&quot;core&quot;</span><span class="p">:</span> <span class="n">core</span><span class="p">,</span>
                <span class="s2">&quot;trailing&quot;</span><span class="p">:</span> <span class="n">trailing</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.classify_range_edges" class="doc doc-heading">
<code class="highlight language-python"><span class="n">classify_range_edges</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.classify_range_edges" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Classifies polygons within clusters into leading, core, trailing, and relict edges based on spatial position relative to the centroid
of the largest polygon in each cluster. Includes longitudinal and latitudinal
relict detection.</p>
<p>The function:
    - Ensures the input GeoDataFrame is projected to EPSG:3395 for distance calculations.
    - Computes centroids, latitudes, longitudes, and areas for all polygons.
    - Determines the centroid of the largest polygon in each cluster.
    - Assigns each polygon a category based on latitude and longitude differences
      relative to the cluster centroid, using thresholds that can vary with cluster
      size.
    - Detects potential relict polygons based on latitude and longitude deviations.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame containing 'geometry' and 'cluster' columns.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>largest_polygons</code></td>
        <td><code>list of GeoDataFrame</code></td>
        <td><p>List containing the largest polygons per
cluster with an 'AREA' column for threshold calculations.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>The original GeoDataFrame augmented with a 'category' column
indicating the polygon's position relative to the cluster:
    - "leading" (poleward)
    - "trailing" (equatorward)
    - "core" (central)
    - "relict (0.01 latitude)" or "relict (longitude)" (outlier positions)</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify_range_edges</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies polygons within clusters into leading, core, trailing, and relict edges based on spatial position relative to the centroid</span>
<span class="sd">    of the largest polygon in each cluster. Includes longitudinal and latitudinal</span>
<span class="sd">    relict detection.</span>

<span class="sd">    The function:</span>
<span class="sd">        - Ensures the input GeoDataFrame is projected to EPSG:3395 for distance calculations.</span>
<span class="sd">        - Computes centroids, latitudes, longitudes, and areas for all polygons.</span>
<span class="sd">        - Determines the centroid of the largest polygon in each cluster.</span>
<span class="sd">        - Assigns each polygon a category based on latitude and longitude differences</span>
<span class="sd">          relative to the cluster centroid, using thresholds that can vary with cluster</span>
<span class="sd">          size.</span>
<span class="sd">        - Detects potential relict polygons based on latitude and longitude deviations.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf (GeoDataFrame): Input GeoDataFrame containing &#39;geometry&#39; and &#39;cluster&#39; columns.</span>
<span class="sd">        largest_polygons (list of GeoDataFrame): List containing the largest polygons per</span>
<span class="sd">            cluster with an &#39;AREA&#39; column for threshold calculations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: The original GeoDataFrame augmented with a &#39;category&#39; column</span>
<span class="sd">        indicating the polygon&#39;s position relative to the cluster:</span>
<span class="sd">            - &quot;leading&quot; (poleward)</span>
<span class="sd">            - &quot;trailing&quot; (equatorward)</span>
<span class="sd">            - &quot;core&quot; (central)</span>
<span class="sd">            - &quot;relict (0.01 latitude)&quot; or &quot;relict (longitude)&quot; (outlier positions)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure CRS is in EPSG:3395</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Compute centroids and extract coordinates</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span>

    <span class="c1"># Find the centroid of the largest polygon within each cluster</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_largest_polygon_centroid</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">largest_polygon</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">largest_polygon</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="n">cluster_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_largest_polygon_centroid</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Classify polygons within each cluster based on latitude and longitude distance</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_within_cluster</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">cluster_centroid</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cluster_lat</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">y</span>
        <span class="n">cluster_lon</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">x</span>

        <span class="n">largest_polygon_area</span> <span class="o">=</span> <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span>

        <span class="c1"># Define long_value based on area size</span>
        <span class="k">if</span> <span class="n">largest_polygon_area</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="c1"># elif largest_polygon_area &gt; 200:</span>
        <span class="c1"># long_value = 1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="mf">0.05</span>

        <span class="c1"># Then calculate thresholds</span>
        <span class="n">lat_threshold_01</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_05</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_02</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lon_threshold_01</span> <span class="o">=</span> <span class="n">long_value</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lon</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">classify</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lat</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lon</span>

            <span class="c1"># Relict by latitude</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (0.01 latitude)&quot;</span>
            <span class="c1"># Relict by longitude</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon_diff</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lon_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (longitude)&quot;</span>
            <span class="c1"># Leading edge (poleward, high latitudes)</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.99)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.95)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.9)&quot;</span>
            <span class="c1"># Trailing edge (equatorward, low latitudes)</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.05)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.1)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;core&quot;</span>

        <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_gdf</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify_within_cluster</span><span class="p">)</span>

    <span class="c1"># Drop temporary columns</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.classify_range_edges_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">classify_range_edges_gbif</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;north_america&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.classify_range_edges_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Classify polygons in a GeoDataFrame into range-edge categories
(leading, core, trailing, relict) within each cluster, based on
centroid distances relative to the largest polygon in that cluster.</p>
<p>The classification considers both latitudinal shifts (poleward vs. equatorward)
and longitudinal deviations (relict populations), with thresholds scaled
by region-specific parameters and polygon area.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame containing at minimum:
- 'geometry': Polygon geometries (species range fragments).
- 'cluster': Cluster identifier for grouping polygons.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>largest_polygons</code></td>
        <td><code>list of dict</code></td>
        <td><p>Largest polygon(s) per cluster, where
each dictionary must contain an 'AREA' key. Used to adjust
longitudinal thresholds.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>continent</code></td>
        <td><code>str, default=&#34;north_america&#34;</code></td>
        <td><p>Region keyword that selects
threshold scaling values. Supported values:
- "north_america"
- "europe"
- "asia"
- "north_africa"
- "central_north_south_america"</p></td>
        <td><code>&#39;north_america&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>Copy of the input with a new column:
    - 'category': Assigned edge classification, one of:
        * "leading (0.99)", "leading (0.95)", "leading (0.9)"
        * "core"
        * "trailing (0.05)", "trailing (0.1)"
        * "relict (0.01 latitude)", "relict (longitude)"</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify_range_edges_gbif</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;north_america&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classify polygons in a GeoDataFrame into range-edge categories</span>
<span class="sd">    (leading, core, trailing, relict) within each cluster, based on</span>
<span class="sd">    centroid distances relative to the largest polygon in that cluster.</span>

<span class="sd">    The classification considers both latitudinal shifts (poleward vs. equatorward)</span>
<span class="sd">    and longitudinal deviations (relict populations), with thresholds scaled</span>
<span class="sd">    by region-specific parameters and polygon area.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (GeoDataFrame): Input GeoDataFrame containing at minimum:</span>
<span class="sd">            - &#39;geometry&#39;: Polygon geometries (species range fragments).</span>
<span class="sd">            - &#39;cluster&#39;: Cluster identifier for grouping polygons.</span>
<span class="sd">        largest_polygons (list of dict): Largest polygon(s) per cluster, where</span>
<span class="sd">            each dictionary must contain an &#39;AREA&#39; key. Used to adjust</span>
<span class="sd">            longitudinal thresholds.</span>
<span class="sd">        continent (str, default=&quot;north_america&quot;): Region keyword that selects</span>
<span class="sd">            threshold scaling values. Supported values:</span>
<span class="sd">            - &quot;north_america&quot;</span>
<span class="sd">            - &quot;europe&quot;</span>
<span class="sd">            - &quot;asia&quot;</span>
<span class="sd">            - &quot;north_africa&quot;</span>
<span class="sd">            - &quot;central_north_south_america&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: Copy of the input with a new column:</span>
<span class="sd">            - &#39;category&#39;: Assigned edge classification, one of:</span>
<span class="sd">                * &quot;leading (0.99)&quot;, &quot;leading (0.95)&quot;, &quot;leading (0.9)&quot;</span>
<span class="sd">                * &quot;core&quot;</span>
<span class="sd">                * &quot;trailing (0.05)&quot;, &quot;trailing (0.1)&quot;</span>
<span class="sd">                * &quot;relict (0.01 latitude)&quot;, &quot;relict (longitude)&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add unique ID for reliable merging</span>
    <span class="n">df_original</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">})</span>

    <span class="c1"># Subset to unique geometry-cluster pairs with ID</span>
    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_original</span><span class="p">[[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Ensure proper CRS</span>
    <span class="k">if</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Calculate centroids, lat/lon, area</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span>

    <span class="c1"># Get centroid of largest polygon in each cluster</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_largest_polygon_centroid</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">largest_polygon</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">largest_polygon</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="n">cluster_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">unique_geoms</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_largest_polygon_centroid</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Classify within clusters</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_within_cluster</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">cluster_centroid</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cluster_lat</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">y</span>
        <span class="n">cluster_lon</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">x</span>

        <span class="n">north_america_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="c1"># area &gt; 150000</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">,</span>  <span class="c1"># area &gt; 100000</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="c1"># area &lt;= 100000</span>
        <span class="p">}</span>

        <span class="n">europe_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># slightly different values</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">asia_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mf">0.08</span><span class="p">,</span>  <span class="c1"># slightly different values</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.08</span><span class="p">,</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">north_africa_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>  <span class="c1"># area &gt; 150000</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>  <span class="c1"># area &gt; 100000</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>  <span class="c1"># area &lt;= 100000</span>
        <span class="p">}</span>

        <span class="n">central_south_america_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="c1"># area &gt; 150000</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">,</span>  <span class="c1"># area &gt; 100000</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="c1"># area &lt;= 100000</span>
        <span class="p">}</span>

        <span class="c1"># Function to get long_value from dictionary</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_long_value</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">continent_dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">150000</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">continent_dict</span><span class="p">[</span><span class="s2">&quot;large&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">continent_dict</span><span class="p">[</span><span class="s2">&quot;medium&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">continent_dict</span><span class="p">[</span><span class="s2">&quot;small&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;europe&quot;</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="n">get_long_value</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">],</span> <span class="n">europe_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;north_america&quot;</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="n">get_long_value</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">],</span> <span class="n">north_america_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="n">get_long_value</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">],</span> <span class="n">north_africa_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="n">get_long_value</span><span class="p">(</span>
                <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">],</span> <span class="n">central_south_america_dict</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">long_value</span> <span class="o">=</span> <span class="n">get_long_value</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">],</span> <span class="n">asia_dict</span><span class="p">)</span>

        <span class="n">lat_threshold_01</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_05</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lat_threshold_02</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">cluster_lat</span>
        <span class="n">lon_threshold_01</span> <span class="o">=</span> <span class="n">long_value</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lon</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">classify</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lat</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lon</span>

            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (0.01 latitude)&quot;</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon_diff</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lon_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (longitude)&quot;</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.99)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.95)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.9)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.05)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.1)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;core&quot;</span>

        <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_gdf</span>

    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="n">classify_within_cluster</span>
    <span class="p">)</span>

    <span class="c1"># Prepare final mapping table and merge</span>
    <span class="n">category_map</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">]]</span>
    <span class="n">df_final</span> <span class="o">=</span> <span class="n">df_original</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">category_map</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_final</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.classify_range_edges_gbif_south" class="doc doc-heading">
<code class="highlight language-python"><span class="n">classify_range_edges_gbif_south</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;oceania&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.classify_range_edges_gbif_south" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Classifies species range polygons into edge categories for the Southern Hemisphere.</p>
<p>This is the Southern Hemisphere counterpart to <code>classify_range_edges_gbif</code>.
It classifies polygons within clusters into ecological range-edge categories
(leading, core, trailing, and relict) based on their centroid’s distance from
the centroid of the largest polygon in the same cluster. In this hemisphere,
<strong>leading edges are further south</strong> and <strong>trailing edges are further north</strong>.
Relict thresholds for both latitude and longitude are adjusted accordingly.</p>
<p>The classification accounts for:
    * Polygon area (large, medium, small), which determines the scale of
      longitude thresholds by continent.
    * Latitudinal thresholds, scaled relative to the cluster centroid.
    * Hemisphere-specific rules for leading/trailing directionality.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input polygons with geometry and cluster assignments.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>largest_polygons</code></td>
        <td><code>list[dict]</code></td>
        <td><p>Metadata for the largest polygons in each cluster.
Each dict should include an "AREA" key for threshold scaling.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>continent</code></td>
        <td><code>str, default=&#34;oceania&#34;</code></td>
        <td><p>Continent-specific calibration for classification thresholds.
Supported values:
    - "oceania"
    - "central_south_south_america"
    - "central_south_africa"</p></td>
        <td><code>&#39;oceania&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>Original polygons with an additional column <code>category</code> containing
    the classification:
        - "leading (0.99)", "leading (0.95)", "leading (0.9)"
        - "trailing (0.05)", "trailing (0.1)"
        - "core"
        - "relict (longitude)", "relict (0.01 latitude)"</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If the GeoDataFrame does not contain a valid CRS.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify_range_edges_gbif_south</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;oceania&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies species range polygons into edge categories for the Southern Hemisphere.</span>

<span class="sd">    This is the Southern Hemisphere counterpart to `classify_range_edges_gbif`.</span>
<span class="sd">    It classifies polygons within clusters into ecological range-edge categories</span>
<span class="sd">    (leading, core, trailing, and relict) based on their centroid’s distance from</span>
<span class="sd">    the centroid of the largest polygon in the same cluster. In this hemisphere,</span>
<span class="sd">    **leading edges are further south** and **trailing edges are further north**.</span>
<span class="sd">    Relict thresholds for both latitude and longitude are adjusted accordingly.</span>

<span class="sd">    The classification accounts for:</span>
<span class="sd">        * Polygon area (large, medium, small), which determines the scale of</span>
<span class="sd">          longitude thresholds by continent.</span>
<span class="sd">        * Latitudinal thresholds, scaled relative to the cluster centroid.</span>
<span class="sd">        * Hemisphere-specific rules for leading/trailing directionality.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (GeoDataFrame):</span>
<span class="sd">            Input polygons with geometry and cluster assignments.</span>
<span class="sd">        largest_polygons (list[dict]):</span>
<span class="sd">            Metadata for the largest polygons in each cluster.</span>
<span class="sd">            Each dict should include an &quot;AREA&quot; key for threshold scaling.</span>
<span class="sd">        continent (str, default=&quot;oceania&quot;):</span>
<span class="sd">            Continent-specific calibration for classification thresholds.</span>
<span class="sd">            Supported values:</span>
<span class="sd">                - &quot;oceania&quot;</span>
<span class="sd">                - &quot;central_south_south_america&quot;</span>
<span class="sd">                - &quot;central_south_africa&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame:</span>
<span class="sd">            Original polygons with an additional column ``category`` containing</span>
<span class="sd">            the classification:</span>
<span class="sd">                - &quot;leading (0.99)&quot;, &quot;leading (0.95)&quot;, &quot;leading (0.9)&quot;</span>
<span class="sd">                - &quot;trailing (0.05)&quot;, &quot;trailing (0.1)&quot;</span>
<span class="sd">                - &quot;core&quot;</span>
<span class="sd">                - &quot;relict (longitude)&quot;, &quot;relict (0.01 latitude)&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the GeoDataFrame does not contain a valid CRS.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Add unique ID for reliable merging</span>
    <span class="n">df_original</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">})</span>

    <span class="c1"># Subset to unique geometry-cluster pairs with ID</span>
    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_original</span><span class="p">[[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Ensure proper CRS</span>
    <span class="k">if</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Calculate centroids, lat/lon, area</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
    <span class="n">unique_geoms</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">area</span>

    <span class="c1"># Get centroid of largest polygon in each cluster</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_largest_polygon_centroid</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">largest_polygon</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">largest_polygon</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="n">cluster_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">unique_geoms</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">find_largest_polygon_centroid</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Classify within clusters</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">classify_within_cluster</span><span class="p">(</span><span class="n">sub_gdf</span><span class="p">):</span>
        <span class="n">cluster_centroid</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;cluster_centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cluster_lat</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">y</span>
        <span class="n">cluster_lon</span> <span class="o">=</span> <span class="n">cluster_centroid</span><span class="o">.</span><span class="n">x</span>

        <span class="n">oceania_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">,</span>  <span class="c1"># area &gt; 150000</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="c1"># area &gt; 100000</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>  <span class="c1"># area &lt;= 100000</span>
        <span class="p">}</span>

        <span class="n">south_america_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">,</span>  <span class="c1"># area &gt; 150000</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="c1"># area &gt; 100000</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>  <span class="c1"># area &lt;= 100000</span>
        <span class="p">}</span>

        <span class="n">south_africa_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;large&quot;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">,</span>  <span class="c1"># area &gt; 150000</span>
            <span class="s2">&quot;medium&quot;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>  <span class="c1"># area &gt; 100000</span>
            <span class="s2">&quot;small&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># area &lt;= 100000</span>
        <span class="p">}</span>

        <span class="c1"># Function to get long_value from dictionary</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_long_value</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">continent_dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">150000</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">continent_dict</span><span class="p">[</span><span class="s2">&quot;large&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">continent_dict</span><span class="p">[</span><span class="s2">&quot;medium&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">continent_dict</span><span class="p">[</span><span class="s2">&quot;small&quot;</span><span class="p">]</span>

        <span class="n">long_value</span> <span class="o">=</span> <span class="n">get_long_value</span><span class="p">(</span>
            <span class="n">largest_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;AREA&quot;</span><span class="p">],</span>
            <span class="p">(</span>
                <span class="n">oceania_dict</span>
                <span class="k">if</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;oceania&quot;</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="n">south_america_dict</span>
                    <span class="k">if</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;central_south_south_america&quot;</span>
                    <span class="k">else</span> <span class="p">(</span>
                        <span class="n">south_africa_dict</span>
                        <span class="k">if</span> <span class="n">continent</span> <span class="o">==</span> <span class="s2">&quot;central_south_africa&quot;</span>
                        <span class="k">else</span> <span class="n">oceania_dict</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">),</span>  <span class="c1"># default to oceania if continent not recognized</span>
        <span class="p">)</span>

        <span class="n">lat_threshold_01</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lat</span><span class="p">)</span>
        <span class="n">lat_threshold_05</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lat</span><span class="p">)</span>
        <span class="n">lat_threshold_02</span> <span class="o">=</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lat</span><span class="p">)</span>
        <span class="n">lon_threshold_01</span> <span class="o">=</span> <span class="n">long_value</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cluster_lon</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">classify</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">lat_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lat</span>
            <span class="n">lon_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_lon</span>

            <span class="c1"># Check longitude relict first</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon_diff</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lon_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (longitude)&quot;</span>

            <span class="c1"># Then check latitude</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;relict (0.01 latitude)&quot;</span>

            <span class="c1"># Leading = further south (negative lat_diff)</span>
            <span class="k">if</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_01</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.99)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.95)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;leading (0.9)&quot;</span>

            <span class="c1"># Trailing = further north (positive lat_diff)</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_05</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.05)&quot;</span>
            <span class="k">elif</span> <span class="n">lat_diff</span> <span class="o">&gt;=</span> <span class="n">lat_threshold_02</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;trailing (0.1)&quot;</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;core&quot;</span>

        <span class="n">sub_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">classify</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_gdf</span>

    <span class="n">unique_geoms</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="n">classify_within_cluster</span>
    <span class="p">)</span>

    <span class="c1"># Prepare final mapping table and merge</span>
    <span class="n">category_map</span> <span class="o">=</span> <span class="n">unique_geoms</span><span class="p">[[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">]]</span>
    <span class="n">df_final</span> <span class="o">=</span> <span class="n">df_original</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">category_map</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_final</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">clip_polygons_to_continent_gbif</span><span class="p">(</span><span class="n">input_gdf</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;north_america&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.clip_polygons_to_continent_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Clips polygon geometries to a bounding box while preserving one row per original point.</p>
<p>This function:
1. Ensures geometries are valid.
2. Assigns unique IDs to shared polygons.
3. Clips polygons to continental land areas.
4. Clips again to a bounding box (default: North America).
5. Dissolves polygon fragments back into single geometries.
6. Merges the clipped polygons back to the original GeoDataFrame.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_gdf</code></td>
        <td><code>geopandas.GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame containing at least a 'geometry' column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lat_min</code></td>
        <td><code>float</code></td>
        <td><p>Minimum latitude of bounding box. Default is 6.6.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lat_max</code></td>
        <td><code>float</code></td>
        <td><p>Maximum latitude of bounding box. Default is 83.3.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lon_min</code></td>
        <td><code>float</code></td>
        <td><p>Minimum longitude of bounding box. Default is -178.2.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lon_max</code></td>
        <td><code>float</code></td>
        <td><p>Maximum longitude of bounding box. Default is -49.0.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>geopandas.GeoDataFrame</code></td>
      <td><p>A GeoDataFrame with the same number of rows as the input,
where polygon geometries have been clipped to a bounding box.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">clip_polygons_to_continent_gbif</span><span class="p">(</span>
    <span class="n">input_gdf</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;north_america&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clips polygon geometries to a bounding box while preserving one row per original point.</span>

<span class="sd">    This function:</span>
<span class="sd">    1. Ensures geometries are valid.</span>
<span class="sd">    2. Assigns unique IDs to shared polygons.</span>
<span class="sd">    3. Clips polygons to continental land areas.</span>
<span class="sd">    4. Clips again to a bounding box (default: North America).</span>
<span class="sd">    5. Dissolves polygon fragments back into single geometries.</span>
<span class="sd">    6. Merges the clipped polygons back to the original GeoDataFrame.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_gdf (geopandas.GeoDataFrame): Input GeoDataFrame containing at least a &#39;geometry&#39; column.</span>
<span class="sd">        lat_min (float, optional): Minimum latitude of bounding box. Default is 6.6.</span>
<span class="sd">        lat_max (float, optional): Maximum latitude of bounding box. Default is 83.3.</span>
<span class="sd">        lon_min (float, optional): Minimum longitude of bounding box. Default is -178.2.</span>
<span class="sd">        lon_max (float, optional): Maximum longitude of bounding box. Default is -49.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        geopandas.GeoDataFrame: A GeoDataFrame with the same number of rows as the input,</span>
<span class="sd">        where polygon geometries have been clipped to a bounding box.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">box</span>

    <span class="n">bounding_boxes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;north_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;europe&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">},</span>
        <span class="s2">&quot;asia&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
        <span class="c1"># South America split at equator</span>
        <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">55</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="c1"># Africa split at equator</span>
        <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;oceania&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounding_boxes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent &#39;</span><span class="si">{</span><span class="n">continent</span><span class="si">}</span><span class="s2">&#39; not recognized. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">bounding_boxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounding_boxes</span><span class="p">[</span><span class="n">continent</span><span class="p">]</span>

    <span class="n">lat_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span>
    <span class="n">lat_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">]</span>
    <span class="n">lon_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span>
    <span class="n">lon_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]</span>

    <span class="c1"># Load continent polygons (land areas)</span>
    <span class="n">land_url</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/land.geojson&quot;</span>
    <span class="p">)</span>
    <span class="n">continents_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">land_url</span><span class="p">)</span>

    <span class="c1"># Ensure valid geometries</span>
    <span class="n">input_gdf</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="p">[</span><span class="n">input_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>
    <span class="n">continents_gdf</span> <span class="o">=</span> <span class="n">continents_gdf</span><span class="p">[</span><span class="n">continents_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>

    <span class="c1"># Reproject if needed</span>
    <span class="k">if</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">continents_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
        <span class="n">input_gdf</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">continents_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Step 1: Assign unique polygon IDs for shared geometries</span>
    <span class="n">input_gdf</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">input_gdf</span><span class="p">[</span><span class="s2">&quot;poly_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="c1"># Step 2: Clip only unique polygons</span>
    <span class="n">unique_polygons</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)[</span>
        <span class="p">[</span><span class="s2">&quot;poly_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">unique_polygons</span><span class="p">,</span> <span class="n">continents_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>

    <span class="c1"># Step 3: Clip again to North America bounding box</span>
    <span class="n">na_bbox</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">lon_min</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">)</span>
    <span class="n">na_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">na_bbox</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">input_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">clipped</span><span class="p">,</span> <span class="n">na_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>

    <span class="c1"># Step 4: Collapse fragments back into one geometry per poly_id</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">clipped</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;poly_id&quot;</span><span class="p">)</span>

    <span class="c1"># Step 5: Merge clipped polygons back to original data</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">input_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">clipped</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
        <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;poly_id&quot;</span><span class="p">,</span>
        <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_clipped&quot;</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Use clipped geometry if available</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;geometry_clipped&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry_clipped&quot;</span><span class="p">,</span> <span class="s2">&quot;poly_id&quot;</span><span class="p">])</span>

    <span class="c1"># Ensure it&#39;s still a GeoDataFrame with correct CRS</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">input_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="doc doc-heading">
<code class="highlight language-python"><span class="n">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.collapse_and_calculate_centroids" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Collapses subgroups in the 'category' column into broader groups and calculates
the centroid for each category.</p>
      <ul>
<li>gdf: GeoDataFrame with a 'category' column and polygon geometries.</li>
</ul>
      <ul>
<li>GeoDataFrame with one centroid per collapsed category.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collapse_and_calculate_centroids</span><span class="p">(</span><span class="n">gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collapses subgroups in the &#39;category&#39; column into broader groups and calculates</span>
<span class="sd">    the centroid for each category.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf: GeoDataFrame with a &#39;category&#39; column and polygon geometries.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - GeoDataFrame with one centroid per collapsed category.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Standardize &#39;category&#39; names</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># Step 2: Collapse specific subgroups</span>
    <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># Step 3: Calculate centroids per collapsed category</span>
    <span class="n">centroids_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">category</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">):</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">unary_union</span><span class="o">.</span><span class="n">centroid</span>
        <span class="n">centroids_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">centroid</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">centroids_data</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.compute_individual_persistence" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_individual_persistence</span><span class="p">(</span><span class="n">points_gdf</span><span class="p">,</span> <span class="n">raster_stack_arrays</span><span class="p">,</span> <span class="n">propagule_array</span><span class="p">,</span> <span class="n">baseline_death</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.compute_individual_persistence" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Compute 1- and 5-year persistence probabilities for point locations based on environmental and demographic factors.</p>
<p>Persistence is influenced by local density, abundance changes, propagule pressure, northward movement,
and edge effects relative to category centroids.</p>
      <p>points_gdf : geopandas.GeoDataFrame
    Point locations with columns 'category', 'collapsed_category', 'geometry', 'point_geometry', and 'geometry_id'.
raster_stack_arrays : tuple of np.ndarray
    Raster arrays representing environmental or demographic variables in the order:
    (density, northward movement, abundance change, edge indicator).
propagule_array : np.ndarray
    Raster array representing propagule pressure.
baseline_death : float, default=0.1
    Baseline probability of death in one year, used to compute persistence probabilities.
transform : affine.Affine or None, optional
    Affine transform for converting geographic coordinates to raster indices. If None, coordinates
    are interpreted as direct array indices.</p>
      <p>geopandas.GeoDataFrame
    GeoDataFrame containing:
    - point_id: unique index of each point
    - P_1y, P_5y: 1-year and 5-year persistence probabilities
    - density_vals, northward_vals, abundance_change_vals, edge_vals, propagule_vals: raster values sampled at each point
    - risk_decile: decile ranking of 5-year persistence risk (higher = more at risk)
    - baseline_death: baseline death probability used
    - P_1y_vs_baseline, P_5y_vs_baseline: comparison of persistence vs baseline ("higher", "lower", or "baseline (spatial outlier)")
    - north_south_of_category_centroid: direction relative to category centroid
    - point_geometry, geometry, geometry_id: original point geometries</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_individual_persistence</span><span class="p">(</span>
    <span class="n">points_gdf</span><span class="p">,</span> <span class="n">raster_stack_arrays</span><span class="p">,</span> <span class="n">propagule_array</span><span class="p">,</span> <span class="n">baseline_death</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute 1- and 5-year persistence probabilities for point locations based on environmental and demographic factors.</span>

<span class="sd">    Persistence is influenced by local density, abundance changes, propagule pressure, northward movement,</span>
<span class="sd">    and edge effects relative to category centroids.</span>

<span class="sd">    Args:</span>
<span class="sd">    points_gdf : geopandas.GeoDataFrame</span>
<span class="sd">        Point locations with columns &#39;category&#39;, &#39;collapsed_category&#39;, &#39;geometry&#39;, &#39;point_geometry&#39;, and &#39;geometry_id&#39;.</span>
<span class="sd">    raster_stack_arrays : tuple of np.ndarray</span>
<span class="sd">        Raster arrays representing environmental or demographic variables in the order:</span>
<span class="sd">        (density, northward movement, abundance change, edge indicator).</span>
<span class="sd">    propagule_array : np.ndarray</span>
<span class="sd">        Raster array representing propagule pressure.</span>
<span class="sd">    baseline_death : float, default=0.1</span>
<span class="sd">        Baseline probability of death in one year, used to compute persistence probabilities.</span>
<span class="sd">    transform : affine.Affine or None, optional</span>
<span class="sd">        Affine transform for converting geographic coordinates to raster indices. If None, coordinates</span>
<span class="sd">        are interpreted as direct array indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">    geopandas.GeoDataFrame</span>
<span class="sd">        GeoDataFrame containing:</span>
<span class="sd">        - point_id: unique index of each point</span>
<span class="sd">        - P_1y, P_5y: 1-year and 5-year persistence probabilities</span>
<span class="sd">        - density_vals, northward_vals, abundance_change_vals, edge_vals, propagule_vals: raster values sampled at each point</span>
<span class="sd">        - risk_decile: decile ranking of 5-year persistence risk (higher = more at risk)</span>
<span class="sd">        - baseline_death: baseline death probability used</span>
<span class="sd">        - P_1y_vs_baseline, P_5y_vs_baseline: comparison of persistence vs baseline (&quot;higher&quot;, &quot;lower&quot;, or &quot;baseline (spatial outlier)&quot;)</span>
<span class="sd">        - north_south_of_category_centroid: direction relative to category centroid</span>
<span class="sd">        - point_geometry, geometry, geometry_id: original point geometries</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">density</span><span class="p">,</span> <span class="n">northward</span><span class="p">,</span> <span class="n">abundance_change</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">raster_stack_arrays</span>
    <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Compute category centroids</span>
    <span class="n">category_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">points_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">polys</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">]))</span>
        <span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Determine if each point is north or south of its category&#39;s centroid</span>
    <span class="n">north_south</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">points_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">centroid_y</span> <span class="o">=</span> <span class="n">category_centroids</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">point_geometry</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">centroid_y</span><span class="p">:</span>
            <span class="n">north_south</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;north&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">north_south</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;south&quot;</span><span class="p">)</span>

    <span class="n">points_gdf</span> <span class="o">=</span> <span class="n">points_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;edge_vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;collapsed_category&quot;</span><span class="p">]</span>

    <span class="c1"># Function to map coordinates to array indices</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coords_to_index</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="o">~</span><span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">row</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>

    <span class="c1"># Convert points to array indices</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">points_gdf</span><span class="o">.</span><span class="n">point_geometry</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">coords_to_index</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>

    <span class="c1"># Sample raster values</span>
    <span class="n">density_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">density</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="n">northward_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">northward</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="n">abundance_change_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abundance_change</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="n">propagule_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">propagule_array</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;edge_vals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="c1"># Replace NaNs with 0</span>
    <span class="n">density_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">density_vals</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">northward_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">northward_vals</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">abundance_change_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">abundance_change_vals</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># edge_vals = np.nan_to_num(edge_vals, nan=0.0)</span>
    <span class="n">propagule_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">propagule_vals</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="n">effects_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">density_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">effects_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">density_vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">abundance_change_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">effects_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abundance_change_vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">propagule_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># compute propagule effect as before</span>
        <span class="n">lower_quartile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">propagule_vals</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
        <span class="n">upper_half</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">propagule_vals</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">propagule_effect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">propagule_vals</span><span class="p">)</span>
        <span class="n">propagule_effect</span><span class="p">[</span><span class="n">propagule_vals</span> <span class="o">&gt;=</span> <span class="n">upper_half</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">propagule_effect</span><span class="p">[</span><span class="n">propagule_vals</span> <span class="o">&lt;=</span> <span class="n">lower_quartile</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">propagule_effect</span> <span class="o">*=</span> <span class="n">propagule_vals</span>
        <span class="n">effects_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">propagule_effect</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">north_south</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">northward_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">north_south_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">north_south</span><span class="p">)</span>
        <span class="n">northward_effect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">((</span><span class="n">north_south_array</span> <span class="o">==</span> <span class="s2">&quot;north&quot;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">northward_vals</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="o">|</span> <span class="p">((</span><span class="n">north_south_array</span> <span class="o">==</span> <span class="s2">&quot;south&quot;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">northward_vals</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">northward_vals</span><span class="p">),</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">northward_vals</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">effects_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">northward_effect</span><span class="p">)</span>

    <span class="c1"># Sum all available effects</span>
    <span class="k">if</span> <span class="n">effects_list</span><span class="p">:</span>
        <span class="n">total_effect</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">effects_list</span><span class="p">)</span>
        <span class="c1"># Normalize so total_effect stays &lt; 1</span>
        <span class="n">total_effect</span> <span class="o">=</span> <span class="n">total_effect</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">total_effect</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_effect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">propagule_vals</span><span class="p">)</span>  <span class="c1"># or baseline if no data at all</span>

    <span class="c1"># Apply edge effect</span>
    <span class="n">edge_scale_factors</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s2">&quot;core&quot;</span><span class="p">:</span> <span class="mf">1.05</span><span class="p">,</span>
        <span class="s2">&quot;leading&quot;</span><span class="p">:</span> <span class="mf">1.02</span><span class="p">,</span>
        <span class="s2">&quot;trailing&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>
        <span class="s2">&quot;relict&quot;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">edge_effect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">edge_scale_factors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;edge_vals&quot;</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="n">total_effect</span> <span class="o">*=</span> <span class="n">edge_effect</span>

    <span class="c1"># Modified death probability</span>
    <span class="n">P_death_mod</span> <span class="o">=</span> <span class="n">baseline_death</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">total_effect</span><span class="p">)</span>
    <span class="n">P_death_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">P_death_mod</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Persistence probabilities</span>
    <span class="n">P_1y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">P_death_mod</span>
    <span class="n">P_5y</span> <span class="o">=</span> <span class="n">P_1y</span><span class="o">**</span><span class="mi">5</span>
    <span class="c1"># Baseline expectations</span>
    <span class="n">expected_1y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">baseline_death</span>
    <span class="n">expected_5y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">baseline_death</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span>

    <span class="c1"># Compare with baseline</span>
    <span class="n">all_nan_or_zero_mask</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">density_vals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">northward_vals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">abundance_change_vals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">edge_vals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">propagule_vals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">P_1y_vs_baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">P_1y</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">P_5y_vs_baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">P_5y</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">P_1y_vs_baseline</span><span class="p">[</span><span class="n">all_nan_or_zero_mask</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;baseline (spatial outlier)&quot;</span>
    <span class="n">P_5y_vs_baseline</span><span class="p">[</span><span class="n">all_nan_or_zero_mask</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;baseline (spatial outlier)&quot;</span>
    <span class="n">mask_valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">all_nan_or_zero_mask</span>
    <span class="n">P_1y_vs_baseline</span><span class="p">[</span><span class="n">mask_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">P_1y</span><span class="p">[</span><span class="n">mask_valid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">expected_1y</span><span class="p">,</span> <span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span>
    <span class="p">)</span>
    <span class="n">P_5y_vs_baseline</span><span class="p">[</span><span class="n">mask_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">P_5y</span><span class="p">[</span><span class="n">mask_valid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">expected_5y</span><span class="p">,</span> <span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Risk decile</span>
    <span class="n">risk_decile</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">-</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">P_5y</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">duplicates</span><span class="o">=</span><span class="s2">&quot;drop&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compile results</span>
    <span class="n">results_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;point_id&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_gdf</span><span class="p">)),</span>
            <span class="s2">&quot;P_1y&quot;</span><span class="p">:</span> <span class="n">P_1y</span><span class="p">,</span>
            <span class="s2">&quot;P_5y&quot;</span><span class="p">:</span> <span class="n">P_5y</span><span class="p">,</span>
            <span class="s2">&quot;density_vals&quot;</span><span class="p">:</span> <span class="n">density_vals</span><span class="p">,</span>
            <span class="s2">&quot;northward_vals&quot;</span><span class="p">:</span> <span class="n">northward_vals</span><span class="p">,</span>
            <span class="s2">&quot;abundance_change_vals&quot;</span><span class="p">:</span> <span class="n">abundance_change_vals</span><span class="p">,</span>
            <span class="s2">&quot;edge_vals&quot;</span><span class="p">:</span> <span class="n">edge_vals</span><span class="p">,</span>
            <span class="s2">&quot;propagule_vals&quot;</span><span class="p">:</span> <span class="n">propagule_vals</span><span class="p">,</span>
            <span class="s2">&quot;risk_decile&quot;</span><span class="p">:</span> <span class="n">risk_decile</span><span class="p">,</span>
            <span class="s2">&quot;baseline_death&quot;</span><span class="p">:</span> <span class="n">baseline_death</span><span class="p">,</span>
            <span class="s2">&quot;P_1y_vs_baseline&quot;</span><span class="p">:</span> <span class="n">P_1y_vs_baseline</span><span class="p">,</span>
            <span class="s2">&quot;P_5y_vs_baseline&quot;</span><span class="p">:</span> <span class="n">P_5y_vs_baseline</span><span class="p">,</span>
            <span class="s2">&quot;north_south_of_category_centroid&quot;</span><span class="p">:</span> <span class="n">north_south</span><span class="p">,</span>
            <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="s2">&quot;geometry_id&quot;</span><span class="p">:</span> <span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">geometry</span><span class="o">=</span><span class="n">points_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="n">points_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">results_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.compute_propagule_pressure_range" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_propagule_pressure_range</span><span class="p">(</span><span class="n">stacked_raster</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">scale_factors</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.compute_propagule_pressure_range" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Compute propagule pressure across a rasterized landscape, incorporating distance decay, directional
movement, and edge/category effects.</p>
<p>This function estimates the influence of nearby occupied cells on each raster cell, accounting for:
- Distance to the nearest occupied cell (exponential decay with rate D)
- Directional movement based on northward or southward rates
- Local density contributions (self-pressure)
- Edge dynamics and category-specific scaling</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>stacked_raster</code></td>
        <td></td>
        <td><p>tuple of np.ndarray
Input raster stack with at least four elements:
- density array: abundance or occupancy of the species
- northward_rate: northward movement rate per year (km/y)
- edge_change_rate: rate of edge expansion or contraction
- category_raw: integer-coded categories (e.g., core, leading, trailing, relict)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>D</code></td>
        <td></td>
        <td><p>float, default=0.3
Exponential decay parameter controlling how propagule influence decreases with distance.</p></td>
        <td><code>0.3</code></td>
      </tr>
      <tr>
        <td><code>S</code></td>
        <td></td>
        <td><p>float, default=10.0
Scaling factor for directional and edge-based adjustments to propagule pressure.</p></td>
        <td><code>10.0</code></td>
      </tr>
      <tr>
        <td><code>scale_factors</code></td>
        <td></td>
        <td><p>dict or None, optional
Category-specific multipliers for propagule pressure. Defaults to:
    {1: 1.5,  # Core
    2: 1.2,  # Leading
    3: 0.8,  # Trailing
    4: 1.0}  # Relict</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>np.ndarray
    Raster array of the same shape as the input density array, representing the
    adjusted propagule pressure at each cell, incorporating distance, directional,
    and category/edge effects.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_propagule_pressure_range</span><span class="p">(</span><span class="n">stacked_raster</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">scale_factors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute propagule pressure across a rasterized landscape, incorporating distance decay, directional</span>
<span class="sd">    movement, and edge/category effects.</span>

<span class="sd">    This function estimates the influence of nearby occupied cells on each raster cell, accounting for:</span>
<span class="sd">    - Distance to the nearest occupied cell (exponential decay with rate D)</span>
<span class="sd">    - Directional movement based on northward or southward rates</span>
<span class="sd">    - Local density contributions (self-pressure)</span>
<span class="sd">    - Edge dynamics and category-specific scaling</span>

<span class="sd">    Args:</span>
<span class="sd">        stacked_raster : tuple of np.ndarray</span>
<span class="sd">            Input raster stack with at least four elements:</span>
<span class="sd">            - density array: abundance or occupancy of the species</span>
<span class="sd">            - northward_rate: northward movement rate per year (km/y)</span>
<span class="sd">            - edge_change_rate: rate of edge expansion or contraction</span>
<span class="sd">            - category_raw: integer-coded categories (e.g., core, leading, trailing, relict)</span>
<span class="sd">        D : float, default=0.3</span>
<span class="sd">            Exponential decay parameter controlling how propagule influence decreases with distance.</span>
<span class="sd">        S : float, default=10.0</span>
<span class="sd">            Scaling factor for directional and edge-based adjustments to propagule pressure.</span>
<span class="sd">        scale_factors : dict or None, optional</span>
<span class="sd">            Category-specific multipliers for propagule pressure. Defaults to:</span>
<span class="sd">                {1: 1.5,  # Core</span>
<span class="sd">                2: 1.2,  # Leading</span>
<span class="sd">                3: 0.8,  # Trailing</span>
<span class="sd">                4: 1.0}  # Relict</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Raster array of the same shape as the input density array, representing the</span>
<span class="sd">            adjusted propagule pressure at each cell, incorporating distance, directional,</span>
<span class="sd">            and category/edge effects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract input data</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">stacked_raster</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">northward_rate</span> <span class="o">=</span> <span class="n">stacked_raster</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># in km/y</span>
    <span class="n">category_raw</span> <span class="o">=</span> <span class="n">stacked_raster</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Replace NaNs with zeros</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">density</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">northward_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">northward_rate</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">category</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">category_raw</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Identify occupied cells</span>
    <span class="n">occupied_mask</span> <span class="o">=</span> <span class="n">density</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Compute distance and indices of nearest occupied cell</span>
    <span class="n">distance</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="o">~</span><span class="n">occupied_mask</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Gather source values</span>
    <span class="n">nearest_y</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># y-coordinate of nearest occupied cell</span>
    <span class="n">current_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">delta_y</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">current_y</span> <span class="o">-</span> <span class="n">nearest_y</span>
    <span class="p">)</span>  <span class="c1"># Distance from each cell to the nearest occupied cell</span>

    <span class="c1"># Initialize direction modifier to 1</span>
    <span class="n">direction_modifier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">northward_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="c1"># Check northward rate for moving north or south and apply corresponding logic</span>
    <span class="n">northward_mask</span> <span class="o">=</span> <span class="n">northward_rate</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># Mask for northward movement</span>
    <span class="n">southward_mask</span> <span class="o">=</span> <span class="n">northward_rate</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="c1"># Mask for southward movement</span>

    <span class="c1"># Apply southward movement logic</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">occupied_mask</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="n">northward_rate</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># south = 1, north = -1</span>
                    <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>  <span class="c1"># How far outward to apply</span>
                        <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">direction</span>
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">dy</span><span class="p">,</span> <span class="n">dy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># widen as you go further</span>
                                <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
                                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                    <span class="n">distance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                    <span class="n">modifier</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span> <span class="o">*</span> <span class="n">distance_factor</span><span class="p">)</span> <span class="o">/</span> <span class="n">S</span>
                                    <span class="n">direction_modifier</span><span class="p">[</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">modifier</span>

    <span class="c1"># Clip to prevent out-of-bounds influence</span>
    <span class="n">direction_modifier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">direction_modifier</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="c1"># Apply northward movement logic</span>
    <span class="c1"># if np.any(northward_mask):</span>
    <span class="c1"># direction_modifier[northward_mask &amp; (delta_y &gt; 0)] = 1 - (np.abs(northward_rate[northward_mask &amp; (delta_y &gt; 0)]) * np.abs(delta_y[northward_mask &amp; (delta_y &gt; 0)])) / S</span>
    <span class="c1"># direction_modifier[northward_mask &amp; (delta_y &lt; 0)] = 1 + (np.abs(northward_rate[northward_mask &amp; (delta_y &lt; 0)]) * np.abs(delta_y[northward_mask &amp; (delta_y &lt; 0)])) / S</span>
    <span class="c1"># direction_modifier = np.clip(direction_modifier, 0.1, 2.0)</span>

    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">occupied_mask</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="n">northward_rate</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="p">)</span>  <span class="c1"># north = -1, south = 1 (flipped direction)</span>
                    <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>  <span class="c1"># How far outward to apply</span>
                        <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">direction</span>
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">dy</span><span class="p">,</span> <span class="n">dy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># widen as you go further</span>
                                <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
                                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                    <span class="n">distance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                    <span class="n">modifier</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span> <span class="o">*</span> <span class="n">distance_factor</span><span class="p">)</span> <span class="o">/</span> <span class="n">S</span>
                                    <span class="n">direction_modifier</span><span class="p">[</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">modifier</span>

    <span class="c1"># Compute pressure from source density and distance</span>

    <span class="n">pressure_nearest</span> <span class="o">=</span> <span class="n">density</span><span class="p">[</span><span class="n">nearest_y</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">D</span> <span class="o">*</span> <span class="n">distance</span><span class="p">)</span>

    <span class="n">D_self</span> <span class="o">=</span> <span class="n">density</span>

    <span class="n">pressure</span> <span class="o">=</span> <span class="n">pressure_nearest</span> <span class="o">+</span> <span class="p">(</span><span class="n">D_self</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">D</span> <span class="o">*</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># pressure = density[nearest_y, indices[1]] * np.exp(-D * distance)</span>
    <span class="c1"># pressure = nearest_y * np.exp(-D * distance)</span>

    <span class="c1"># Apply directional influence (adjusting based on the direction_modifier)</span>
    <span class="n">pressure_directional</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">*</span> <span class="n">direction_modifier</span>

    <span class="c1"># Apply category-based scaling</span>
    <span class="k">if</span> <span class="n">scale_factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scale_factors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="c1"># Core</span>
            <span class="mi">2</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">,</span>  <span class="c1"># Leading</span>
            <span class="mi">3</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>  <span class="c1"># Trailing</span>
            <span class="mi">4</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># Relict</span>
        <span class="p">}</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cat</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">scale_factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">scaling</span><span class="p">[</span><span class="n">category</span> <span class="o">==</span> <span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor</span>

    <span class="c1"># Final pressure scaled</span>
    <span class="n">pressure_scaled</span> <span class="o">=</span> <span class="n">pressure_directional</span> <span class="o">*</span> <span class="n">scaling</span>

    <span class="n">edge_change_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">stacked_raster</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="c1"># Initialize modifier matrix (default = 1)</span>
    <span class="n">edge_modifier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">edge_change_rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="c1"># Define which categories to include (Core=1, Leading=2, Trailing=3)</span>
    <span class="n">target_categories</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">category</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="ow">in</span> <span class="n">target_categories</span><span class="p">:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="n">edge_change_rate</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Spread influence outward from this cell</span>
                    <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">density</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">):</span>
                                <span class="n">distance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">distance_factor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">distance_factor</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># to avoid division by zero</span>
                                <span class="n">modifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">distance_factor</span><span class="p">))</span> <span class="o">/</span> <span class="n">S</span>
                                <span class="n">edge_modifier</span><span class="p">[</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">modifier</span>

    <span class="c1"># Clip to keep values within a stable range</span>
    <span class="n">edge_modifier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">edge_modifier</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="c1"># Apply additional edge-based pressure influence</span>
    <span class="n">pressure_scaled</span> <span class="o">*=</span> <span class="n">edge_modifier</span>

    <span class="k">return</span> <span class="n">pressure_scaled</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.convert_to_gdf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_to_gdf</span><span class="p">(</span><span class="n">euc_data</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.convert_to_gdf" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Converts raw GBIF occurrence data into a cleaned GeoDataFrame,
including geometry, year, and basisOfRecord.</p>
      <ul>
<li>euc_data (list): List of occurrence records (dicts) from GBIF.</li>
</ul>
      <ul>
<li>gpd.GeoDataFrame: Cleaned GeoDataFrame with lat/lon as geometry.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">convert_to_gdf</span><span class="p">(</span><span class="n">euc_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts raw GBIF occurrence data into a cleaned GeoDataFrame,</span>
<span class="sd">    including geometry, year, and basisOfRecord.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - euc_data (list): List of occurrence records (dicts) from GBIF.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - gpd.GeoDataFrame: Cleaned GeoDataFrame with lat/lon as geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">euc_data</span><span class="p">:</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;year&quot;</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;basisOfRecord&quot;</span><span class="p">)</span>
        <span class="n">scientific_name</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;scientificName&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">event_date</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eventDate&quot;</span><span class="p">)</span>
        <span class="n">species</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scientific_name</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="n">scientific_name</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species</span><span class="p">,</span>
                    <span class="s2">&quot;decimalLatitude&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span>
                    <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span>
                    <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                    <span class="s2">&quot;eventDate&quot;</span><span class="p">:</span> <span class="n">event_date</span><span class="p">,</span>
                    <span class="s2">&quot;basisOfRecord&quot;</span><span class="p">:</span> <span class="n">basis</span><span class="p">,</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^0-9\-]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d</span><span class="si">{4}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">])</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.count_points_per_category" class="doc doc-heading">
<code class="highlight language-python"><span class="n">count_points_per_category</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.count_points_per_category" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Standardizes category labels and counts how many points fall into each simplified category.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>The original DataFrame with a 'category' column.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>A DataFrame showing total points per simplified category.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_points_per_category</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standardizes category labels and counts how many points fall into each simplified category.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pd.DataFrame): The original DataFrame with a &#39;category&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame showing total points per simplified category.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Standardize the categories</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># Count the number of points per simplified category</span>
    <span class="n">category_counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)[</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">category_counts</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="s2">&quot;n_points&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">category_counts</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.create_interactive_map" class="doc doc-heading">
<code class="highlight language-python"><span class="n">create_interactive_map</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">if_save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.create_interactive_map" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create and display an interactive 3D map with polygon outlines and a
hexagon elevation layer representing point density.</p>
<p>The function splits the input DataFrame into polygons and points, converts
them to GeoDataFrames, and then visualizes them using PyDeck. The map is displayed in the default web browser
and can optionally be saved as an HTML file in the user's Downloads folder.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dataframe</code></td>
        <td><code>pd.DataFrame or gpd.GeoDataFrame</code></td>
        <td><p>A DataFrame containing both polygon and point geometries. Must have
a 'geometry' column for polygons and a 'point_geometry' column for points.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>if_save</code></td>
        <td><code>bool</code></td>
        <td><p>If True, the map will be saved as "map.html" in the user's Downloads
folder. Defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>None</code></td>
      <td><p>The function displays the map in a web browser and optionally saves it.</p></td>
    </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>Point densities are visualized using a HexagonLayer with elevation based
  on the count of points in each hexagon.</li>
<li>Tooltip shows the elevation value (density) when hovering over hexagons.</li>
<li>Temporary HTML file is automatically opened in the default browser.</li>
<li>Saved map overwrites existing "map.html" in Downloads if present.</li>
</ul>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_interactive_map</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">if_save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create and display an interactive 3D map with polygon outlines and a</span>
<span class="sd">    hexagon elevation layer representing point density.</span>

<span class="sd">    The function splits the input DataFrame into polygons and points, converts</span>
<span class="sd">    them to GeoDataFrames, and then visualizes them using PyDeck. The map is displayed in the default web browser</span>
<span class="sd">    and can optionally be saved as an HTML file in the user&#39;s Downloads folder.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataframe (pd.DataFrame or gpd.GeoDataFrame):</span>
<span class="sd">            A DataFrame containing both polygon and point geometries. Must have</span>
<span class="sd">            a &#39;geometry&#39; column for polygons and a &#39;point_geometry&#39; column for points.</span>
<span class="sd">        if_save (bool, optional):</span>
<span class="sd">            If True, the map will be saved as &quot;map.html&quot; in the user&#39;s Downloads</span>
<span class="sd">            folder. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function displays the map in a web browser and optionally saves it.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Point densities are visualized using a HexagonLayer with elevation based</span>
<span class="sd">          on the count of points in each hexagon.</span>
<span class="sd">        - Tooltip shows the elevation value (density) when hovering over hexagons.</span>
<span class="sd">        - Temporary HTML file is automatically opened in the default browser.</span>
<span class="sd">        - Saved map overwrites existing &quot;map.html&quot; in Downloads if present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Keep the polygon geometries</span>
    <span class="n">polygon_gdf</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># Remove point geometry column from polygons</span>
    <span class="n">polygon_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="c1"># Create the point GeoDataFrame, setting &#39;point_geometry&#39; as the geometry column</span>
    <span class="n">point_gdf</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">point_gdf</span> <span class="o">=</span> <span class="n">point_gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># Remove the polygon geometry column from points</span>
    <span class="n">point_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="n">point_gdf</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;point_geometry&quot;</span>
    <span class="p">)</span>  <span class="c1"># Set &#39;point_geometry&#39; as the geometry column</span>

    <span class="c1"># --- Convert to GeoJSON for the polygon layer ---</span>
    <span class="n">polygon_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">polygon_gdf</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>

    <span class="c1"># Add columns for point locations (longitude, latitude)</span>
    <span class="n">point_gdf</span><span class="p">[</span><span class="s2">&quot;point_lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
    <span class="n">point_gdf</span><span class="p">[</span><span class="s2">&quot;point_lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

    <span class="n">point_gdf</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># --- Define the initial view state for the map ---</span>
    <span class="n">view_state</span> <span class="o">=</span> <span class="n">pdk</span><span class="o">.</span><span class="n">ViewState</span><span class="p">(</span>
        <span class="n">latitude</span><span class="o">=</span><span class="n">point_gdf</span><span class="p">[</span><span class="s2">&quot;point_lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
        <span class="n">longitude</span><span class="o">=</span><span class="n">point_gdf</span><span class="p">[</span><span class="s2">&quot;point_lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
        <span class="n">zoom</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">pitch</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># --- Polygon outline layer ---</span>
    <span class="n">polygon_layer</span> <span class="o">=</span> <span class="n">pdk</span><span class="o">.</span><span class="n">Layer</span><span class="p">(</span>
        <span class="s2">&quot;GeoJsonLayer&quot;</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">polygon_json</span><span class="p">,</span>
        <span class="n">get_fill_color</span><span class="o">=</span><span class="s2">&quot;[0, 0, 0, 0]&quot;</span><span class="p">,</span>
        <span class="n">get_line_color</span><span class="o">=</span><span class="p">[</span><span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">],</span>
        <span class="n">line_width_min_pixels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">pickable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># --- Smooth elevation using HexagonLayer ---</span>
    <span class="n">hex_layer</span> <span class="o">=</span> <span class="n">pdk</span><span class="o">.</span><span class="n">Layer</span><span class="p">(</span>
        <span class="s2">&quot;HexagonLayer&quot;</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">point_gdf</span><span class="p">,</span>
        <span class="n">get_position</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;point_lon&quot;</span><span class="p">,</span> <span class="s2">&quot;point_lat&quot;</span><span class="p">],</span>
        <span class="n">radius</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>  <span class="c1"># Hexagon size in meters (adjust for smoothness)</span>
        <span class="n">elevation_scale</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>  <span class="c1"># Lower scale for smoother, less jagged effect</span>
        <span class="n">get_elevation_weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>  <span class="c1"># Use &#39;weight&#39; column for height (density)</span>
        <span class="n">elevation_range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">],</span>  <span class="c1"># Range for elevation (can adjust as needed)</span>
        <span class="n">extruded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">coverage</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Coverage of hexagons, 1 = fully covered</span>
        <span class="n">pickable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># --- Create the pydeck map with the layers ---</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">pdk</span><span class="o">.</span><span class="n">Deck</span><span class="p">(</span>
        <span class="n">layers</span><span class="o">=</span><span class="p">[</span><span class="n">polygon_layer</span><span class="p">,</span> <span class="n">hex_layer</span><span class="p">],</span>
        <span class="n">initial_view_state</span><span class="o">=</span><span class="n">view_state</span><span class="p">,</span>
        <span class="n">tooltip</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;Height (density): </span><span class="si">{elevationValue}</span><span class="s2">&quot;</span><span class="p">},</span>
    <span class="p">)</span>

    <span class="c1"># --- Create and display the map in a temporary HTML file ---</span>
    <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp_file</span><span class="p">:</span>
        <span class="c1"># Get the temporary file path</span>
        <span class="n">temp_file_path</span> <span class="o">=</span> <span class="n">tmp_file</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Save the map to the temporary file</span>
        <span class="n">r</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span><span class="n">temp_file_path</span><span class="p">)</span>

        <span class="c1"># Open the saved map in the default browser (automatically detects default browser)</span>
        <span class="n">webbrowser</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;file://</span><span class="si">{</span><span class="n">temp_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">if_save</span><span class="p">:</span>
        <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nt&quot;</span><span class="p">:</span>  <span class="c1"># Windows</span>
            <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">,</span> <span class="s2">&quot;map.html&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># macOS or Linux</span>
            <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">,</span> <span class="s2">&quot;map.html&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Save the map directly to the Downloads folder</span>
            <span class="n">r</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span><span class="n">downloads_path</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map saved at </span><span class="si">{</span><span class="n">downloads_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving map to Downloads: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.create_opacity_slider_map" class="doc doc-heading">
<code class="highlight language-python"><span class="n">create_opacity_slider_map</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.create_opacity_slider_map" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create a new interactive map that overlays one map on another with a year slider,
adjusting the opacity of the overlay layers between the two maps.
The original input maps remain unaffected.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>map1</code></td>
        <td><code>ipyleaflet.Map</code></td>
        <td><p>The base map to display beneath the overlay.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>map2</code></td>
        <td><code>ipyleaflet.Map</code></td>
        <td><p>The map whose layers will be overlaid on map1 with adjustable opacity.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Name of the species, used to determine the starting year for the slider.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>center</code></td>
        <td><code>list of float</code></td>
        <td><p>Latitude and longitude to center the map. Defaults to [40, -100].</p></td>
        <td><code>[40, -100]</code></td>
      </tr>
      <tr>
        <td><code>zoom</code></td>
        <td><code>int</code></td>
        <td><p>Initial zoom level for the map. Defaults to 4.</p></td>
        <td><code>4</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>Final year for the slider. Defaults to 2025.</p></td>
        <td><code>2025</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ipywidgets.VBox</code></td>
      <td><p>A vertical container holding the new map with overlay layers and the year
    slider widget. The slider adjusts the opacity of overlay layers from map1
    and map2 based on the selected year.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_opacity_slider_map</span><span class="p">(</span>
    <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new interactive map that overlays one map on another with a year slider,</span>
<span class="sd">    adjusting the opacity of the overlay layers between the two maps.</span>
<span class="sd">    The original input maps remain unaffected.</span>

<span class="sd">    Args:</span>
<span class="sd">        map1 (ipyleaflet.Map):</span>
<span class="sd">            The base map to display beneath the overlay.</span>
<span class="sd">        map2 (ipyleaflet.Map):</span>
<span class="sd">            The map whose layers will be overlaid on map1 with adjustable opacity.</span>
<span class="sd">        species_name (str):</span>
<span class="sd">            Name of the species, used to determine the starting year for the slider.</span>
<span class="sd">        center (list of float, optional):</span>
<span class="sd">            Latitude and longitude to center the map. Defaults to [40, -100].</span>
<span class="sd">        zoom (int, optional):</span>
<span class="sd">            Initial zoom level for the map. Defaults to 4.</span>
<span class="sd">        end_year (int, optional):</span>
<span class="sd">            Final year for the slider. Defaults to 2025.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ipywidgets.VBox:</span>
<span class="sd">            A vertical container holding the new map with overlay layers and the year</span>
<span class="sd">            slider widget. The slider adjusts the opacity of overlay layers from map1</span>
<span class="sd">            and map2 based on the selected year.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize new map</span>
    <span class="n">swipe_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">)</span>

    <span class="c1"># Re-add tile layers from both maps</span>
    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">map1</span><span class="o">.</span><span class="n">layers</span> <span class="o">+</span> <span class="n">map2</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
            <span class="n">swipe_map</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">))</span>

    <span class="c1"># Recreate and add overlay layers from both maps</span>
    <span class="n">overlay_layers_1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">overlay_layers_2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">map1</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_layer</span> <span class="o">=</span> <span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="n">overlay_layers_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
                <span class="n">swipe_map</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">map2</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_layer</span> <span class="o">=</span> <span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="n">overlay_layers_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
                <span class="n">swipe_map</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="c1"># Get year range</span>
    <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">))</span>
    <span class="n">end_year</span> <span class="o">=</span> <span class="n">end_year</span>
    <span class="n">year_range</span> <span class="o">=</span> <span class="n">end_year</span> <span class="o">-</span> <span class="n">start_year</span>

    <span class="c1"># Create year slider with static labels</span>
    <span class="n">slider</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;80%&quot;</span><span class="p">),</span>
        <span class="n">readout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">slider_box</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">start_year</span><span class="p">),</span> <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)),</span>
            <span class="n">slider</span><span class="p">,</span>
            <span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">end_year</span><span class="p">),</span> <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Update opacity when slider changes</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_opacity</span><span class="p">(</span><span class="n">change</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">change</span><span class="p">[</span><span class="s2">&quot;new&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_year</span><span class="p">)</span> <span class="o">/</span> <span class="n">year_range</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">overlay_layers_1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">):</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="o">**</span><span class="n">layer</span><span class="o">.</span><span class="n">style</span><span class="p">,</span>
                    <span class="s2">&quot;opacity&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="p">,</span>
                    <span class="s2">&quot;fillOpacity&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">overlay_layers_2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">):</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">layer</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="s2">&quot;opacity&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span> <span class="s2">&quot;fillOpacity&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">}</span>

    <span class="n">slider</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">update_opacity</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
    <span class="n">update_opacity</span><span class="p">({</span><span class="s2">&quot;new&quot;</span><span class="p">:</span> <span class="n">start_year</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">([</span><span class="n">swipe_map</span><span class="p">,</span> <span class="n">slider_box</span><span class="p">])</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.extract_raster_means_single_species" class="doc doc-heading">
<code class="highlight language-python"><span class="n">extract_raster_means_single_species</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.extract_raster_means_single_species" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Extract species-wide and category-level average raster values for a single species.</p>
<p>This function computes mean values of environmental rasters (precipitation, temperature, elevation)
over the polygons in a GeoDataFrame for a single species. It returns both species-wide averages
and averages per category.</p>
<p>The function also calculates the latitudinal and longitudinal range of the species
based on the polygon bounds, and normalizes category labels to a consistent set.</p>
      <p>gdf : geopandas.GeoDataFrame
    GeoDataFrame containing polygons for a single species. Expected columns:
    - 'geometry': polygon geometries
    - 'category' (optional): category label for each polygon (e.g., leading, trailing, relict)
species_name : str
    Name of the species to assign in the output DataFrames.</p>
      <p>total_df : pandas.DataFrame
    DataFrame containing species-wide averages for each raster variable:
    - 'species': species name
    - 'precipitation(mm)': mean precipitation across all polygons
    - 'temperature(c)': mean temperature across all polygons
    - 'elevation(m)': mean elevation across all polygons
    - 'latitudinal_difference': max latitude minus min latitude of species polygons
    - 'longitudinal_difference': max longitude minus min longitude of species polygons
category_df : pandas.DataFrame
    DataFrame containing category-level averages for each raster variable:
    - 'species': species name
    - 'category': standardized category label
    - 'precipitation(mm)', 'temperature(c)', 'elevation(m)': mean values for polygons in the category</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_raster_means_single_species</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract species-wide and category-level average raster values for a single species.</span>

<span class="sd">    This function computes mean values of environmental rasters (precipitation, temperature, elevation)</span>
<span class="sd">    over the polygons in a GeoDataFrame for a single species. It returns both species-wide averages</span>
<span class="sd">    and averages per category.</span>

<span class="sd">    The function also calculates the latitudinal and longitudinal range of the species</span>
<span class="sd">    based on the polygon bounds, and normalizes category labels to a consistent set.</span>

<span class="sd">    Args:</span>
<span class="sd">    gdf : geopandas.GeoDataFrame</span>
<span class="sd">        GeoDataFrame containing polygons for a single species. Expected columns:</span>
<span class="sd">        - &#39;geometry&#39;: polygon geometries</span>
<span class="sd">        - &#39;category&#39; (optional): category label for each polygon (e.g., leading, trailing, relict)</span>
<span class="sd">    species_name : str</span>
<span class="sd">        Name of the species to assign in the output DataFrames.</span>

<span class="sd">    Returns:</span>
<span class="sd">    total_df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing species-wide averages for each raster variable:</span>
<span class="sd">        - &#39;species&#39;: species name</span>
<span class="sd">        - &#39;precipitation(mm)&#39;: mean precipitation across all polygons</span>
<span class="sd">        - &#39;temperature(c)&#39;: mean temperature across all polygons</span>
<span class="sd">        - &#39;elevation(m)&#39;: mean elevation across all polygons</span>
<span class="sd">        - &#39;latitudinal_difference&#39;: max latitude minus min latitude of species polygons</span>
<span class="sd">        - &#39;longitudinal_difference&#39;: max longitude minus min longitude of species polygons</span>
<span class="sd">    category_df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing category-level averages for each raster variable:</span>
<span class="sd">        - &#39;species&#39;: species name</span>
<span class="sd">        - &#39;category&#39;: standardized category label</span>
<span class="sd">        - &#39;precipitation(mm)&#39;, &#39;temperature(c)&#39;, &#39;elevation(m)&#39;: mean values for polygons in the category</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Hardcoded GitHub raw URLs for rasters</span>
    <span class="n">raster_urls</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;precipitation(mm)&quot;</span><span class="p">:</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/avg_precip.tif&quot;</span><span class="p">,</span>
        <span class="s2">&quot;temperature(c)&quot;</span><span class="p">:</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/avg_temp.tif&quot;</span><span class="p">,</span>
        <span class="s2">&quot;elevation(m)&quot;</span><span class="p">:</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/elev.tif&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># -------- Species-wide average --------</span>
    <span class="n">row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">raster_urls</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="c1"># Get zonal stats</span>
                    <span class="n">stats</span> <span class="o">=</span> <span class="n">zonal_stats</span><span class="p">(</span>
                        <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">affine</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                        <span class="n">nodata</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
                        <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

                    <span class="c1"># If zonal stats don&#39;t return valid values, use centroid fallback</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;No valid zonal stats for </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">, falling back to centroid method...&quot;</span>
                        <span class="p">)</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
                            <span class="n">centroid</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span>
                            <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">]</span>
                            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                    <span class="c1"># Ensure values are not empty before calculating the mean</span>
                    <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="n">row</span><span class="p">[</span><span class="s2">&quot;latitudinal_difference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span>
    <span class="n">row</span><span class="p">[</span><span class="s2">&quot;longitudinal_difference&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span>

    <span class="n">total_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">row</span><span class="p">])</span>

    <span class="c1"># -------- Normalize and collapse category labels --------</span>
    <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">category_mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;leading (0.99)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
            <span class="s2">&quot;leading (0.95)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
            <span class="s2">&quot;leading (0.9)&quot;</span><span class="p">:</span> <span class="s2">&quot;leading&quot;</span><span class="p">,</span>
            <span class="s2">&quot;trailing (0.1)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
            <span class="s2">&quot;trailing (0.05)&quot;</span><span class="p">:</span> <span class="s2">&quot;trailing&quot;</span><span class="p">,</span>
            <span class="s2">&quot;relict (0.01 latitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
            <span class="s2">&quot;relict (longitude)&quot;</span><span class="p">:</span> <span class="s2">&quot;relict&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">category_mapping</span><span class="p">)</span>

    <span class="c1"># -------- Category-level averages --------</span>
    <span class="n">category_rows</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span><span class="p">]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">category</span><span class="p">,</span>
            <span class="p">}</span>  <span class="c1"># Reinitialize row here to avoid overwriting</span>
            <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">raster_urls</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                    <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
                    <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                            <span class="c1"># Get zonal stats</span>
                            <span class="n">stats</span> <span class="o">=</span> <span class="n">zonal_stats</span><span class="p">(</span>
                                <span class="n">subset</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                                <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                <span class="n">affine</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                                <span class="n">nodata</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
                                <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

                            <span class="c1"># If zonal stats don&#39;t return valid values, use centroid fallback</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
                                <span class="c1"># print(f&quot;No valid zonal stats for category &#39;{category}&#39; and {var_name}, falling back to centroid method...&quot;)</span>
                                <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">subset</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
                                    <span class="n">centroid</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span>
                                    <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                                    <span class="n">value</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">]</span>
                                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                            <span class="c1"># Ensure values are not empty before calculating the mean</span>
                            <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
                                <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                                    <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                                <span class="p">)</span>  <span class="c1"># Ensure the result is a float</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># If no valid values, assign None</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2"> for category &#39;</span><span class="si">{</span><span class="n">category</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">category_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

    <span class="n">category_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">category_rows</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total_df</span><span class="p">,</span> <span class="n">category_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_gbif_data" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_gbif_data</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_gbif_data" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches occurrence data from GBIF for a specified species, returning up to a specified limit.</p>
      <ul>
<li>species_name (str): The scientific name of the species to query from GBIF.</li>
<li>limit (int, optional): The maximum number of occurrence records to retrieve.
        Defaults to 2000.</li>
</ul>
      <ul>
<li>list[dict]: A list of occurrence records (as dictionaries) containing GBIF data.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_gbif_data</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches occurrence data from GBIF for a specified species, returning up to a specified limit.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - species_name (str): The scientific name of the species to query from GBIF.</span>
<span class="sd">    - limit (int, optional): The maximum number of occurrence records to retrieve.</span>
<span class="sd">            Defaults to 2000.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - list[dict]: A list of occurrence records (as dictionaries) containing GBIF data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">page_limit</span> <span class="o">=</span> <span class="mi">300</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
        <span class="c1"># Fetch the data for the current page</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">occurrences</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
            <span class="n">scientificName</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
            <span class="n">hasGeospatialIssue</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">page_limit</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">hasCoordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add the fetched data to the list</span>
        <span class="n">all_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">])</span>

        <span class="c1"># If we have enough data, break out of the loop</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Otherwise, increment the offset for the next page of results</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">page_limit</span>

    <span class="c1"># Trim the list to exactly the new_limit size if needed</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>

    <span class="c1"># print(f&quot;Fetched {len(all_data)} records (trimmed to requested limit)&quot;)</span>
    <span class="k">return</span> <span class="n">all_data</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_gbif_data_modern" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_gbif_data_modern</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_gbif_data_modern" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches modern occurrence records for a species from GBIF between specified years.</p>
<p>The function works backward from <code>end_year</code> to <code>start_year</code> until the specified limit is reached.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species to query.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit</code></td>
        <td><code>int</code></td>
        <td><p>Maximum number of occurrence records to retrieve. Default is 2000.</p></td>
        <td><code>2000</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>The last year to include in the search (inclusive). Default is 2025.</p></td>
        <td><code>2025</code></td>
      </tr>
      <tr>
        <td><code>start_year</code></td>
        <td><code>int</code></td>
        <td><p>The first year to include in the search (inclusive). Default is 1971.</p></td>
        <td><code>1971</code></td>
      </tr>
      <tr>
        <td><code>basisOfRecord</code></td>
        <td><code>str, list, or None</code></td>
        <td><p>Basis of record filter (e.g., "OBSERVATION",
"PRESERVED_SPECIMEN"). Default is None (no filtering).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list[dict]</code></td>
      <td><p>A list of GBIF occurrence records (dictionaries) up to the specified limit.</p></td>
    </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>The function stops early if no records are found for 5 consecutive years.</li>
<li>Works backward year by year until the limit is reached or the start_year is passed.</li>
</ul>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_gbif_data_modern</span><span class="p">(</span>
    <span class="n">species_name</span><span class="p">,</span>
    <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
    <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span>
    <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span>
    <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches modern occurrence records for a species from GBIF between specified years.</span>

<span class="sd">    The function works backward from `end_year` to `start_year` until the specified limit is reached.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        species_name (str): Scientific name of the species to query.</span>
<span class="sd">        limit (int, optional): Maximum number of occurrence records to retrieve. Default is 2000.</span>
<span class="sd">        end_year (int, optional): The last year to include in the search (inclusive). Default is 2025.</span>
<span class="sd">        start_year (int, optional): The first year to include in the search (inclusive). Default is 1971.</span>
<span class="sd">        basisOfRecord (str, list, or None, optional): Basis of record filter (e.g., &quot;OBSERVATION&quot;,</span>
<span class="sd">            &quot;PRESERVED_SPECIMEN&quot;). Default is None (no filtering).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[dict]: A list of GBIF occurrence records (dictionaries) up to the specified limit.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function stops early if no records are found for 5 consecutive years.</span>
<span class="sd">        - Works backward year by year until the limit is reached or the start_year is passed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">page_limit</span> <span class="o">=</span> <span class="mi">300</span>
    <span class="n">consecutive_empty_years</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">end_year</span><span class="p">,</span> <span class="n">start_year</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">year_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">search_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;scientificName&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;hasCoordinate&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;hasGeospatialIssue&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                <span class="s2">&quot;limit&quot;</span><span class="p">:</span> <span class="n">page_limit</span><span class="p">,</span>
                <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="n">offset</span><span class="p">,</span>
                <span class="s2">&quot;continent&quot;</span><span class="p">:</span> <span class="n">continent</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">basisOfRecord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">search_params</span><span class="p">[</span><span class="s2">&quot;basisOfRecord&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basisOfRecord</span>

            <span class="n">response</span> <span class="o">=</span> <span class="n">occurrences</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="o">**</span><span class="n">search_params</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="p">[])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">year_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">page_limit</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">offset</span> <span class="o">+=</span> <span class="n">page_limit</span>

        <span class="k">if</span> <span class="n">year_data</span><span class="p">:</span>
            <span class="n">all_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">year_data</span><span class="p">)</span>
            <span class="n">consecutive_empty_years</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">consecutive_empty_years</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">all_data</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">consecutive_empty_years</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No data found for 5 consecutive years before </span><span class="si">{</span><span class="n">year</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="si">}</span><span class="s2">. Stopping early.&quot;</span>
            <span class="p">)</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">all_data</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_gbif_data_with_historic</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_gbif_data_with_historic" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches both modern and historic occurrence data from GBIF for a specified species.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit</code></td>
        <td><code>int</code></td>
        <td><p>Max number of records to fetch for each (modern and historic).</p></td>
        <td><code>2000</code></td>
      </tr>
      <tr>
        <td><code>start_year</code></td>
        <td><code>int</code></td>
        <td><p>The earliest year for modern data and latest year for historic data.</p></td>
        <td><code>1971</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int</code></td>
        <td><p>The most recent year to fetch from.</p></td>
        <td><code>2025</code></td>
      </tr>
      <tr>
        <td><code>basisOfRecord</code></td>
        <td><code>str or list or None</code></td>
        <td><p>Basis of record filter for GBIF data (e.g., "PRESERVED_SPECIMEN", "OBSERVATION"). Default is None (no filtering).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dict</code></td>
      <td><p>{
    'modern': [...],  # from start_year + 1 to end_year
    'historic': [...] # from start_year backwards to ~1960
}</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_gbif_data_with_historic</span><span class="p">(</span>
    <span class="n">species_name</span><span class="p">,</span>
    <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
    <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span>
    <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span>
    <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches both modern and historic occurrence data from GBIF for a specified species.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        species_name (str): Scientific name of the species.</span>
<span class="sd">        limit (int): Max number of records to fetch for each (modern and historic).</span>
<span class="sd">        start_year (int): The earliest year for modern data and latest year for historic data.</span>
<span class="sd">        end_year (int): The most recent year to fetch from.</span>
<span class="sd">        basisOfRecord (str or list or None, optional): Basis of record filter for GBIF data (e.g., &quot;PRESERVED_SPECIMEN&quot;, &quot;OBSERVATION&quot;). Default is None (no filtering).</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: {</span>
<span class="sd">            &#39;modern&#39;: [...],  # from start_year + 1 to end_year</span>
<span class="sd">            &#39;historic&#39;: [...] # from start_year backwards to ~1960</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modern</span> <span class="o">=</span> <span class="n">fetch_gbif_data_modern</span><span class="p">(</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
        <span class="n">start_year</span><span class="o">=</span><span class="n">start_year</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">end_year</span><span class="o">=</span><span class="n">end_year</span><span class="p">,</span>
        <span class="n">basisOfRecord</span><span class="o">=</span><span class="n">basisOfRecord</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">historic</span> <span class="o">=</span> <span class="n">fetch_historic_records</span><span class="p">(</span>
        <span class="n">species_name</span><span class="o">=</span><span class="n">species_name</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
        <span class="n">year</span><span class="o">=</span><span class="n">start_year</span><span class="p">,</span>
        <span class="n">basisOfRecord</span><span class="o">=</span><span class="n">basisOfRecord</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;modern&quot;</span><span class="p">:</span> <span class="n">modern</span><span class="p">,</span> <span class="s2">&quot;historic&quot;</span><span class="p">:</span> <span class="n">historic</span><span class="p">}</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.fetch_historic_records" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fetch_historic_records</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.fetch_historic_records" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Fetches historic occurrence records for a species from GBIF, going backward in time
from a specified year until a minimum year or until the record limit is reached.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species to search for.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit</code></td>
        <td><code>int</code></td>
        <td><p>Maximum number of records to retrieve. Default is 2000.</p></td>
        <td><code>2000</code></td>
      </tr>
      <tr>
        <td><code>year</code></td>
        <td><code>int</code></td>
        <td><p>Starting year to fetch historic records from. Default is 1971.</p></td>
        <td><code>1971</code></td>
      </tr>
      <tr>
        <td><code>basisOfRecord</code></td>
        <td><code>str, list, or None</code></td>
        <td><p>Basis of record filter for GBIF data
(e.g., "PRESERVED_SPECIMEN", "OBSERVATION"). Default is None (no filtering).</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list[dict]</code></td>
      <td><p>A list of GBIF occurrence records (dictionaries) up to the specified limit.</p></td>
    </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>The function stops early if no records are found for 5 consecutive years.</li>
<li>Years earlier than 1960 are not queried.</li>
</ul>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_historic_records</span><span class="p">(</span>
    <span class="n">species_name</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">basisOfRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches historic occurrence records for a species from GBIF, going backward in time</span>
<span class="sd">    from a specified year until a minimum year or until the record limit is reached.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        species_name (str): Scientific name of the species to search for.</span>
<span class="sd">        limit (int, optional): Maximum number of records to retrieve. Default is 2000.</span>
<span class="sd">        year (int, optional): Starting year to fetch historic records from. Default is 1971.</span>
<span class="sd">        basisOfRecord (str, list, or None, optional): Basis of record filter for GBIF data</span>
<span class="sd">            (e.g., &quot;PRESERVED_SPECIMEN&quot;, &quot;OBSERVATION&quot;). Default is None (no filtering).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[dict]: A list of GBIF occurrence records (dictionaries) up to the specified limit.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function stops early if no records are found for 5 consecutive years.</span>
<span class="sd">        - Years earlier than 1960 are not queried.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
    <span class="n">page_limit</span> <span class="o">=</span> <span class="mi">300</span>
    <span class="n">consecutive_empty_years</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="ow">and</span> <span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">1960</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">year_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">search_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;scientificName&quot;</span><span class="p">:</span> <span class="n">species_name</span><span class="p">,</span>
                <span class="s2">&quot;hasCoordinate&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;hasGeospatialIssue&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
                <span class="s2">&quot;limit&quot;</span><span class="p">:</span> <span class="n">page_limit</span><span class="p">,</span>
                <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="n">offset</span><span class="p">,</span>
                <span class="s2">&quot;continent&quot;</span><span class="p">:</span> <span class="n">continent</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">basisOfRecord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">search_params</span><span class="p">[</span><span class="s2">&quot;basisOfRecord&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basisOfRecord</span>

            <span class="n">response</span> <span class="o">=</span> <span class="n">occurrences</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="o">**</span><span class="n">search_params</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;results&quot;</span><span class="p">,</span> <span class="p">[])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">year_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">page_limit</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">page_limit</span>

        <span class="k">if</span> <span class="n">year_data</span><span class="p">:</span>
            <span class="n">all_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">year_data</span><span class="p">)</span>
            <span class="n">consecutive_empty_years</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">consecutive_empty_years</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">consecutive_empty_years</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No data found for 5 consecutive years before </span><span class="si">{</span><span class="n">year</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="si">}</span><span class="s2">. Stopping early.&quot;</span>
            <span class="p">)</span>
            <span class="k">break</span>

        <span class="n">year</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">all_data</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="doc doc-heading">
<code class="highlight language-python"><span class="n">full_propagule_pressure_pipeline</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">,</span> <span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.full_propagule_pressure_pipeline" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Full wrapper pipeline to compute propagule pressure from input data.</p>
<div class="admonition steps">
<p class="admonition-title">Steps</p>
<ol>
<li>Merge category dataframes.</li>
<li>Prepare GeoDataFrame for rasterization.</li>
<li>Map category strings to integers.</li>
<li>Rasterize to show and save versions.</li>
<li>Compute propagule pressure for both rasters.</li>
</ol>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>classified_modern</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame with spatial features and categories.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>northward_rate_df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>Contains northward movement rate per point or cell.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>change</code></td>
        <td><code>DataFrame</code></td>
        <td><p>Contains rate of change per point or cell.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>tuple</code></td>
      <td><p>(pressure_show, pressure_save), both as 2D numpy arrays</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">full_propagule_pressure_pipeline</span><span class="p">(</span>
    <span class="n">classified_modern</span><span class="p">,</span> <span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Full wrapper pipeline to compute propagule pressure from input data.</span>

<span class="sd">    Steps:</span>
<span class="sd">        1. Merge category dataframes.</span>
<span class="sd">        2. Prepare GeoDataFrame for rasterization.</span>
<span class="sd">        3. Map category strings to integers.</span>
<span class="sd">        4. Rasterize to show and save versions.</span>
<span class="sd">        5. Compute propagule pressure for both rasters.</span>

<span class="sd">    Args:</span>
<span class="sd">        classified_modern (GeoDataFrame): GeoDataFrame with spatial features and categories.</span>
<span class="sd">        northward_rate_df (DataFrame): Contains northward movement rate per point or cell.</span>
<span class="sd">        change (DataFrame): Contains rate of change per point or cell.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (pressure_show, pressure_save), both as 2D numpy arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Merge data</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">merge_category_dataframes</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span>

    <span class="c1"># Step 2: Prepare for rasterization</span>
    <span class="n">preped_gdf</span> <span class="o">=</span> <span class="n">prepare_gdf_for_rasterization</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">,</span> <span class="n">merged</span><span class="p">)</span>

    <span class="c1"># Step 3: Map category to integers</span>
    <span class="n">preped_gdf_new</span> <span class="o">=</span> <span class="n">cat_int_mapping</span><span class="p">(</span>
        <span class="n">preped_gdf</span>
    <span class="p">)</span>  <span class="c1"># assumes this was renamed from cat_int_mapping</span>

    <span class="c1"># Step 4: Rasterize</span>
    <span class="n">value_columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;density&quot;</span><span class="p">,</span>
        <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rate of Change&quot;</span><span class="p">,</span>
        <span class="s2">&quot;category_int&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">raster_show</span><span class="p">,</span> <span class="n">gdf_transform</span><span class="p">,</span> <span class="n">show_bounds</span> <span class="o">=</span> <span class="n">rasterize_multiband_gdf_match</span><span class="p">(</span>
        <span class="n">preped_gdf_new</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span>
    <span class="p">)</span>
    <span class="n">raster_save</span><span class="p">,</span> <span class="n">world_transform</span><span class="p">,</span> <span class="n">save_bounds</span> <span class="o">=</span> <span class="n">rasterize_multiband_gdf_world</span><span class="p">(</span>
        <span class="n">preped_gdf_new</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span>
    <span class="p">)</span>

    <span class="c1"># Step 5: Compute propagule pressure</span>
    <span class="n">pressure_show</span> <span class="o">=</span> <span class="n">compute_propagule_pressure_range</span><span class="p">(</span><span class="n">raster_show</span><span class="p">)</span>
    <span class="n">pressure_save</span> <span class="o">=</span> <span class="n">compute_propagule_pressure_range</span><span class="p">(</span><span class="n">raster_save</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pressure_show</span><span class="p">,</span>
        <span class="n">pressure_save</span><span class="p">,</span>
        <span class="n">show_bounds</span><span class="p">,</span>
        <span class="n">save_bounds</span><span class="p">,</span>
        <span class="n">gdf_transform</span><span class="p">,</span>
        <span class="n">world_transform</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.get_species_code_if_exists" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_species_code_if_exists</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.get_species_code_if_exists" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Converts species name to 8-letter key and checks if it exists in REFERENCES.
Returns the code if found, else returns False.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_species_code_if_exists</span><span class="p">(</span><span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts species name to 8-letter key and checks if it exists in REFERENCES.</span>
<span class="sd">    Returns the code if found, else returns False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">key</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">REFERENCES</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.get_start_year_from_species" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.get_start_year_from_species" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Retrieves the start year associated with a species from the REFERENCES dictionary.</p>
<p>The function converts a species name into an 8-character key by taking the first
four letters of the genus and the first four letters of the species epithet.
It then looks up this key in the REFERENCES dictionary. If the key is not found
or the species name is incomplete, 'NA' is returned.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>The scientific name of the species in the format 'Genus species'.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>str</code></td>
      <td><p>The start year associated with the species if found in REFERENCES,
     otherwise 'NA'.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves the start year associated with a species from the REFERENCES dictionary.</span>

<span class="sd">    The function converts a species name into an 8-character key by taking the first</span>
<span class="sd">    four letters of the genus and the first four letters of the species epithet.</span>
<span class="sd">    It then looks up this key in the REFERENCES dictionary. If the key is not found</span>
<span class="sd">    or the species name is incomplete, &#39;NA&#39; is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        species_name (str): The scientific name of the species in the format &#39;Genus species&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The start year associated with the species if found in REFERENCES,</span>
<span class="sd">             otherwise &#39;NA&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">REFERENCES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;NA&quot;</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.008</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;north_america&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.make_dbscan_polygons_with_points_from_gdf" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Performs DBSCAN clustering on a GeoDataFrame and returns a GeoDataFrame of
polygons representing clusters with associated points and years.</p>
      <ul>
<li>gdf (GeoDataFrame): Input GeoDataFrame with 'decimalLatitude', 'decimalLongitude', and 'year' columns.</li>
<li>eps (float): Maximum distance between two samples for one to be considered as in the neighborhood of the other.</li>
<li>min_samples (int): The number of samples in a neighborhood for a point to be considered as a core point.</li>
<li>lat_min, lat_max, lon_min, lon_max (float): Bounding box for filtering points. Default values are set to the extent of North America.</li>
</ul>
      <ul>
<li>expanded_gdf (GeoDataFrame): GeoDataFrame of cluster polygons with retained point geometries and years.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.008</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;north_america&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs DBSCAN clustering on a GeoDataFrame and returns a GeoDataFrame of</span>
<span class="sd">    polygons representing clusters with associated points and years.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - gdf (GeoDataFrame): Input GeoDataFrame with &#39;decimalLatitude&#39;, &#39;decimalLongitude&#39;, and &#39;year&#39; columns.</span>
<span class="sd">    - eps (float): Maximum distance between two samples for one to be considered as in the neighborhood of the other.</span>
<span class="sd">    - min_samples (int): The number of samples in a neighborhood for a point to be considered as a core point.</span>
<span class="sd">    - lat_min, lat_max, lon_min, lon_max (float): Bounding box for filtering points. Default values are set to the extent of North America.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - expanded_gdf (GeoDataFrame): GeoDataFrame of cluster polygons with retained point geometries and years.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bounding_boxes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;north_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;europe&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">},</span>
        <span class="s2">&quot;asia&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
        <span class="c1"># South America split at equator</span>
        <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">55</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="c1"># Africa split at equator</span>
        <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;oceania&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounding_boxes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent &#39;</span><span class="si">{</span><span class="n">continent</span><span class="si">}</span><span class="s2">&#39; not recognized. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">bounding_boxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounding_boxes</span><span class="p">[</span><span class="n">continent</span><span class="p">]</span>

    <span class="n">lat_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span>
    <span class="n">lat_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">]</span>
    <span class="n">lon_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span>
    <span class="n">lon_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="s2">&quot;decimalLatitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="s2">&quot;decimalLongitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;GeoDataFrame must contain &#39;decimalLatitude&#39; and &#39;decimalLongitude&#39; columns.&quot;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Clean and filter</span>
    <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data</span><span class="p">[[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;eventDate&quot;</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
        <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lat_min</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lat_max</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lon_min</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;haversine&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">labels_</span>

    <span class="n">gdf_points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]),</span>
        <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">cluster_polygons</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cluster_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">gdf_points</span><span class="p">[</span><span class="n">gdf_points</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">valid_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">cluster_points</span> <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">MultiPoint</span><span class="p">(</span><span class="n">valid_points</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
                    <span class="n">hull_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">corner_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">hull_coords</span><span class="p">]</span>
                    <span class="n">corner_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">corner_points</span> <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">valid_points</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">corner_points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">hull</span> <span class="o">=</span> <span class="n">MultiPoint</span><span class="p">(</span><span class="n">corner_points</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span>
                <span class="n">cluster_polygons</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">hull</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating convex hull for cluster </span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">expanded_rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">cluster_polygon</span> <span class="ow">in</span> <span class="n">cluster_polygons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">gdf_points</span><span class="p">[</span><span class="n">gdf_points</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cluster_points</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">cluster_polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="n">point</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span>
                <span class="n">cluster_polygon</span>
            <span class="p">):</span>
                <span class="n">expanded_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;polygon_geometry&quot;</span><span class="p">:</span> <span class="n">cluster_polygon</span><span class="p">,</span>
                        <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;eventDate&quot;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;eventDate&quot;</span><span class="p">],</span>
                    <span class="p">}</span>
                <span class="p">)</span>

    <span class="n">expanded_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="n">expanded_rows</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;polygon_geometry&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">expanded_rows</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Set &#39;geometry&#39; column as active geometry column explicitly</span>
    <span class="n">expanded_gdf</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Drop &#39;polygon_geometry&#39; as it&#39;s no longer needed</span>
    <span class="n">expanded_gdf</span> <span class="o">=</span> <span class="n">expanded_gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;polygon_geometry&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">expanded_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.merge_and_remap_polygons" class="doc doc-heading">
<code class="highlight language-python"><span class="n">merge_and_remap_polygons</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.merge_and_remap_polygons" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Merges touching or intersecting polygons in a GeoDataFrame and remaps the merged geometry
back to the original rows. Optionally applies a buffer to polygons before merging.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame with columns ['geometry', 'point_geometry', ...].</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>buffer_distance</code></td>
        <td><code>float</code></td>
        <td><p>Distance to buffer polygons before merging (in meters).
Defaults to 0 (no buffer).</p></td>
        <td><code>0</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>A GeoDataFrame where intersecting or touching polygons have been merged,
with the same number of rows as the input and CRS set to EPSG:4326.</p></td>
    </tr>
  </tbody>
</table>      <div class="admonition notes">
<p class="admonition-title">Notes</p>
<p>This function preserves point geometries and ensures the result is in WGS84 (EPSG:4326).</p>
</div>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_and_remap_polygons</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges touching or intersecting polygons in a GeoDataFrame and remaps the merged geometry</span>
<span class="sd">    back to the original rows. Optionally applies a buffer to polygons before merging.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf (GeoDataFrame): Input GeoDataFrame with columns [&#39;geometry&#39;, &#39;point_geometry&#39;, ...].</span>
<span class="sd">        buffer_distance (float, optional): Distance to buffer polygons before merging (in meters).</span>
<span class="sd">            Defaults to 0 (no buffer).</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: A GeoDataFrame where intersecting or touching polygons have been merged,</span>
<span class="sd">        with the same number of rows as the input and CRS set to EPSG:4326.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function preserves point geometries and ensures the result is in WGS84 (EPSG:4326).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Ensure CRS is projected for buffering and spatial operations</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Step 1: Extract unique polygons</span>
    <span class="n">unique_polys</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_polys</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">unique_polys</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Apply buffering if necessary</span>
    <span class="k">if</span> <span class="n">buffer_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">unique_polys</span><span class="p">[</span><span class="s2">&quot;geom_buffered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_distance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_polys</span><span class="p">[</span><span class="s2">&quot;geom_buffered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>

    <span class="c1"># Step 2: Merge only touching or intersecting polygons</span>
    <span class="n">sindex</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">sindex</span>
    <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">unique_polys</span><span class="p">[</span><span class="s2">&quot;geom_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">assigned</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">current_geom</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">current</span><span class="p">,</span> <span class="s2">&quot;geom_buffered&quot;</span><span class="p">]</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sindex</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">current_geom</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">match</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">match_geom</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">match</span><span class="p">,</span> <span class="s2">&quot;geom_buffered&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">current_geom</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">match_geom</span><span class="p">)</span> <span class="ow">or</span> <span class="n">current_geom</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span>
                        <span class="n">match_geom</span>
                    <span class="p">):</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
        <span class="n">assigned</span> <span class="o">|=</span> <span class="n">group</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="c1"># Step 3: Build mapping from original polygon to merged geometry</span>
    <span class="n">polygon_to_merged</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">merged_geoms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">group_polys</span> <span class="o">=</span> <span class="n">unique_polys</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">group_polys</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">merged_geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">group_polys</span><span class="p">:</span>
            <span class="n">polygon_to_merged</span><span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">wkt</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>

    <span class="c1"># Step 4: Map merged geometry back to each row in original gdf based on geometry</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;merged_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">poly</span><span class="p">:</span> <span class="n">polygon_to_merged</span><span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">wkt</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Step 5: Set the merged geometry as the active geometry column</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;merged_geometry&quot;</span><span class="p">]</span>

    <span class="c1"># Step 6: Remove temporary &#39;merged_geometry&#39; column</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;merged_geometry&quot;</span><span class="p">])</span>

    <span class="c1"># Step 7: Ensure that point geometries are correctly associated (keep them unchanged)</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">]</span>

    <span class="c1"># Set the &#39;geometry&#39; column explicitly as the active geometry column</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Optional: reproject to WGS84 (EPSG:4326)</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">4326</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.merge_category_dataframes" class="doc doc-heading">
<code class="highlight language-python"><span class="n">merge_category_dataframes</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.merge_category_dataframes" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Merges three category-level dataframes on the 'category' column and returns the merged result.
Standardizes 'category' casing to title case before merging.</p>
      <p>northward_rate_df : pandas.DataFrame
    DataFrame containing northward movement rates for each category. Expected columns:
    - 'category' or 'Category': category name
    - 'species' (optional)
    - 'northward_rate_km_per_year': numeric rate of northward movement
change : pandas.DataFrame
    DataFrame containing change metrics for each category. Expected columns:
    - 'category' or 'Category': category name
    - 'species' (optional)
    - 'Rate of Change': numeric change value</p>
      <p>pandas.DataFrame
    Merged DataFrame containing:
    - 'species': species name (if available)
    - 'category': standardized category name (title case)
    - 'northward_rate_km_per_year': numeric northward movement rate
    - 'Rate of Change': numeric change value</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_category_dataframes</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges three category-level dataframes on the &#39;category&#39; column and returns the merged result.</span>
<span class="sd">    Standardizes &#39;category&#39; casing to title case before merging.</span>

<span class="sd">    Args:</span>
<span class="sd">    northward_rate_df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing northward movement rates for each category. Expected columns:</span>
<span class="sd">        - &#39;category&#39; or &#39;Category&#39;: category name</span>
<span class="sd">        - &#39;species&#39; (optional)</span>
<span class="sd">        - &#39;northward_rate_km_per_year&#39;: numeric rate of northward movement</span>
<span class="sd">    change : pandas.DataFrame</span>
<span class="sd">        DataFrame containing change metrics for each category. Expected columns:</span>
<span class="sd">        - &#39;category&#39; or &#39;Category&#39;: category name</span>
<span class="sd">        - &#39;species&#39; (optional)</span>
<span class="sd">        - &#39;Rate of Change&#39;: numeric change value</span>

<span class="sd">    Returns:</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        Merged DataFrame containing:</span>
<span class="sd">        - &#39;species&#39;: species name (if available)</span>
<span class="sd">        - &#39;category&#39;: standardized category name (title case)</span>
<span class="sd">        - &#39;northward_rate_km_per_year&#39;: numeric northward movement rate</span>
<span class="sd">        - &#39;Rate of Change&#39;: numeric change value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="c1"># Standardize &#39;category&#39; column</span>
    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="p">[</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">]:</span>
        <span class="k">if</span> <span class="s2">&quot;Category&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Category&quot;</span><span class="p">:</span> <span class="s2">&quot;category&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>

    <span class="c1"># Merge dataframes</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">northward_rate_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">change</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>

    <span class="c1"># Drop duplicated species columns if they exist</span>
    <span class="k">if</span> <span class="s2">&quot;species_x&quot;</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;species_y&quot;</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;species_x&quot;</span><span class="p">,</span> <span class="s2">&quot;species_y&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">cols_to_keep</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;species&quot;</span><span class="p">,</span>
        <span class="s2">&quot;category&quot;</span><span class="p">,</span>
        <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rate of Change&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols_to_keep</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">merged_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.merge_touching_groups" class="doc doc-heading">
<code class="highlight language-python"><span class="n">merge_touching_groups</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.merge_touching_groups" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Merges polygons in a GeoDataFrame that touch or intersect into fully connected groups.</p>
<p>This function:
    - Optionally applies a small buffer to geometries to ensure touching polygons
      are detected.
    - Find all polygons connected to other polygons.
    - Merges geometries in each connected group using <code>unary_union</code>.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GeoDataFrame containing polygon geometries and attributes.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>buffer_distance</code></td>
        <td><code>float</code></td>
        <td><p>Distance (in projection units) to buffer
geometries for merging. Defaults to 0 (no buffering).</p></td>
        <td><code>0</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>New GeoDataFrame with:
    - Merged geometries of all touching/intersecting polygons.
    - Numeric attributes summed across merged polygons.
    - Non-numeric attributes taken from the first polygon in each group.
    - CRS preserved from the input (reprojected to EPSG:3395 if necessary).</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_touching_groups</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges polygons in a GeoDataFrame that touch or intersect into fully connected groups.</span>

<span class="sd">    This function:</span>
<span class="sd">        - Optionally applies a small buffer to geometries to ensure touching polygons</span>
<span class="sd">          are detected.</span>
<span class="sd">        - Find all polygons connected to other polygons.</span>
<span class="sd">        - Merges geometries in each connected group using `unary_union`.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf (GeoDataFrame): Input GeoDataFrame containing polygon geometries and attributes.</span>
<span class="sd">        buffer_distance (float, optional): Distance (in projection units) to buffer</span>
<span class="sd">            geometries for merging. Defaults to 0 (no buffering).</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: New GeoDataFrame with:</span>
<span class="sd">            - Merged geometries of all touching/intersecting polygons.</span>
<span class="sd">            - Numeric attributes summed across merged polygons.</span>
<span class="sd">            - Non-numeric attributes taken from the first polygon in each group.</span>
<span class="sd">            - CRS preserved from the input (reprojected to EPSG:3395 if necessary).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Suppress specific warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3395</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3395</span><span class="p">)</span>

    <span class="c1"># Apply small positive buffer if requested (only for matching)</span>
    <span class="k">if</span> <span class="n">buffer_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_distance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span>

    <span class="c1"># Build spatial index on buffered geometry</span>
    <span class="n">sindex</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">sindex</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">assigned</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># Find all polygons that touch or intersect</span>
        <span class="n">possible_matches_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sindex</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
        <span class="n">possible_matches</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">possible_matches_index</span><span class="p">]</span>
        <span class="n">touching</span> <span class="o">=</span> <span class="n">possible_matches</span><span class="p">[</span>
            <span class="n">possible_matches</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
            <span class="o">|</span> <span class="n">possible_matches</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Include self</span>
        <span class="n">touching_idxs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">touching</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">touching_idxs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Expand to fully connected group</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">to_check</span> <span class="o">=</span> <span class="n">touching_idxs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">to_check</span><span class="p">:</span>
            <span class="n">checking_idx</span> <span class="o">=</span> <span class="n">to_check</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">checking_idx</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">group</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">checking_idx</span><span class="p">)</span>
            <span class="n">checking_geom</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">checking_idx</span><span class="p">]</span>
            <span class="n">new_matches_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sindex</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">checking_geom</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
            <span class="n">new_matches</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">new_matches_idx</span><span class="p">]</span>
            <span class="n">new_touching</span> <span class="o">=</span> <span class="n">new_matches</span><span class="p">[</span>
                <span class="n">new_matches</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">checking_geom</span><span class="p">)</span>
                <span class="o">|</span> <span class="n">new_matches</span><span class="p">[</span><span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">checking_geom</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">new_touching_idxs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_touching</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">to_check</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_touching_idxs</span> <span class="o">-</span> <span class="n">group</span><span class="p">)</span>

        <span class="n">assigned</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="c1"># Merge geometries and attributes</span>
    <span class="n">merged_records</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">group_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>

        <span class="c1"># Merge original geometries (NOT buffered ones)</span>
        <span class="n">merged_geom</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">group_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

        <span class="c1"># Aggregate attributes</span>
        <span class="n">record</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry_buffered&quot;</span><span class="p">]:</span>
                <span class="n">record</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_geom</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">group_gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                    <span class="n">record</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_gdf</span><span class="p">[</span>
                        <span class="n">col</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># Sum numeric fields like AREA, PERIMETER</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">record</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>  <span class="c1"># Keep the first value for text/categorical columns</span>

        <span class="n">merged_records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

    <span class="n">merged_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">merged_records</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Reset warnings filter to default</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.prepare_data" class="doc doc-heading">
<code class="highlight language-python"><span class="n">prepare_data</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.prepare_data" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Aggregate point data by polygon and prepare a GeoDataFrame for mapping.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame or gpd.GeoDataFrame</code></td>
        <td><p>Input DataFrame containing at least the following columns:
- 'geometry_id': Identifier for each polygon
- 'geometry': Polygon geometry
- 'point_geometry': Point geometry to be counted per polygon
- 'category': A categorical column associated with the polygon</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gpd.GeoDataFrame</code></td>
      <td><p>Aggregated GeoDataFrame with columns:
    - 'geometry_id': Polygon identifier
    - 'geometry': Polygon geometry
    - 'category': First category value per polygon
    - 'point_count': Number of points within each polygon</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prepare_data</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregate point data by polygon and prepare a GeoDataFrame for mapping.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame or gpd.GeoDataFrame):</span>
<span class="sd">            Input DataFrame containing at least the following columns:</span>
<span class="sd">            - &#39;geometry_id&#39;: Identifier for each polygon</span>
<span class="sd">            - &#39;geometry&#39;: Polygon geometry</span>
<span class="sd">            - &#39;point_geometry&#39;: Point geometry to be counted per polygon</span>
<span class="sd">            - &#39;category&#39;: A categorical column associated with the polygon</span>

<span class="sd">    Returns:</span>
<span class="sd">        gpd.GeoDataFrame: Aggregated GeoDataFrame with columns:</span>
<span class="sd">            - &#39;geometry_id&#39;: Polygon identifier</span>
<span class="sd">            - &#39;geometry&#39;: Polygon geometry</span>
<span class="sd">            - &#39;category&#39;: First category value per polygon</span>
<span class="sd">            - &#39;point_count&#39;: Number of points within each polygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;point_count&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">gdf_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
    <span class="n">gdf_polygons</span> <span class="o">=</span> <span class="n">gdf_polygons</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gdf_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="doc doc-heading">
<code class="highlight language-python"><span class="n">prepare_gdf_for_rasterization</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">df_values</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.prepare_gdf_for_rasterization" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Merge polygon-level GeoDataFrame with range-level category values,
and remove duplicate polygons.</p>
      <ul>
<li>gdf: GeoDataFrame with polygons and category/density</li>
<li>df_values: DataFrame with category, northward_rate_km_per_year, Rate of Change</li>
</ul>
      <ul>
<li>GeoDataFrame with merged attributes and unique geometries</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prepare_gdf_for_rasterization</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">df_values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge polygon-level GeoDataFrame with range-level category values,</span>
<span class="sd">    and remove duplicate polygons.</span>

<span class="sd">    Args:</span>
<span class="sd">    - gdf: GeoDataFrame with polygons and category/density</span>
<span class="sd">    - df_values: DataFrame with category, northward_rate_km_per_year, Rate of Change</span>

<span class="sd">    Returns:</span>
<span class="sd">    - GeoDataFrame with merged attributes and unique geometries</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Standardize category column casing</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
    <span class="n">df_values</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_values</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>

    <span class="c1"># Merge based on &#39;category&#39;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_values</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Optional: handle missing Rate of Change or movement values</span>
    <span class="n">merged</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s2">&quot;Rate of Change&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Select relevant columns</span>
    <span class="n">relevant_columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
        <span class="s2">&quot;category&quot;</span><span class="p">,</span>
        <span class="s2">&quot;density&quot;</span><span class="p">,</span>
        <span class="s2">&quot;northward_rate_km_per_year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rate of Change&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">final_gdf</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="n">relevant_columns</span><span class="p">]</span>

    <span class="c1"># Drop duplicate geometries</span>
    <span class="n">final_gdf</span> <span class="o">=</span> <span class="n">final_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_gbif_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_gbif_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">,</span> <span class="n">columns_to_keep</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;species&#39;</span><span class="p">,</span> <span class="s1">&#39;decimalLatitude&#39;</span><span class="p">,</span> <span class="s1">&#39;decimalLongitude&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;basisOfRecord&#39;</span><span class="p">])</span></code>


<a href="#ecospat.stand_alone_functions.process_gbif_csv" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Processes a GBIF download CSV, filters and cleans it, and returns a dictionary
of species-specific GeoDataFrames (in memory only).</p>
      <ul>
<li>csv_path (str): Path to the GBIF CSV download (tab-separated).</li>
<li>columns_to_keep (list): List of columns to retain from the CSV.</li>
</ul>
      <ul>
<li>dict: Keys are species names (with underscores), values are GeoDataFrames.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_gbif_csv</span><span class="p">(</span>
    <span class="n">csv_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">columns_to_keep</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;species&quot;</span><span class="p">,</span>
        <span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;year&quot;</span><span class="p">,</span>
        <span class="s2">&quot;basisOfRecord&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a GBIF download CSV, filters and cleans it, and returns a dictionary</span>
<span class="sd">    of species-specific GeoDataFrames (in memory only).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - csv_path (str): Path to the GBIF CSV download (tab-separated).</span>
<span class="sd">    - columns_to_keep (list): List of columns to retain from the CSV.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - dict: Keys are species names (with underscores), values are GeoDataFrames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Load the CSV file</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Filter columns</span>
    <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">columns_to_keep</span><span class="p">]</span>

    <span class="c1"># Group by species</span>
    <span class="n">species_grouped</span> <span class="o">=</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;species&quot;</span><span class="p">)</span>

    <span class="c1"># Prepare output dictionary</span>
    <span class="n">species_gdfs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">species_name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">species_grouped</span><span class="p">:</span>
        <span class="n">species_key</span> <span class="o">=</span> <span class="n">species_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="c1"># Clean the data</span>
        <span class="n">group_cleaned</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">group_cleaned</span> <span class="o">=</span> <span class="n">group_cleaned</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
            <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">,</span> <span class="s2">&quot;decimalLongitude&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Convert to GeoDataFrame</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">group_cleaned</span><span class="p">,</span>
            <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span>
                <span class="n">group_cleaned</span><span class="p">[</span><span class="s2">&quot;decimalLongitude&quot;</span><span class="p">],</span> <span class="n">group_cleaned</span><span class="p">[</span><span class="s2">&quot;decimalLatitude&quot;</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add to dictionary</span>
        <span class="n">species_gdfs</span><span class="p">[</span><span class="n">species_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span>

    <span class="k">return</span> <span class="n">species_gdfs</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_gbif_data_pipeline" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_gbif_data_pipeline</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">year_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;north_america&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Run the GBIF spatial data pipeline for species occurrence records.</p>
<p>This function takes a GeoDataFrame of GBIF occurrence points and processes
them into classified range polygons through a multi-step pipeline:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code>1. Cluster occurrence points into polygons using DBSCAN,
   constrained by latitude/longitude bounds.
2. Optionally prune polygons by year (for modern data only).
3. Merge and remap overlapping polygons with a buffer.
4. Remove polygons that overlap with lakes.
5. Clip polygons to the specified continental bounding box.
6. Assign cluster IDs and identify the largest polygon per cluster.
7. Classify polygons into range-edge categories (leading, core, trailing, relict).
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GBIF occurrence data containing point geometries.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species.
Required if <code>year_range</code> is not provided for modern data.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>is_modern</code></td>
        <td><code>bool, default=True</code></td>
        <td><p>If True, filters occurrences by year range.
If False, skips year-based pruning (for historical data).</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>year_range</code></td>
        <td><code>tuple[int, int]</code></td>
        <td><p>(start_year, end_year) for filtering.
If None and <code>is_modern=True</code>, the start year will be inferred from species data
or <code>user_start_year</code>.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int, default=2025</code></td>
        <td><p>End year for modern pruning if <code>year_range</code> not provided.</p></td>
        <td><code>2025</code></td>
      </tr>
      <tr>
        <td><code>user_start_year</code></td>
        <td><code>int</code></td>
        <td><p>Override start year if species-specific start year
is unavailable.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>continent</code></td>
        <td><code>str, default=&#34;north_america&#34;</code></td>
        <td><p>Region keyword passed to
<code>classify_range_edges_gbif</code> to control edge classification thresholds.
Supported values:
- "north_america"
- "europe"
- "asia"
- "north_africa"
- "central_north_south_america"</p></td>
        <td><code>&#39;north_america&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>Polygons representing clustered species ranges with metadata:
    - 'cluster': Cluster ID
    - 'category': Edge classification ("leading", "core", "trailing", "relict")
    - geometry: Polygon geometries after clustering, merging, clipping, and filtering.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If <code>species_name</code> is missing when <code>year_range</code> is None and <code>is_modern=True</code>.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>If a start year cannot be determined and <code>user_start_year</code> is not provided.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_gbif_data_pipeline</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span>
    <span class="n">species_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">year_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span>
    <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;north_america&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the GBIF spatial data pipeline for species occurrence records.</span>

<span class="sd">    This function takes a GeoDataFrame of GBIF occurrence points and processes</span>
<span class="sd">    them into classified range polygons through a multi-step pipeline:</span>

<span class="sd">        1. Cluster occurrence points into polygons using DBSCAN,</span>
<span class="sd">           constrained by latitude/longitude bounds.</span>
<span class="sd">        2. Optionally prune polygons by year (for modern data only).</span>
<span class="sd">        3. Merge and remap overlapping polygons with a buffer.</span>
<span class="sd">        4. Remove polygons that overlap with lakes.</span>
<span class="sd">        5. Clip polygons to the specified continental bounding box.</span>
<span class="sd">        6. Assign cluster IDs and identify the largest polygon per cluster.</span>
<span class="sd">        7. Classify polygons into range-edge categories (leading, core, trailing, relict).</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf (GeoDataFrame): GBIF occurrence data containing point geometries.</span>
<span class="sd">        species_name (str, optional): Scientific name of the species.</span>
<span class="sd">            Required if `year_range` is not provided for modern data.</span>
<span class="sd">        is_modern (bool, default=True): If True, filters occurrences by year range.</span>
<span class="sd">            If False, skips year-based pruning (for historical data).</span>
<span class="sd">        year_range (tuple[int, int], optional): (start_year, end_year) for filtering.</span>
<span class="sd">            If None and `is_modern=True`, the start year will be inferred from species data</span>
<span class="sd">            or `user_start_year`.</span>
<span class="sd">        end_year (int, default=2025): End year for modern pruning if `year_range` not provided.</span>
<span class="sd">        user_start_year (int, optional): Override start year if species-specific start year</span>
<span class="sd">            is unavailable.</span>
<span class="sd">        continent (str, default=&quot;north_america&quot;): Region keyword passed to</span>
<span class="sd">            `classify_range_edges_gbif` to control edge classification thresholds.</span>
<span class="sd">            Supported values:</span>
<span class="sd">            - &quot;north_america&quot;</span>
<span class="sd">            - &quot;europe&quot;</span>
<span class="sd">            - &quot;asia&quot;</span>
<span class="sd">            - &quot;north_africa&quot;</span>
<span class="sd">            - &quot;central_north_south_america&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: Polygons representing clustered species ranges with metadata:</span>
<span class="sd">            - &#39;cluster&#39;: Cluster ID</span>
<span class="sd">            - &#39;category&#39;: Edge classification (&quot;leading&quot;, &quot;core&quot;, &quot;trailing&quot;, &quot;relict&quot;)</span>
<span class="sd">            - geometry: Polygon geometries after clustering, merging, clipping, and filtering.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `species_name` is missing when `year_range` is None and `is_modern=True`.</span>
<span class="sd">        ValueError: If a start year cannot be determined and `user_start_year` is not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bounding_boxes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;north_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;europe&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">},</span>
        <span class="s2">&quot;asia&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
        <span class="c1"># South America split at equator</span>
        <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">55</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="c1"># Africa split at equator</span>
        <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;oceania&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounding_boxes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent &#39;</span><span class="si">{</span><span class="n">continent</span><span class="si">}</span><span class="s2">&#39; not recognized. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">bounding_boxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounding_boxes</span><span class="p">[</span><span class="n">continent</span><span class="p">]</span>

    <span class="n">lat_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span>
    <span class="n">lat_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">]</span>
    <span class="n">lon_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span>
    <span class="n">lon_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">is_modern</span> <span class="ow">and</span> <span class="n">year_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">species_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;species_name must be provided if year_range is not.&quot;</span><span class="p">)</span>

        <span class="c1"># Get start year from species data if available, otherwise use a default</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_start_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_start_year</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start year not found for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

        <span class="c1"># Use the provided end_year if available, otherwise default to 2025</span>
        <span class="n">year_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_year</span><span class="p">,</span> <span class="n">end_year</span><span class="p">)</span>

    <span class="c1"># Step 1: Create DBSCAN polygons</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="n">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">)</span>

    <span class="c1"># Step 2: Optionally prune by year for modern data</span>
    <span class="k">if</span> <span class="n">is_modern</span><span class="p">:</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="n">prune_by_year</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">year_range</span><span class="p">)</span>

    <span class="c1"># Step 3: Merge and remap</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merge_and_remap_polygons</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Step 4: Remove lakes</span>
    <span class="n">unique_polys_no_lakes</span> <span class="o">=</span> <span class="n">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">)</span>

    <span class="c1"># Step 5: Clip to continents</span>
    <span class="n">clipped_polys</span> <span class="o">=</span> <span class="n">clip_polygons_to_continent_gbif</span><span class="p">(</span>
        <span class="n">unique_polys_no_lakes</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Step 6: Assign cluster ID and large polygon</span>
    <span class="n">assigned_poly</span><span class="p">,</span> <span class="n">large_poly</span> <span class="o">=</span> <span class="n">assign_polygon_clusters_gbif_test</span><span class="p">(</span><span class="n">clipped_polys</span><span class="p">)</span>

    <span class="c1"># Step 7: Classify edges</span>
    <span class="n">classified_poly</span> <span class="o">=</span> <span class="n">classify_range_edges_gbif</span><span class="p">(</span><span class="n">assigned_poly</span><span class="p">,</span> <span class="n">large_poly</span><span class="p">,</span> <span class="n">continent</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">classified_poly</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_gbif_data_pipeline_south" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_gbif_data_pipeline_south</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">species_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">year_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span> <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="s1">&#39;oceania&#39;</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.process_gbif_data_pipeline_south" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Processes GBIF occurrence data into classified Southern Hemisphere range polygons.</p>
<p>This function executes a multi-step spatial filtering and classification pipeline
for occurrence data in the Southern Hemisphere. Compared to the northern pipeline,
it flips hemisphere logic so that <strong>leading edges are further south</strong> and
<strong>trailing edges are further north</strong>, with relict thresholds adjusted accordingly.</p>
<p>The pipeline includes:
    1. Creating DBSCAN polygons from occurrence points within global bounds.
    2. Optionally pruning polygons by year for modern data.
    3. Merging and remapping overlapping polygons with a buffer distance.
    4. Removing polygons that fall within lakes.
    5. Clipping polygons to continent-specific bounds.
    6. Assigning cluster IDs and identifying the largest polygon in each cluster.
    7. Classifying polygons into range-edge categories
       (leading, core, trailing, relict) using Southern Hemisphere rules.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Input GBIF occurrence data containing point geometries.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species_name</code></td>
        <td><code>str</code></td>
        <td><p>Scientific name of the species. Required if <code>year_range</code> is not provided.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>is_modern</code></td>
        <td><code>bool, default=True</code></td>
        <td><p>Whether the data should be treated as modern.
If False, year pruning is skipped.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>year_range</code></td>
        <td><code>tuple[int, int]</code></td>
        <td><p>Explicit (start_year, end_year) for filtering occurrences.
Used only if <code>is_modern=True</code>.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>end_year</code></td>
        <td><code>int, default=2025</code></td>
        <td><p>End year for pruning modern data. Ignored if <code>year_range</code> is provided.</p></td>
        <td><code>2025</code></td>
      </tr>
      <tr>
        <td><code>user_start_year</code></td>
        <td><code>int</code></td>
        <td><p>User-specified start year if species-specific start year
cannot be determined internally.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>continent</code></td>
        <td><code>str, default=&#34;oceania&#34;</code></td>
        <td><p>Target continent for classification thresholds.
Supported values:
    - "oceania"
    - "central_south_south_america"
    - "central_south_africa"</p></td>
        <td><code>&#39;oceania&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>A GeoDataFrame of classified polygons with cluster IDs,
    range-edge categories, and metadata. Each polygon represents a
    spatially clustered portion of the species' Southern Hemisphere range,
    pruned, merged, and clipped to valid continental bounds.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_gbif_data_pipeline_south</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span>
    <span class="n">species_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">is_modern</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">year_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">,</span>
    <span class="n">user_start_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continent</span><span class="o">=</span><span class="s2">&quot;oceania&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes GBIF occurrence data into classified Southern Hemisphere range polygons.</span>

<span class="sd">    This function executes a multi-step spatial filtering and classification pipeline</span>
<span class="sd">    for occurrence data in the Southern Hemisphere. Compared to the northern pipeline,</span>
<span class="sd">    it flips hemisphere logic so that **leading edges are further south** and</span>
<span class="sd">    **trailing edges are further north**, with relict thresholds adjusted accordingly.</span>

<span class="sd">    The pipeline includes:</span>
<span class="sd">        1. Creating DBSCAN polygons from occurrence points within global bounds.</span>
<span class="sd">        2. Optionally pruning polygons by year for modern data.</span>
<span class="sd">        3. Merging and remapping overlapping polygons with a buffer distance.</span>
<span class="sd">        4. Removing polygons that fall within lakes.</span>
<span class="sd">        5. Clipping polygons to continent-specific bounds.</span>
<span class="sd">        6. Assigning cluster IDs and identifying the largest polygon in each cluster.</span>
<span class="sd">        7. Classifying polygons into range-edge categories</span>
<span class="sd">           (leading, core, trailing, relict) using Southern Hemisphere rules.</span>

<span class="sd">    Args:</span>
<span class="sd">        gdf (GeoDataFrame):</span>
<span class="sd">            Input GBIF occurrence data containing point geometries.</span>
<span class="sd">        species_name (str, optional):</span>
<span class="sd">            Scientific name of the species. Required if `year_range` is not provided.</span>
<span class="sd">        is_modern (bool, default=True):</span>
<span class="sd">            Whether the data should be treated as modern.</span>
<span class="sd">            If False, year pruning is skipped.</span>
<span class="sd">        year_range (tuple[int, int], optional):</span>
<span class="sd">            Explicit (start_year, end_year) for filtering occurrences.</span>
<span class="sd">            Used only if `is_modern=True`.</span>
<span class="sd">        end_year (int, default=2025):</span>
<span class="sd">            End year for pruning modern data. Ignored if `year_range` is provided.</span>
<span class="sd">        user_start_year (int, optional):</span>
<span class="sd">            User-specified start year if species-specific start year</span>
<span class="sd">            cannot be determined internally.</span>
<span class="sd">        continent (str, default=&quot;oceania&quot;):</span>
<span class="sd">            Target continent for classification thresholds.</span>
<span class="sd">            Supported values:</span>
<span class="sd">                - &quot;oceania&quot;</span>
<span class="sd">                - &quot;central_south_south_america&quot;</span>
<span class="sd">                - &quot;central_south_africa&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame:</span>
<span class="sd">            A GeoDataFrame of classified polygons with cluster IDs,</span>
<span class="sd">            range-edge categories, and metadata. Each polygon represents a</span>
<span class="sd">            spatially clustered portion of the species&#39; Southern Hemisphere range,</span>
<span class="sd">            pruned, merged, and clipped to valid continental bounds.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:</span>
<span class="sd">            If `species_name` is not provided and `year_range` is None for modern data.</span>
<span class="sd">        ValueError:</span>
<span class="sd">            If a start year cannot be determined for the species and `user_start_year` is not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bounding_boxes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;north_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;europe&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">40</span><span class="p">},</span>
        <span class="s2">&quot;asia&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
        <span class="c1"># South America split at equator</span>
        <span class="s2">&quot;central_north_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;central_south_south_america&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">55</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">80</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="c1"># Africa split at equator</span>
        <span class="s2">&quot;north_africa&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="s2">&quot;central_south_africa&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>
            <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;oceania&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;lat_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="s2">&quot;lat_max&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;lon_min&quot;</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="s2">&quot;lon_max&quot;</span><span class="p">:</span> <span class="mi">180</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">continent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounding_boxes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continent &#39;</span><span class="si">{</span><span class="n">continent</span><span class="si">}</span><span class="s2">&#39; not recognized. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">bounding_boxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounding_boxes</span><span class="p">[</span><span class="n">continent</span><span class="p">]</span>

    <span class="n">lat_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_min&quot;</span><span class="p">]</span>
    <span class="n">lat_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lat_max&quot;</span><span class="p">]</span>
    <span class="n">lon_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_min&quot;</span><span class="p">]</span>
    <span class="n">lon_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;lon_max&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">is_modern</span> <span class="ow">and</span> <span class="n">year_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">species_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;species_name must be provided if year_range is not.&quot;</span><span class="p">)</span>

        <span class="c1"># Get start year from species data if available, otherwise use a default</span>
        <span class="n">start_year</span> <span class="o">=</span> <span class="n">get_start_year_from_species</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_year</span> <span class="o">==</span> <span class="s2">&quot;NA&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_start_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_start_year</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start year not found for species &#39;</span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_year</span><span class="p">)</span>

        <span class="c1"># Use the provided end_year if available, otherwise default to 2025</span>
        <span class="n">year_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_year</span><span class="p">,</span> <span class="n">end_year</span><span class="p">)</span>

    <span class="c1"># Step 1: Create DBSCAN polygons</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="n">make_dbscan_polygons_with_points_from_gdf</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">)</span>

    <span class="c1"># Step 2: Optionally prune by year for modern data</span>
    <span class="k">if</span> <span class="n">is_modern</span><span class="p">:</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="n">prune_by_year</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">year_range</span><span class="p">)</span>

    <span class="c1"># Step 3: Merge and remap</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merge_and_remap_polygons</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Step 4: Remove lakes</span>
    <span class="n">unique_polys_no_lakes</span> <span class="o">=</span> <span class="n">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">)</span>

    <span class="c1"># Step 5: Clip to continents</span>
    <span class="n">clipped_polys</span> <span class="o">=</span> <span class="n">clip_polygons_to_continent_gbif</span><span class="p">(</span>
        <span class="n">unique_polys_no_lakes</span><span class="p">,</span>
        <span class="n">continent</span><span class="o">=</span><span class="n">continent</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Step 6: Assign cluster ID and large polygon</span>
    <span class="n">assigned_poly</span><span class="p">,</span> <span class="n">large_poly</span> <span class="o">=</span> <span class="n">assign_polygon_clusters_gbif_test</span><span class="p">(</span><span class="n">clipped_polys</span><span class="p">)</span>

    <span class="c1"># Step 7: Classify edges</span>
    <span class="n">classified_poly</span> <span class="o">=</span> <span class="n">classify_range_edges_gbif_south</span><span class="p">(</span>
        <span class="n">assigned_poly</span><span class="p">,</span> <span class="n">large_poly</span><span class="p">,</span> <span class="n">continent</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">classified_poly</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.process_species_historical_range" class="doc doc-heading">
<code class="highlight language-python"><span class="n">process_species_historical_range</span><span class="p">(</span><span class="n">new_map</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.process_species_historical_range" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Wrapper function to process species range and classification using the HistoricalMap instance.
Performs the following operations:
1. Retrieves the species code using the species name.
2. Loads the historic data for the species.
3. Removes lakes from the species range.
4. Merges touching polygons.
5. Clusters and classifies the polygons.
6. Updates the polygon categories.</p>
      <ul>
<li>new_map (HistoricalMap): The map object that contains the species' historical data.</li>
<li>species_name (str): The name of the species to process.</li>
</ul>
      <ul>
<li>updated_polygon: The updated polygon with classification and category information.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_species_historical_range</span><span class="p">(</span><span class="n">new_map</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to process species range and classification using the HistoricalMap instance.</span>
<span class="sd">    Performs the following operations:</span>
<span class="sd">    1. Retrieves the species code using the species name.</span>
<span class="sd">    2. Loads the historic data for the species.</span>
<span class="sd">    3. Removes lakes from the species range.</span>
<span class="sd">    4. Merges touching polygons.</span>
<span class="sd">    5. Clusters and classifies the polygons.</span>
<span class="sd">    6. Updates the polygon categories.</span>

<span class="sd">    Args:</span>
<span class="sd">    - new_map (HistoricalMap): The map object that contains the species&#39; historical data.</span>
<span class="sd">    - species_name (str): The name of the species to process.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - updated_polygon: The updated polygon with classification and category information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Get the species code</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">get_species_code_if_exists</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">code</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Species code not found for </span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Step 2: Load historic data</span>
    <span class="n">new_map</span><span class="o">.</span><span class="n">load_historic_data</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

    <span class="c1"># Step 3: Remove lakes from the species range</span>
    <span class="n">range_no_lakes</span> <span class="o">=</span> <span class="n">new_map</span><span class="o">.</span><span class="n">remove_lakes</span><span class="p">(</span><span class="n">new_map</span><span class="o">.</span><span class="n">gdfs</span><span class="p">[</span><span class="n">code</span><span class="p">])</span>

    <span class="c1"># Step 4: Merge touching polygons</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merge_touching_groups</span><span class="p">(</span><span class="n">range_no_lakes</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>

    <span class="c1"># Step 5: Cluster and classify polygons</span>
    <span class="n">clustered_polygons</span><span class="p">,</span> <span class="n">largest_polygons</span> <span class="o">=</span> <span class="n">assign_polygon_clusters</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">)</span>
    <span class="n">classified_polygons</span> <span class="o">=</span> <span class="n">classify_range_edges</span><span class="p">(</span><span class="n">clustered_polygons</span><span class="p">,</span> <span class="n">largest_polygons</span><span class="p">)</span>

    <span class="c1"># Step 6: Update the polygon categories</span>
    <span class="n">updated_polygon</span> <span class="o">=</span> <span class="n">update_polygon_categories</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">,</span> <span class="n">classified_polygons</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_polygon</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.prune_by_year" class="doc doc-heading">
<code class="highlight language-python"><span class="n">prune_by_year</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.prune_by_year" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Prune a DataFrame to only include rows where 'year' is between start_year and end_year (inclusive).</p>
      <ul>
<li>df: pandas.DataFrame or geopandas.GeoDataFrame with a 'year' column</li>
<li>start_year: int, start of the year range (default 1971)</li>
<li>end_year: int, end of the year range (default 2025)</li>
</ul>
      <ul>
<li>pruned DataFrame only with rows in the specified year range</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prune_by_year</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">start_year</span><span class="o">=</span><span class="mi">1971</span><span class="p">,</span> <span class="n">end_year</span><span class="o">=</span><span class="mi">2025</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prune a DataFrame to only include rows where &#39;year&#39; is between start_year and end_year (inclusive).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - df: pandas.DataFrame or geopandas.GeoDataFrame with a &#39;year&#39; column</span>
<span class="sd">    - start_year: int, start of the year range (default 1971)</span>
<span class="sd">    - end_year: int, end of the year range (default 2025)</span>

<span class="sd">    Returns:</span>
<span class="sd">    - pruned DataFrame only with rows in the specified year range</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;year&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataFrame must have a &#39;year&#39; column.&quot;</span><span class="p">)</span>

    <span class="n">pruned_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_year</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_year</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">pruned_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="doc doc-heading">
<code class="highlight language-python"><span class="n">rasterize_multiband_gdf_match</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_match" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution.</p>
      <ul>
<li>gdf: GeoDataFrame with polygon geometries and numeric value_columns</li>
<li>value_columns: list of column names to rasterize into bands</li>
<li>bounds: bounding box (minx, miny, maxx, maxy). If None, computed from gdf.</li>
<li>resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</li>
</ul>
      <ul>
<li>3D numpy array (bands, height, width)</li>
<li>affine transform</li>
<li>bounds used for rasterization</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rasterize_multiband_gdf_match</span><span class="p">(</span>
    <span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution.</span>

<span class="sd">    Args:</span>
<span class="sd">    - gdf: GeoDataFrame with polygon geometries and numeric value_columns</span>
<span class="sd">    - value_columns: list of column names to rasterize into bands</span>
<span class="sd">    - bounds: bounding box (minx, miny, maxx, maxy). If None, computed from gdf.</span>
<span class="sd">    - resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - 3D numpy array (bands, height, width)</span>
<span class="sd">    - affine transform</span>
<span class="sd">    - bounds used for rasterization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Calculate bounds if not given</span>
    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>

    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="c1"># Calculate the width and height of the raster</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>

    <span class="c1"># Create the transform based on bounds and resolution</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value_columns</span><span class="p">:</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">])]</span>
        <span class="n">raster</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span>

    <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stacked</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="doc doc-heading">
<code class="highlight language-python"><span class="n">rasterize_multiband_gdf_world</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.rasterize_multiband_gdf_world" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution
covering the entire world.</p>
      <ul>
<li>gdf: GeoDataFrame with polygon geometries and numeric value_columns</li>
<li>value_columns: list of column names to rasterize into bands</li>
<li>resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</li>
</ul>
      <ul>
<li>3D numpy array (bands, height, width)</li>
<li>affine transform</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rasterize_multiband_gdf_world</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">value_columns</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.1666667</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rasterizes multiple value columns of a GeoDataFrame into a multiband raster with a specified resolution</span>
<span class="sd">    covering the entire world.</span>

<span class="sd">    Args:</span>
<span class="sd">    - gdf: GeoDataFrame with polygon geometries and numeric value_columns</span>
<span class="sd">    - value_columns: list of column names to rasterize into bands</span>
<span class="sd">    - resolution: The desired resolution of the raster in degrees (default is 10 minutes = 0.1666667 degrees).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - 3D numpy array (bands, height, width)</span>
<span class="sd">    - affine transform</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the bounds of the entire world</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">90</span>

    <span class="c1"># Calculate the width and height of the raster based on the resolution</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>

    <span class="c1"># Create the transform based on the world bounds and new resolution</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value_columns</span><span class="p">:</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">])]</span>
        <span class="n">raster</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span>
                <span class="n">height</span><span class="p">,</span>
                <span class="n">width</span><span class="p">,</span>
            <span class="p">),</span>  <span class="c1"># Ensure this matches the calculated height and width</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># Fill areas outside the polygons with NaN</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span>

    <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stacked</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.recreate_layer" class="doc doc-heading">
<code class="highlight language-python"><span class="n">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.recreate_layer" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Safely recreate a common ipyleaflet layer from its core properties
to avoid modifying the original object.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>layer</code></td>
        <td><code>ipyleaflet.Layer</code></td>
        <td><p>The map layer to recreate. Supported types include:
- GeoJSON: polygon, line, or point data with style and hover style
- TileLayer: base map tiles</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ipyleaflet.Layer</code></td>
      <td><p>A new instance of the same layer type with identical core properties.
    Modifications to the returned layer will not affect the original layer.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">recreate_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Safely recreate a common ipyleaflet layer from its core properties</span>
<span class="sd">    to avoid modifying the original object.</span>

<span class="sd">    Args:</span>
<span class="sd">        layer (ipyleaflet.Layer):</span>
<span class="sd">            The map layer to recreate. Supported types include:</span>
<span class="sd">            - GeoJSON: polygon, line, or point data with style and hover style</span>
<span class="sd">            - TileLayer: base map tiles</span>

<span class="sd">    Returns:</span>
<span class="sd">        ipyleaflet.Layer:</span>
<span class="sd">            A new instance of the same layer type with identical core properties.</span>
<span class="sd">            Modifications to the returned layer will not affect the original layer.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError:</span>
<span class="sd">            If the layer type is not supported by this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">GeoJSON</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">GeoJSON</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">style</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="n">hover_style</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">hover_style</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="n">name</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">TileLayer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TileLayer</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Layer type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="si">}</span><span class="s2"> not supported in recreate_layer.&quot;</span>
        <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">polygons_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.remove_lakes_and_plot_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Removes lake polygons from range polygons and retains all rows in the original data,
updating the geometry where lakes intersect with polygons.</p>
      <ul>
<li>polygons_gdf: GeoDataFrame of range polygons.</li>
</ul>
      <ul>
<li>Updated GeoDataFrame with lakes removed from intersecting polygons.</li>
</ul>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">remove_lakes_and_plot_gbif</span><span class="p">(</span><span class="n">polygons_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes lake polygons from range polygons and retains all rows in the original data,</span>
<span class="sd">    updating the geometry where lakes intersect with polygons.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - polygons_gdf: GeoDataFrame of range polygons.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - Updated GeoDataFrame with lakes removed from intersecting polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">polygons_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="p">[</span>
        <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">geom_type</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">])</span>
    <span class="p">]</span>

    <span class="c1"># Load lakes GeoDataFrame</span>
    <span class="n">lakes_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/lakes_na.geojson&quot;</span>
    <span class="n">lakes_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">lakes_url</span><span class="p">)</span>

    <span class="c1"># Ensure geometries are valid</span>
    <span class="n">polygons_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="p">[</span><span class="n">polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>
    <span class="n">lakes_gdf</span> <span class="o">=</span> <span class="n">lakes_gdf</span><span class="p">[</span><span class="n">lakes_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_valid</span><span class="p">]</span>

    <span class="c1"># Ensure CRS matches before performing spatial operations</span>
    <span class="k">if</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">lakes_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CRS mismatch! Transforming </span><span class="si">{</span><span class="n">polygons_gdf</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">lakes_gdf</span><span class="o">.</span><span class="n">crs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">polygons_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">lakes_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Add an ID column to identify unique polygons (group points by shared polygons)</span>
    <span class="n">polygons_gdf</span><span class="p">[</span><span class="s2">&quot;unique_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="c1"># Deduplicate the range polygons by geometry and add ID to unique polygons</span>
    <span class="n">unique_gdf</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
    <span class="n">unique_gdf</span><span class="p">[</span><span class="s2">&quot;unique_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_gdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
        <span class="s2">&quot;geometry&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>  <span class="c1"># Assign shared unique IDs</span>

    <span class="c1"># Clip the unique polygons with the lake polygons (difference operation)</span>
    <span class="n">polygons_no_lakes_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">unique_gdf</span><span class="p">,</span> <span class="n">lakes_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;difference&quot;</span><span class="p">)</span>

    <span class="c1"># Merge the modified unique polygons back with the original GeoDataFrame using &#39;unique_id&#39;</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">polygons_no_lakes_gdf</span><span class="p">[[</span><span class="s2">&quot;unique_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;unique_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Now update the geometry column with the new geometries from the modified polygons</span>
    <span class="n">merged_polygons</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_polygons</span><span class="p">[</span><span class="s2">&quot;geometry_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
        <span class="n">merged_polygons</span><span class="p">[</span><span class="s2">&quot;geometry_x&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Drop the temporary columns that were used for merging</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">merged_polygons</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry_y&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry_x&quot;</span><span class="p">,</span> <span class="s2">&quot;unique_id&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Ensure the resulting DataFrame is still a GeoDataFrame</span>
    <span class="n">merged_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">merged_polygons</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="c1"># Set CRS correctly</span>
    <span class="n">merged_polygons</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">polygons_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Return the updated GeoDataFrame</span>
    <span class="k">return</span> <span class="n">merged_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_historic_gbif_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_historic_gbif_csv</span><span class="p">(</span><span class="n">classified_historic</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_historic_gbif_csv" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Save historic GBIF data to a CSV file in the user's Downloads folder.</p>
      <p>classified_historic : pandas.DataFrame or geopandas.GeoDataFrame
    DataFrame containing historic range polygons for a species.
species_name : str
    Name of the species; used to generate the CSV file name.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_historic_gbif_csv</span><span class="p">(</span><span class="n">classified_historic</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save historic GBIF data to a CSV file in the user&#39;s Downloads folder.</span>

<span class="sd">    Args:</span>
<span class="sd">    classified_historic : pandas.DataFrame or geopandas.GeoDataFrame</span>
<span class="sd">        DataFrame containing historic range polygons for a species.</span>
<span class="sd">    species_name : str</span>
<span class="sd">        Name of the species; used to generate the CSV file name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set up paths</span>
    <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
    <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">)</span>

    <span class="c1"># Define the file name</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">species_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_classified_historic.csv&quot;</span>

    <span class="c1"># Save the DataFrame to CSV in the Downloads folder</span>
    <span class="n">classified_historic</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">downloads_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_individual_persistence_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_individual_persistence_csv</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_individual_persistence_csv" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Save individual persistence point data to a CSV file in the user's Downloads folder.</p>
      <p>points : pandas.DataFrame or geopandas.GeoDataFrame
    DataFrame containing individual persistence data for a species. Typically includes columns
    such as persistence probabilities, raster values, and risk deciles.
species_name : str
    Name of the species; used to generate the CSV file name.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_individual_persistence_csv</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save individual persistence point data to a CSV file in the user&#39;s Downloads folder.</span>

<span class="sd">    Args:</span>
<span class="sd">    points : pandas.DataFrame or geopandas.GeoDataFrame</span>
<span class="sd">        DataFrame containing individual persistence data for a species. Typically includes columns</span>
<span class="sd">        such as persistence probabilities, raster values, and risk deciles.</span>
<span class="sd">    species_name : str</span>
<span class="sd">        Name of the species; used to generate the CSV file name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set up paths</span>
    <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
    <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">)</span>

    <span class="c1"># Define the file name</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">species_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_points.csv&quot;</span>

    <span class="c1"># Save the DataFrame to CSV in the Downloads folder</span>
    <span class="n">points</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">downloads_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_modern_gbif_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_modern_gbif_csv</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_modern_gbif_csv" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Save modern GBIF data to a CSV file in the user's Downloads folder.</p>
      <p>classified_modern : pandas.DataFrame or geopandas.GeoDataFrame
    DataFrame containing modern range polygons for a species.
species_name : str
    Name of the species; used to generate the CSV file name.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_modern_gbif_csv</span><span class="p">(</span><span class="n">classified_modern</span><span class="p">,</span> <span class="n">species_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save modern GBIF data to a CSV file in the user&#39;s Downloads folder.</span>

<span class="sd">    Args:</span>
<span class="sd">    classified_modern : pandas.DataFrame or geopandas.GeoDataFrame</span>
<span class="sd">        DataFrame containing modern range polygons for a species.</span>
<span class="sd">    species_name : str</span>
<span class="sd">        Name of the species; used to generate the CSV file name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set up paths</span>
    <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
    <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">)</span>

    <span class="c1"># Define the file name</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">species_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_classified_modern.csv&quot;</span>

    <span class="c1"># Save the DataFrame to CSV in the Downloads folder</span>
    <span class="n">classified_modern</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">downloads_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_raster_to_downloads_global" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_raster_to_downloads_global</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_raster_to_downloads_global" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Saves a NumPy raster array as a GeoTIFF to the user's Downloads folder.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>array</code></td>
        <td><code>ndarray</code></td>
        <td><p>The raster data to save.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bounds</code></td>
        <td><code>tuple</code></td>
        <td><p>Bounding box in the format (minx, miny, maxx, maxy).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species</code></td>
        <td><code>str</code></td>
        <td><p>The species name to use in the output filename.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_raster_to_downloads_global</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves a NumPy raster array as a GeoTIFF to the user&#39;s Downloads folder.</span>

<span class="sd">    Args:</span>
<span class="sd">        array (ndarray): The raster data to save.</span>
<span class="sd">        bounds (tuple): Bounding box in the format (minx, miny, maxx, maxy).</span>
<span class="sd">        species (str): The species name to use in the output filename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Clean filename</span>
        <span class="n">clean_species</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">clean_species</span><span class="si">}</span><span class="s2">_persistence_raster_global.tif&quot;</span>

        <span class="c1"># Determine Downloads path</span>
        <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Generate raster transform</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span>
            <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Write to GeoTIFF</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">downloads_path</span><span class="p">,</span>
            <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># print(f&quot;Raster successfully saved to: {downloads_path}&quot;)</span>
        <span class="k">return</span> <span class="n">downloads_path</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving raster: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_raster_to_downloads_range" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_raster_to_downloads_range</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_raster_to_downloads_range" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Saves a NumPy raster array as a GeoTIFF to the user's Downloads folder.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>array</code></td>
        <td><code>ndarray</code></td>
        <td><p>The raster data to save.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bounds</code></td>
        <td><code>tuple</code></td>
        <td><p>Bounding box in the format (minx, miny, maxx, maxy).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>species</code></td>
        <td><code>str</code></td>
        <td><p>The species name to use in the output filename.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_raster_to_downloads_range</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">species</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves a NumPy raster array as a GeoTIFF to the user&#39;s Downloads folder.</span>

<span class="sd">    Args:</span>
<span class="sd">        array (ndarray): The raster data to save.</span>
<span class="sd">        bounds (tuple): Bounding box in the format (minx, miny, maxx, maxy).</span>
<span class="sd">        species (str): The species name to use in the output filename.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Clean filename</span>
        <span class="n">clean_species</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">clean_species</span><span class="si">}</span><span class="s2">_persistence_raster.tif&quot;</span>

        <span class="c1"># Determine Downloads path</span>
        <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Generate raster transform</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span>
            <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Write to GeoTIFF</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">downloads_path</span><span class="p">,</span>
            <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># print(f&quot;Raster successfully saved to: {downloads_path}&quot;)</span>
        <span class="k">return</span> <span class="n">downloads_path</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving raster: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.save_results_as_csv" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save_results_as_csv</span><span class="p">(</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">final_result</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">total_clim_result</span><span class="p">,</span> <span class="n">category_clim_result</span><span class="p">,</span> <span class="n">species_name</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.save_results_as_csv" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Save multiple species-level and category-level analysis results to CSV files.</p>
<p>The function standardizes category column names, merges relevant dataframes, and saves:
1. Species-level range patterns as 'range_pattern.csv'.
2. Category-level summaries as 'category_summary.csv'.</p>
      <p>northward_rate_df : pandas.DataFrame
    DataFrame containing northward movement rates per category.
final_result : pandas.DataFrame
    DataFrame containing overall species-level analysis results.
change : pandas.DataFrame
    DataFrame with change metrics per category.
total_clim_result : pandas.DataFrame
    Species-level climate-related summary statistics.
category_clim_result : pandas.DataFrame
    Category-level climate-related summary statistics.
species_name : str
    Name of the species; used to create the results folder name.</p>

        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_results_as_csv</span><span class="p">(</span>
    <span class="n">northward_rate_df</span><span class="p">,</span>
    <span class="n">final_result</span><span class="p">,</span>
    <span class="n">change</span><span class="p">,</span>
    <span class="n">total_clim_result</span><span class="p">,</span>
    <span class="n">category_clim_result</span><span class="p">,</span>
    <span class="n">species_name</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save multiple species-level and category-level analysis results to CSV files.</span>

<span class="sd">    The function standardizes category column names, merges relevant dataframes, and saves:</span>
<span class="sd">    1. Species-level range patterns as &#39;range_pattern.csv&#39;.</span>
<span class="sd">    2. Category-level summaries as &#39;category_summary.csv&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">    northward_rate_df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing northward movement rates per category.</span>
<span class="sd">    final_result : pandas.DataFrame</span>
<span class="sd">        DataFrame containing overall species-level analysis results.</span>
<span class="sd">    change : pandas.DataFrame</span>
<span class="sd">        DataFrame with change metrics per category.</span>
<span class="sd">    total_clim_result : pandas.DataFrame</span>
<span class="sd">        Species-level climate-related summary statistics.</span>
<span class="sd">    category_clim_result : pandas.DataFrame</span>
<span class="sd">        Category-level climate-related summary statistics.</span>
<span class="sd">    species_name : str</span>
<span class="sd">        Name of the species; used to create the results folder name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set up paths</span>
    <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
    <span class="n">downloads_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home_dir</span><span class="p">,</span> <span class="s2">&quot;Downloads&quot;</span><span class="p">)</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">_%H%M%S&quot;</span><span class="p">)</span>
    <span class="n">folder_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">species_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_Results_</span><span class="si">{</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">downloads_path</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">)</span>

    <span class="c1"># Create results folder</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Standardize the column name to &#39;category&#39; and normalize categories to title case</span>
    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="p">[</span><span class="n">northward_rate_df</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">category_clim_result</span><span class="p">]:</span>
        <span class="k">if</span> <span class="s2">&quot;Category&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Category&quot;</span><span class="p">:</span> <span class="s2">&quot;category&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;category&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>

    <span class="c1"># Merge the three DataFrames by category</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">northward_rate_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">change</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">category_clim_result</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Drop duplicate species columns (if they exist)</span>
    <span class="k">if</span> <span class="s2">&quot;species_x&quot;</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;species_y&quot;</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">merged_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;species_x&quot;</span><span class="p">,</span> <span class="s2">&quot;species_y&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">merged_single</span> <span class="o">=</span> <span class="n">final_result</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">total_clim_result</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;species&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>

    <span class="c1"># Save final_result as range_pattern.csv</span>
    <span class="n">merged_single</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">results_folder</span><span class="p">,</span> <span class="s2">&quot;range_pattern.csv&quot;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Save the merged DataFrame (category_summary.csv)</span>
    <span class="n">merged_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">results_folder</span><span class="p">,</span> <span class="s2">&quot;category_summary.csv&quot;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.summarize_polygons_for_point_plot" class="doc doc-heading">
<code class="highlight language-python"><span class="n">summarize_polygons_for_point_plot</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.summarize_polygons_for_point_plot" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Summarizes number of points per unique polygon (geometry_id), retaining one row per polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>A DataFrame where each row represents a point with associated polygon metadata.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gpd.GeoDataFrame</code></td>
      <td><p>A summarized GeoDataFrame with one row per unique polygon and geometry set.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">summarize_polygons_for_point_plot</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summarizes number of points per unique polygon (geometry_id), retaining one row per polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): A DataFrame where each row represents a point with associated polygon metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gpd.GeoDataFrame: A summarized GeoDataFrame with one row per unique polygon and geometry set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Group by geometry_id and aggregate</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_vals&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;n_points&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">summary_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.summarize_polygons_with_points" class="doc doc-heading">
<code class="highlight language-python"><span class="n">summarize_polygons_with_points</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.summarize_polygons_with_points" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Summarizes number of points per unique polygon (geometry_id), retaining one row per polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>A DataFrame where each row represents a point with associated polygon metadata.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gpd.GeoDataFrame</code></td>
      <td><p>A summarized GeoDataFrame with one row per unique polygon and geometry set.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">summarize_polygons_with_points</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summarizes number of points per unique polygon (geometry_id), retaining one row per polygon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df (pd.DataFrame): A DataFrame where each row represents a point with associated polygon metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gpd.GeoDataFrame: A summarized GeoDataFrame with one row per unique polygon and geometry set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Group by geometry_id and aggregate</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;geometry_id&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">agg</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
                <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
                <span class="s2">&quot;AREA&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cluster&quot;</span><span class="p">:</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
                <span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;point_geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;n_points&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">summary_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.update_polygon_categories" class="doc doc-heading">
<code class="highlight language-python"><span class="n">update_polygon_categories</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">,</span> <span class="n">classified_polygons</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.update_polygon_categories" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Updates categories of polygons that overlap with island-state polygons by
assigning them the category of the closest 'largest' polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>largest_polygons</code></td>
        <td><code>GeoDataFrame or GeoSeries</code></td>
        <td><p>Polygons representing the largest
clusters, with a 'category' column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>classified_polygons</code></td>
        <td><code>GeoDataFrame or GeoSeries</code></td>
        <td><p>Polygons with initial categories
that may need updating if they overlap island-state polygons.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>geopandas.GeoDataFrame</code></td>
      <td><p>Updated classified polygons with corrected 'category'
values for polygons overlapping island states. CRS is EPSG:4326.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_polygon_categories</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">,</span> <span class="n">classified_polygons</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates categories of polygons that overlap with island-state polygons by</span>
<span class="sd">    assigning them the category of the closest &#39;largest&#39; polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        largest_polygons (GeoDataFrame or GeoSeries): Polygons representing the largest</span>
<span class="sd">            clusters, with a &#39;category&#39; column.</span>
<span class="sd">        classified_polygons (GeoDataFrame or GeoSeries): Polygons with initial categories</span>
<span class="sd">            that may need updating if they overlap island-state polygons.</span>

<span class="sd">    Returns:</span>
<span class="sd">        geopandas.GeoDataFrame: Updated classified polygons with corrected &#39;category&#39;</span>
<span class="sd">        values for polygons overlapping island states. CRS is EPSG:4326.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>

    <span class="c1"># Load island states data</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:3395&quot;</span><span class="p">)</span>

    <span class="c1"># Convert inputs to GeoDataFrames</span>
    <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">largest_polygons</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:3395&quot;</span><span class="p">)</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">classified_polygons</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:3395&quot;</span><span class="p">)</span>

    <span class="c1"># Add category info to largest polygons</span>
    <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
        <span class="n">largest_polygons_gdf</span><span class="p">,</span>
        <span class="n">classified_polygons</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">]],</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Find polygons from classified set that overlap with island states</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
        <span class="n">classified_polygons_gdf</span><span class="p">,</span> <span class="n">island_states_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Clean up overlapping polygons</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;overlapping_index&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">overlapping_polygons_new</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="c1"># Check for empty overlaps before proceeding</span>
    <span class="k">if</span> <span class="n">overlapping_polygons_new</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No overlapping polygons found — returning original classifications.&quot;</span><span class="p">)</span>
        <span class="n">classified_polygons</span> <span class="o">=</span> <span class="n">classified_polygons</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4236&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">classified_polygons</span>

    <span class="c1"># Compute centroids for distance calculation</span>
    <span class="n">overlapping_polygons_new</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlapping_polygons_new</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>

    <span class="c1"># Extract coordinates of centroids</span>
    <span class="n">overlapping_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">overlapping_polygons_new</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Compute distance matrix and find closest matches</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">overlapping_centroids</span><span class="p">,</span> <span class="n">largest_centroids</span><span class="p">)</span>
    <span class="n">closest_indices</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Assign categories from closest large polygons to overlapping polygons</span>
    <span class="n">overlapping_polygons_new</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">closest_indices</span><span class="p">][</span>
        <span class="s2">&quot;category&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Update the classified polygons with new categories</span>
    <span class="n">updated_classified_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">overlapping_polygons_new</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">overlapping_polygons_new</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Convert back to EPSG:4326 explicitly</span>
    <span class="n">updated_classified_polygons</span> <span class="o">=</span> <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>

    <span class="c1"># Ensure the CRS is explicitly set to 4326</span>
    <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_classified_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.update_polygon_categories_gbif" class="doc doc-heading">
<code class="highlight language-python"><span class="n">update_polygon_categories_gbif</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Updates polygon categories based on overlaps with island states and closest large polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>largest_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of largest polygons with 'geometry' and 'category'.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>classified_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>Output from classify_range_edges_gbif with 'geom_id' and 'category'.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>classified_polygons_gdf with updated 'category' values for overlapping polygons.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_polygon_categories_gbif</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates polygon categories based on overlaps with island states and closest large polygon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        largest_polygons_gdf (GeoDataFrame): GeoDataFrame of largest polygons with &#39;geometry&#39; and &#39;category&#39;.</span>
<span class="sd">        classified_polygons_gdf (GeoDataFrame): Output from classify_range_edges_gbif with &#39;geom_id&#39; and &#39;category&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: classified_polygons_gdf with updated &#39;category&#39; values for overlapping polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>

    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="c1"># Ensure all CRS match</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">or</span> <span class="s2">&quot;EPSG:3395&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Convert list of Series to DataFrame</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">)</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">largest_polygons_gdf</span><span class="p">,</span>
            <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="n">unique_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polygons</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Merge back geom_id to the full dataframe</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">unique_polygons</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Spatial join to find overlapping polygons with island states</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
        <span class="n">classified_polygons_gdf</span><span class="p">,</span> <span class="n">island_states_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span>
    <span class="p">)</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">)</span>

    <span class="c1"># Compute centroids for distance matching</span>
    <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>

    <span class="c1"># Extract coordinates</span>
    <span class="n">overlapping_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Compute distances and find nearest large polygon</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">overlapping_centroids</span><span class="p">,</span> <span class="n">largest_centroids</span><span class="p">)</span>
    <span class="n">closest_indices</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Assign nearest large polygon&#39;s category</span>
    <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">closest_indices</span><span class="p">][</span>
        <span class="s2">&quot;category&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Update classified polygons using &#39;geom_id&#39;</span>
    <span class="n">updated_classified_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">update_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">updated_classified_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">update_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_classified_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 id="ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="doc doc-heading">
<code class="highlight language-python"><span class="n">update_polygon_categories_gbif_test</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">)</span></code>


<a href="#ecospat.stand_alone_functions.update_polygon_categories_gbif_test" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Updates polygon categories based on overlaps with island states and nearest large polygon.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>largest_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of largest polygons with 'geometry' and 'category'.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>classified_polygons_gdf</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of smaller polygons (one row per point) with potential duplicate geometries.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GeoDataFrame</code></td>
      <td><p>classified_polygons_gdf with updated 'category' values for overlapping polygons.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>ecospat/stand_alone_functions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_polygon_categories_gbif_test</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">classified_polygons_gdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates polygon categories based on overlaps with island states and nearest large polygon.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        largest_polygons_gdf (GeoDataFrame): GeoDataFrame of largest polygons with &#39;geometry&#39; and &#39;category&#39;.</span>
<span class="sd">        classified_polygons_gdf (GeoDataFrame): GeoDataFrame of smaller polygons (one row per point) with potential duplicate geometries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        GeoDataFrame: classified_polygons_gdf with updated &#39;category&#39; values for overlapping polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>

    <span class="c1"># Load island states</span>
    <span class="n">island_states_url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/anytko/biospat_large_files/main/island_states.geojson&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">island_states_url</span><span class="p">)</span>

    <span class="c1"># Ensure all CRS match</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">or</span> <span class="s2">&quot;EPSG:3395&quot;</span>
    <span class="n">island_states_gdf</span> <span class="o">=</span> <span class="n">island_states_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">largest_polygons_gdf</span><span class="p">)</span>
        <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">largest_polygons_gdf</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span>
        <span class="p">)</span>

    <span class="n">largest_polygons_gdf</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;core&quot;</span>

    <span class="n">largest_polygons_gdf</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Assign unique ID per unique geometry</span>
    <span class="n">unique_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unique_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_polygons</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Merge geom_id back to full dataframe</span>
    <span class="n">classified_polygons_gdf</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">unique_polygons</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;geom_id&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Find overlaps with island states</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span>
        <span class="n">classified_polygons_gdf</span><span class="p">,</span> <span class="n">island_states_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span>
    <span class="p">)</span>
    <span class="n">overlapping_polygons</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;geom_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Compute centroids</span>
    <span class="n">overlapping_centroids</span> <span class="o">=</span> <span class="n">overlapping_polygons</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">largest_centroids</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">centroid</span>

    <span class="c1"># Compute distances between centroids</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span>
        <span class="n">overlapping_centroids</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="n">largest_centroids</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">closest_indices</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Assign categories from nearest large polygon</span>
    <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_polygons_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">closest_indices</span><span class="p">][</span>
        <span class="s2">&quot;category&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Update the categories in the original dataframe</span>
    <span class="n">update_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">overlapping_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">updated_classified_polygons</span> <span class="o">=</span> <span class="n">classified_polygons_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">updated_classified_polygons</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_classified_polygons</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">update_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_classified_polygons</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago" title="May 13, 2025 21:56:25 UTC"><span class="timeago" datetime="2025-05-13T21:56:25+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="May 13, 2025 21:56:25 UTC">2025-05-13</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago" title="May 13, 2025 21:56:25 UTC"><span class="timeago" datetime="2025-05-13T21:56:25+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="May 13, 2025 21:56:25 UTC">2025-05-13</span>
  </span>

    
    
    
  </aside>





                

              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 - 2025 Alivia Nytko
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.tracking", "navigation.top", "search.highlight", "search.share"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="../js/timeago.min.js"></script>
      
        <script src="../js/timeago_mkdocs_material.js"></script>
      
    
  </body>
</html>