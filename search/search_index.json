{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ecospat","text":"<p>A python package to o characterize the range dynamics and shifts of North American tree species.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://anytko.github.io/ecospat</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Maps and identifies edges of historical and contemporary ranges for over 600 tree species.</li> <li>Generates a persistence raster that can be downloaded and used in further analyses.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#ecospat.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>ecospat/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/anytko/ecospat/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>ecospat could always use more documentation, whether as part of the official ecospat docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/anytko/ecospat/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up ecospat for local development.</p> <ol> <li> <p>Fork the ecospat repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/ecospat.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv ecospat\n$ cd ecospat/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 ecospat tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/anytko/ecospat/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"ecospat/","title":"ecospat module","text":"<p>This module provides a custom Map class that extends ipyleaflet.Map to visualize range edge dynamics.</p>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map","title":"<code> GBIF_Map            (HistoricalMap)         </code>","text":"Source code in <code>ecospat/ecospat.py</code> <pre><code>class GBIF_Map(HistoricalMap):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_gbif_polygons(self, polygons_gdf):\n        \"\"\"Add polygons from a GeoDataFrame to the ipyleaflet map.\"\"\"\n        if not isinstance(polygons_gdf, gpd.GeoDataFrame):\n            raise TypeError(\"Input must be a GeoDataFrame.\")\n        if \"geometry\" not in polygons_gdf:\n            raise ValueError(\"GeoDataFrame must have a 'geometry' column.\")\n\n        gbif_polygons = GeoData(\n            geo_dataframe=polygons_gdf,\n            style={\"color\": \"blue\", \"opacity\": 1, \"weight\": 2, \"fillOpacity\": 0.4},\n        )\n\n        self.add_layer(gbif_polygons)\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n        Available basemaps:\n            - \"OpenTopoMap\": A topographic map.\n            - \"OpenStreetMap.Mapnik\": A standard street map.\n            - \"Esri.WorldImagery\": Satellite imagery.\n            - \"Esri.WorldTerrain\": Terrain map from Esri.\n            - \"Esri.WorldStreetMap\": Street map from Esri.\n            - \"CartoDB.Positron\": A light, minimalist map style.\n            - \"CartoDB.DarkMatter\": A dark-themed map style.\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n        Params:\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a basemap from the provided options.\n            - The close button removes the widget from the map.\n\n        Event Handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes and removes the widget from the map.\n            - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n        Returns:\n            None\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"Esri.WorldTerrain\",\n                \"Esri.WorldStreetMap\",\n                \"CartoDB.DarkMatter\",\n                \"CartoDB.Positron\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to add.\n            position (str, optional): Position of the widget. Defaults to \"topright\".\n            **kwargs: Additional keyword arguments for the WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_shp_from_url(self, url, **kwargs):\n        \"\"\"Adds a shapefile from a URL to the map.\n        Adds a shapefile from a URL to the map.\n\n        This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n        in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n        then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n        the CRS to be EPSG:4326 (WGS84).\n\n        Args:\n            url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                    the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n            **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                    configuring the GeoJSON layer on the map.\n        \"\"\"\n        try:\n            base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n                \"blob/\", \"\"\n            )\n            shp_url = base_url + \".shp\"\n            shx_url = base_url + \".shx\"\n            dbf_url = base_url + \".dbf\"\n\n            temp_dir = tempfile.mkdtemp()\n\n            shp_file = requests.get(shp_url).content\n            shx_file = requests.get(shx_url).content\n            dbf_file = requests.get(dbf_url).content\n\n            with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n                f.write(shp_file)\n            with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n                f.write(shx_file)\n            with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n                f.write(dbf_file)\n\n            gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n            geojson = gdf.__geo_interface__\n\n            self.add_geojson(geojson, **kwargs)\n\n            shutil.rmtree(temp_dir)\n\n        except Exception:\n            pass\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> <p>Available basemaps:     - \"OpenTopoMap\": A topographic map.     - \"OpenStreetMap.Mapnik\": A standard street map.     - \"Esri.WorldImagery\": Satellite imagery.     - \"Esri.WorldTerrain\": Terrain map from Esri.     - \"Esri.WorldStreetMap\": Street map from Esri.     - \"CartoDB.Positron\": A light, minimalist map style.     - \"CartoDB.DarkMatter\": A dark-themed map style.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n    Available basemaps:\n        - \"OpenTopoMap\": A topographic map.\n        - \"OpenStreetMap.Mapnik\": A standard street map.\n        - \"Esri.WorldImagery\": Satellite imagery.\n        - \"Esri.WorldTerrain\": Terrain map from Esri.\n        - \"Esri.WorldStreetMap\": Street map from Esri.\n        - \"CartoDB.Positron\": A light, minimalist map style.\n        - \"CartoDB.DarkMatter\": A dark-themed map style.\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for dynamically changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a basemap from the provided options.</li> <li>The close button removes the widget from the map.</li> </ul> <p>Event Handlers:     - <code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.     - <code>on_button_click</code>: Closes and removes the widget from the map.     - <code>on_dropdown_change</code>: Updates the map's basemap when a new option is selected.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n    Params:\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a basemap from the provided options.\n        - The close button removes the widget from the map.\n\n    Event Handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes and removes the widget from the map.\n        - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n    Returns:\n        None\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.WorldTerrain\",\n            \"Esri.WorldStreetMap\",\n            \"CartoDB.DarkMatter\",\n            \"CartoDB.Positron\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_gbif_polygons","title":"<code>add_gbif_polygons(self, polygons_gdf)</code>","text":"<p>Add polygons from a GeoDataFrame to the ipyleaflet map.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_gbif_polygons(self, polygons_gdf):\n    \"\"\"Add polygons from a GeoDataFrame to the ipyleaflet map.\"\"\"\n    if not isinstance(polygons_gdf, gpd.GeoDataFrame):\n        raise TypeError(\"Input must be a GeoDataFrame.\")\n    if \"geometry\" not in polygons_gdf:\n        raise ValueError(\"GeoDataFrame must have a 'geometry' column.\")\n\n    gbif_polygons = GeoData(\n        geo_dataframe=polygons_gdf,\n        style={\"color\": \"blue\", \"opacity\": 1, \"weight\": 2, \"fillOpacity\": 0.4},\n    )\n\n    self.add_layer(gbif_polygons)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_shp_from_url","title":"<code>add_shp_from_url(self, url, **kwargs)</code>","text":"<p>Adds a shapefile from a URL to the map. Adds a shapefile from a URL to the map.</p> <p>This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes the CRS to be EPSG:4326 (WGS84).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the shapefile's location. The URL should be a raw GitHub link to     the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>add_geojson</code> method for styling and     configuring the GeoJSON layer on the map.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp_from_url(self, url, **kwargs):\n    \"\"\"Adds a shapefile from a URL to the map.\n    Adds a shapefile from a URL to the map.\n\n    This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n    in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n    then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n    the CRS to be EPSG:4326 (WGS84).\n\n    Args:\n        url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n        **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                configuring the GeoJSON layer on the map.\n    \"\"\"\n    try:\n        base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n        shp_url = base_url + \".shp\"\n        shx_url = base_url + \".shx\"\n        dbf_url = base_url + \".dbf\"\n\n        temp_dir = tempfile.mkdtemp()\n\n        shp_file = requests.get(shp_url).content\n        shx_file = requests.get(shx_url).content\n        dbf_file = requests.get(dbf_url).content\n\n        with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n            f.write(shp_file)\n        with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n            f.write(shx_file)\n        with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n            f.write(dbf_file)\n\n        gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(geojson, **kwargs)\n\n        shutil.rmtree(temp_dir)\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_widget","title":"<code>add_widget(self, widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>Position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for the WidgetControl.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to add.\n        position (str, optional): Position of the widget. Defaults to \"topright\".\n        **kwargs: Additional keyword arguments for the WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap","title":"<code> HistoricalMap            (Map)         </code>","text":"Source code in <code>ecospat/ecospat.py</code> <pre><code>class HistoricalMap(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n        self.github_historic_url = (\n            \"https://raw.githubusercontent.com/wpetry/USTreeAtlas/main/geojson\"\n        )\n        self.github_state_url = \"https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/10m_cultural\"\n        self.gdfs = {}\n        self.references = REFERENCES\n\n    def shorten_name(self, species_name):\n        \"\"\"Helper to shorten the species name.\"\"\"\n        return (species_name.split()[0][:4] + species_name.split()[1][:4]).lower()\n\n    def load_historic_data(self, species_name):\n        # Create the short name (first 4 letters of each word, lowercase)\n        short_name = self.shorten_name(species_name)\n\n        # Build the URL\n        geojson_url = f\"{self.github_historic_url}/{short_name}.geojson\"\n\n        try:\n            # Download the GeoJSON file\n            response = requests.get(geojson_url)\n            response.raise_for_status()\n\n            # Read it into a GeoDataFrame\n            species_range = gpd.read_file(BytesIO(response.content))\n\n            # Reproject to WGS84\n            species_range = species_range.to_crs(epsg=4326)\n\n            # Save it internally\n            self.gdfs[short_name] = species_range\n\n            # No prints, no plots - clean loading!\n\n        except Exception as e:\n            print(f\"Error loading {geojson_url}: {e}\")\n\n    def remove_lakes(self, polygons_gdf):\n        \"\"\"\n        Removes lakes from range polygons and returns the resulting GeoDataFrame.\n        All operations in EPSG:3395 for consistency.\n        \"\"\"\n\n        lakes_url = \"https://raw.githubusercontent.com/anytko/biospat_large_files/main/lakes_na.geojson\"\n\n        lakes_gdf = gpd.read_file(lakes_url)\n\n        # Ensure valid geometries\n        polygons_gdf = polygons_gdf[polygons_gdf.geometry.is_valid]\n        lakes_gdf = lakes_gdf[lakes_gdf.geometry.is_valid]\n\n        # Force both to have a CRS if missing\n        if polygons_gdf.crs is None:\n            polygons_gdf = polygons_gdf.set_crs(\"EPSG:4326\")\n        if lakes_gdf.crs is None:\n            lakes_gdf = lakes_gdf.set_crs(\"EPSG:4326\")\n\n        # Reproject to EPSG:3395 for spatial ops\n        polygons_proj = polygons_gdf.to_crs(epsg=3395)\n        lakes_proj = lakes_gdf.to_crs(epsg=3395)\n\n        # Perform spatial difference\n        polygons_no_lakes_proj = gpd.overlay(\n            polygons_proj, lakes_proj, how=\"difference\"\n        )\n\n        # Remove empty geometries\n        polygons_no_lakes_proj = polygons_no_lakes_proj[\n            ~polygons_no_lakes_proj.geometry.is_empty\n        ]\n\n        # Stay in EPSG:3395 (no reprojecting back to 4326)\n        return polygons_no_lakes_proj\n\n    def load_states(self):\n        # URLs for the shapefile components (shp, shx, dbf)\n        shp_url = f\"{self.github_state_url}/ne_10m_admin_1_states_provinces.shp\"\n        shx_url = f\"{self.github_state_url}/ne_10m_admin_1_states_provinces.shx\"\n        dbf_url = f\"{self.github_state_url}/ne_10m_admin_1_states_provinces.dbf\"\n\n        try:\n            # Download all components of the shapefile\n            shp_response = requests.get(shp_url)\n            shx_response = requests.get(shx_url)\n            dbf_response = requests.get(dbf_url)\n\n            shp_response.raise_for_status()\n            shx_response.raise_for_status()\n            dbf_response.raise_for_status()\n\n            # Create a temporary directory to store the shapefile components in memory\n            with open(\"/tmp/ne_10m_admin_1_states_provinces.shp\", \"wb\") as shp_file:\n                shp_file.write(shp_response.content)\n            with open(\"/tmp/ne_10m_admin_1_states_provinces.shx\", \"wb\") as shx_file:\n                shx_file.write(shx_response.content)\n            with open(\"/tmp/ne_10m_admin_1_states_provinces.dbf\", \"wb\") as dbf_file:\n                dbf_file.write(dbf_response.content)\n\n            # Now load the shapefile using geopandas\n            state_gdf = gpd.read_file(\"/tmp/ne_10m_admin_1_states_provinces.shp\")\n\n            # Store it in the class as an attribute\n            self.states = state_gdf\n\n            print(\"Lakes data loaded successfully\")\n\n        except Exception as e:\n            print(f\"Error loading lakes shapefile: {e}\")\n\n    def get_historic_date(self, species_name):\n        # Helper function to easily fetch the reference\n        short_name = (species_name.split()[0][:4] + species_name.split()[1][:4]).lower()\n        return self.references.get(short_name, \"Reference not found\")\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n        Available basemaps:\n            - \"OpenTopoMap\": A topographic map.\n            - \"OpenStreetMap.Mapnik\": A standard street map.\n            - \"Esri.WorldImagery\": Satellite imagery.\n            - \"Esri.WorldTerrain\": Terrain map from Esri.\n            - \"Esri.WorldStreetMap\": Street map from Esri.\n            - \"CartoDB.Positron\": A light, minimalist map style.\n            - \"CartoDB.DarkMatter\": A dark-themed map style.\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n        Params:\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a basemap from the provided options.\n            - The close button removes the widget from the map.\n\n        Event Handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes and removes the widget from the map.\n            - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n        Returns:\n            None\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"Esri.WorldTerrain\",\n                \"Esri.WorldStreetMap\",\n                \"CartoDB.DarkMatter\",\n                \"CartoDB.Positron\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to add.\n            position (str, optional): Position of the widget. Defaults to \"topright\".\n            **kwargs: Additional keyword arguments for the WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_shp_from_url(self, url, **kwargs):\n        \"\"\"Adds a shapefile from a URL to the map.\n        Adds a shapefile from a URL to the map.\n\n        This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n        in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n        then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n        the CRS to be EPSG:4326 (WGS84).\n\n        Args:\n            url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                    the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n            **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                    configuring the GeoJSON layer on the map.\n        \"\"\"\n        try:\n            base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n                \"blob/\", \"\"\n            )\n            shp_url = base_url + \".shp\"\n            shx_url = base_url + \".shx\"\n            dbf_url = base_url + \".dbf\"\n\n            temp_dir = tempfile.mkdtemp()\n\n            shp_file = requests.get(shp_url).content\n            shx_file = requests.get(shx_url).content\n            dbf_file = requests.get(dbf_url).content\n\n            with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n                f.write(shp_file)\n            with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n                f.write(shx_file)\n            with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n                f.write(dbf_file)\n\n            gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n            geojson = gdf.__geo_interface__\n\n            self.add_geojson(geojson, **kwargs)\n\n            shutil.rmtree(temp_dir)\n\n        except Exception:\n            pass\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> <p>Available basemaps:     - \"OpenTopoMap\": A topographic map.     - \"OpenStreetMap.Mapnik\": A standard street map.     - \"Esri.WorldImagery\": Satellite imagery.     - \"Esri.WorldTerrain\": Terrain map from Esri.     - \"Esri.WorldStreetMap\": Street map from Esri.     - \"CartoDB.Positron\": A light, minimalist map style.     - \"CartoDB.DarkMatter\": A dark-themed map style.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n    Available basemaps:\n        - \"OpenTopoMap\": A topographic map.\n        - \"OpenStreetMap.Mapnik\": A standard street map.\n        - \"Esri.WorldImagery\": Satellite imagery.\n        - \"Esri.WorldTerrain\": Terrain map from Esri.\n        - \"Esri.WorldStreetMap\": Street map from Esri.\n        - \"CartoDB.Positron\": A light, minimalist map style.\n        - \"CartoDB.DarkMatter\": A dark-themed map style.\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for dynamically changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a basemap from the provided options.</li> <li>The close button removes the widget from the map.</li> </ul> <p>Event Handlers:     - <code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.     - <code>on_button_click</code>: Closes and removes the widget from the map.     - <code>on_dropdown_change</code>: Updates the map's basemap when a new option is selected.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n    Params:\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a basemap from the provided options.\n        - The close button removes the widget from the map.\n\n    Event Handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes and removes the widget from the map.\n        - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n    Returns:\n        None\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.WorldTerrain\",\n            \"Esri.WorldStreetMap\",\n            \"CartoDB.DarkMatter\",\n            \"CartoDB.Positron\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_shp_from_url","title":"<code>add_shp_from_url(self, url, **kwargs)</code>","text":"<p>Adds a shapefile from a URL to the map. Adds a shapefile from a URL to the map.</p> <p>This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes the CRS to be EPSG:4326 (WGS84).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the shapefile's location. The URL should be a raw GitHub link to     the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>add_geojson</code> method for styling and     configuring the GeoJSON layer on the map.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp_from_url(self, url, **kwargs):\n    \"\"\"Adds a shapefile from a URL to the map.\n    Adds a shapefile from a URL to the map.\n\n    This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n    in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n    then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n    the CRS to be EPSG:4326 (WGS84).\n\n    Args:\n        url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n        **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                configuring the GeoJSON layer on the map.\n    \"\"\"\n    try:\n        base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n        shp_url = base_url + \".shp\"\n        shx_url = base_url + \".shx\"\n        dbf_url = base_url + \".dbf\"\n\n        temp_dir = tempfile.mkdtemp()\n\n        shp_file = requests.get(shp_url).content\n        shx_file = requests.get(shx_url).content\n        dbf_file = requests.get(dbf_url).content\n\n        with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n            f.write(shp_file)\n        with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n            f.write(shx_file)\n        with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n            f.write(dbf_file)\n\n        gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(geojson, **kwargs)\n\n        shutil.rmtree(temp_dir)\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_widget","title":"<code>add_widget(self, widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>Position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for the WidgetControl.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to add.\n        position (str, optional): Position of the widget. Defaults to \"topright\".\n        **kwargs: Additional keyword arguments for the WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.remove_lakes","title":"<code>remove_lakes(self, polygons_gdf)</code>","text":"<p>Removes lakes from range polygons and returns the resulting GeoDataFrame. All operations in EPSG:3395 for consistency.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def remove_lakes(self, polygons_gdf):\n    \"\"\"\n    Removes lakes from range polygons and returns the resulting GeoDataFrame.\n    All operations in EPSG:3395 for consistency.\n    \"\"\"\n\n    lakes_url = \"https://raw.githubusercontent.com/anytko/biospat_large_files/main/lakes_na.geojson\"\n\n    lakes_gdf = gpd.read_file(lakes_url)\n\n    # Ensure valid geometries\n    polygons_gdf = polygons_gdf[polygons_gdf.geometry.is_valid]\n    lakes_gdf = lakes_gdf[lakes_gdf.geometry.is_valid]\n\n    # Force both to have a CRS if missing\n    if polygons_gdf.crs is None:\n        polygons_gdf = polygons_gdf.set_crs(\"EPSG:4326\")\n    if lakes_gdf.crs is None:\n        lakes_gdf = lakes_gdf.set_crs(\"EPSG:4326\")\n\n    # Reproject to EPSG:3395 for spatial ops\n    polygons_proj = polygons_gdf.to_crs(epsg=3395)\n    lakes_proj = lakes_gdf.to_crs(epsg=3395)\n\n    # Perform spatial difference\n    polygons_no_lakes_proj = gpd.overlay(\n        polygons_proj, lakes_proj, how=\"difference\"\n    )\n\n    # Remove empty geometries\n    polygons_no_lakes_proj = polygons_no_lakes_proj[\n        ~polygons_no_lakes_proj.geometry.is_empty\n    ]\n\n    # Stay in EPSG:3395 (no reprojecting back to 4326)\n    return polygons_no_lakes_proj\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.shorten_name","title":"<code>shorten_name(self, species_name)</code>","text":"<p>Helper to shorten the species name.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def shorten_name(self, species_name):\n    \"\"\"Helper to shorten the species name.\"\"\"\n    return (species_name.split()[0][:4] + species_name.split()[1][:4]).lower()\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliummap/","title":"folium_mapping module","text":"<p>This module provides a custom Map class that extends folium.Map</p>"},{"location":"foliummap/#ecospat.foliummap.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that extends folium.Map.</p> Source code in <code>ecospat/foliummap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"A custom Map class that extends folium.Map.\"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, tiles=\"OpenStreetMap\", **kwargs):\n        \"\"\"Initializes the Map object.\n\n        Args:\n            center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n            zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n            tiles (str, optional): The tile layer to use for the map. Defaults to \"OpenStreetMap\".\n                Available options:\n                    - \"OpenStreetMap\": Standard street map.\n                    - \"Esri.WorldImagery\": Satellite imagery from Esri.\n                    - \"Esri.WorldTerrain\": Terrain map from Esri.\n                    - \"Esri.WorldStreetMap\": Street map from Esri.\n                    - \"CartoDB.Positron\": A light and minimalist map style.\n                    - \"CartoDB.DarkMatter\": A dark-themed map style.\n\n            **kwargs: Additional keyword arguments for the folium.Map class.\n        \"\"\"\n        super().__init__(location=center, zoom_start=zoom, tiles=tiles, **kwargs)\n\n    def add_basemap(self, basemap):\n        \"\"\"Add a basemap to the map using folium's TileLayer.\n\n        Args:\n            basemap (str): The name of the basemap to add.\n        \"\"\"\n        # Folium built-in tile layers\n        builtin_tiles = [\n            \"OpenStreetMap\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.WorldTerrain\",\n            \"CartoDB Positron\",\n            \"CartoDB Dark_Matter\",\n        ]\n\n        if basemap in builtin_tiles:\n            folium.TileLayer(basemap, name=basemap).add_to(self)\n\n        else:\n            custom_tiles = {\n                \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n                \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            }\n\n            if basemap in custom_tiles:\n                folium.TileLayer(\n                    tiles=custom_tiles[basemap], attr=\"Custom Attribution\", name=basemap\n                ).add_to(self)\n            else:\n                raise ValueError(f\"Basemap '{basemap}' is not available.\")\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_shp_from_url(self, url, **kwargs):\n        \"\"\"Adds a shapefile from a URL to the map using Folium.\n\n        This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n        in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n        then adds it to the Folium map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n        the CRS to be EPSG:4326 (WGS84).\n\n        Args:\n            url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                        the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n            **kwargs: Additional keyword arguments to pass to the `GeoJson` method for styling and\n                        configuring the GeoJSON layer on the Folium map.\n        \"\"\"\n        try:\n            base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n                \"blob/\", \"\"\n            )\n            shp_url = base_url + \".shp\"\n            shx_url = base_url + \".shx\"\n            dbf_url = base_url + \".dbf\"\n\n            temp_dir = tempfile.mkdtemp()\n\n            shp_file = requests.get(shp_url).content\n            shx_file = requests.get(shx_url).content\n            dbf_file = requests.get(dbf_url).content\n\n            with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n                f.write(shp_file)\n            with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n                f.write(shx_file)\n            with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n                f.write(dbf_file)\n\n            gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n            geojson = gdf.__geo_interface__\n\n            folium.GeoJson(geojson, **kwargs).add_to(self)\n\n            shutil.rmtree(temp_dir)\n\n        except Exception as e:\n            print(f\"Error loading shapefile: {e}\")\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_split_map(\n        self,\n        left,\n        right=\"cartodbpositron\",\n        name_left=\"Left Raster\",\n        name_right=\"Right Raster\",\n        colormap_left=None,\n        colormap_right=None,\n        opacity_left=1.0,\n        opacity_right=1.0,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a split map with one or both sides displaying a raster GeoTIFF, with independent colormaps.\n\n        Args:\n            left (str or TileClient): Left map layer (Tile URL, basemap name, or GeoTIFF path).\n            right (str or TileClient): Right map layer (Tile URL, basemap name, or GeoTIFF path).\n            name_left (str, optional): Name for the left raster layer. Defaults to \"Left Raster\".\n            name_right (str, optional): Name for the right raster layer. Defaults to \"Right Raster\".\n            colormap_left (str, optional): Colormap for the left raster. Defaults to None.\n            colormap_right (str, optional): Colormap for the right raster. Defaults to None.\n            opacity_left (float, optional): Opacity of the left raster. Defaults to 1.0.\n            opacity_right (float, optional): Opacity of the right raster. Defaults to 1.0.\n            **kwargs: Additional arguments for the tile layers.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Convert left layer if it's a raster file/URL\n        if isinstance(left, str) and left.endswith(\".tif\"):\n            client_left = TileClient(left)\n            left_layer = get_folium_tile_layer(\n                client_left,\n                name=name_left,\n                colormap=colormap_left,\n                opacity=opacity_left,\n                **kwargs,\n            )\n        else:\n            left_layer = folium.TileLayer(left, overlay=True, **kwargs)\n\n        # Convert right layer if it's a raster file/URL\n        if isinstance(right, str) and right.endswith(\".tif\"):\n            client_right = TileClient(right)\n            right_layer = get_folium_tile_layer(\n                client_right,\n                name=name_right,\n                colormap=colormap_right,\n                opacity=opacity_right,\n                **kwargs,\n            )\n        else:\n            right_layer = folium.TileLayer(right, overlay=True, **kwargs)\n\n        # Add layers to the map\n        left_layer.add_to(self)\n        right_layer.add_to(self)\n\n        # Create split-screen effect\n        split_map = folium.plugins.SideBySideLayers(left_layer, right_layer)\n        split_map.add_to(self)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.__init__","title":"<code>__init__(self, center=(0, 0), zoom=2, tiles='OpenStreetMap', **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>The initial center of the map as (latitude, longitude). Defaults to (0, 0).</p> <code>(0, 0)</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Defaults to 2.</p> <code>2</code> <code>tiles</code> <code>str</code> <p>The tile layer to use for the map. Defaults to \"OpenStreetMap\". Available options:     - \"OpenStreetMap\": Standard street map.     - \"Esri.WorldImagery\": Satellite imagery from Esri.     - \"Esri.WorldTerrain\": Terrain map from Esri.     - \"Esri.WorldStreetMap\": Street map from Esri.     - \"CartoDB.Positron\": A light and minimalist map style.     - \"CartoDB.DarkMatter\": A dark-themed map style.</p> <code>'OpenStreetMap'</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.Map class.</p> <code>{}</code> Source code in <code>ecospat/foliummap.py</code> <pre><code>def __init__(self, center=(0, 0), zoom=2, tiles=\"OpenStreetMap\", **kwargs):\n    \"\"\"Initializes the Map object.\n\n    Args:\n        center (tuple, optional): The initial center of the map as (latitude, longitude). Defaults to (0, 0).\n        zoom (int, optional): The initial zoom level of the map. Defaults to 2.\n        tiles (str, optional): The tile layer to use for the map. Defaults to \"OpenStreetMap\".\n            Available options:\n                - \"OpenStreetMap\": Standard street map.\n                - \"Esri.WorldImagery\": Satellite imagery from Esri.\n                - \"Esri.WorldTerrain\": Terrain map from Esri.\n                - \"Esri.WorldStreetMap\": Street map from Esri.\n                - \"CartoDB.Positron\": A light and minimalist map style.\n                - \"CartoDB.DarkMatter\": A dark-themed map style.\n\n        **kwargs: Additional keyword arguments for the folium.Map class.\n    \"\"\"\n    super().__init__(location=center, zoom_start=zoom, tiles=tiles, **kwargs)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_basemap","title":"<code>add_basemap(self, basemap)</code>","text":"<p>Add a basemap to the map using folium's TileLayer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>The name of the basemap to add.</p> required Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_basemap(self, basemap):\n    \"\"\"Add a basemap to the map using folium's TileLayer.\n\n    Args:\n        basemap (str): The name of the basemap to add.\n    \"\"\"\n    # Folium built-in tile layers\n    builtin_tiles = [\n        \"OpenStreetMap\",\n        \"OpenTopoMap\",\n        \"Esri.WorldImagery\",\n        \"Esri.WorldTerrain\",\n        \"CartoDB Positron\",\n        \"CartoDB Dark_Matter\",\n    ]\n\n    if basemap in builtin_tiles:\n        folium.TileLayer(basemap, name=basemap).add_to(self)\n\n    else:\n        custom_tiles = {\n            \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n            \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n        }\n\n        if basemap in custom_tiles:\n            folium.TileLayer(\n                tiles=custom_tiles[basemap], attr=\"Custom Attribution\", name=basemap\n            ).add_to(self)\n        else:\n            raise ValueError(f\"Basemap '{basemap}' is not available.\")\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_shp_from_url","title":"<code>add_shp_from_url(self, url, **kwargs)</code>","text":"<p>Adds a shapefile from a URL to the map using Folium.</p> <p>This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and then adds it to the Folium map. If the shapefile's coordinate reference system (CRS) is not set, it assumes the CRS to be EPSG:4326 (WGS84).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the shapefile's location. The URL should be a raw GitHub link to         the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>GeoJson</code> method for styling and         configuring the GeoJSON layer on the Folium map.</p> <code>{}</code> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_shp_from_url(self, url, **kwargs):\n    \"\"\"Adds a shapefile from a URL to the map using Folium.\n\n    This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n    in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n    then adds it to the Folium map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n    the CRS to be EPSG:4326 (WGS84).\n\n    Args:\n        url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                    the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n        **kwargs: Additional keyword arguments to pass to the `GeoJson` method for styling and\n                    configuring the GeoJSON layer on the Folium map.\n    \"\"\"\n    try:\n        base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n        shp_url = base_url + \".shp\"\n        shx_url = base_url + \".shx\"\n        dbf_url = base_url + \".dbf\"\n\n        temp_dir = tempfile.mkdtemp()\n\n        shp_file = requests.get(shp_url).content\n        shx_file = requests.get(shx_url).content\n        dbf_file = requests.get(dbf_url).content\n\n        with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n            f.write(shp_file)\n        with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n            f.write(shx_file)\n        with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n            f.write(dbf_file)\n\n        gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n        geojson = gdf.__geo_interface__\n\n        folium.GeoJson(geojson, **kwargs).add_to(self)\n\n        shutil.rmtree(temp_dir)\n\n    except Exception as e:\n        print(f\"Error loading shapefile: {e}\")\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_split_map","title":"<code>add_split_map(self, left, right='cartodbpositron', name_left='Left Raster', name_right='Right Raster', colormap_left=None, colormap_right=None, opacity_left=1.0, opacity_right=1.0, **kwargs)</code>","text":"<p>Adds a split map with one or both sides displaying a raster GeoTIFF, with independent colormaps.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str or TileClient</code> <p>Left map layer (Tile URL, basemap name, or GeoTIFF path).</p> required <code>right</code> <code>str or TileClient</code> <p>Right map layer (Tile URL, basemap name, or GeoTIFF path).</p> <code>'cartodbpositron'</code> <code>name_left</code> <code>str</code> <p>Name for the left raster layer. Defaults to \"Left Raster\".</p> <code>'Left Raster'</code> <code>name_right</code> <code>str</code> <p>Name for the right raster layer. Defaults to \"Right Raster\".</p> <code>'Right Raster'</code> <code>colormap_left</code> <code>str</code> <p>Colormap for the left raster. Defaults to None.</p> <code>None</code> <code>colormap_right</code> <code>str</code> <p>Colormap for the right raster. Defaults to None.</p> <code>None</code> <code>opacity_left</code> <code>float</code> <p>Opacity of the left raster. Defaults to 1.0.</p> <code>1.0</code> <code>opacity_right</code> <code>float</code> <p>Opacity of the right raster. Defaults to 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional arguments for the tile layers.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_split_map(\n    self,\n    left,\n    right=\"cartodbpositron\",\n    name_left=\"Left Raster\",\n    name_right=\"Right Raster\",\n    colormap_left=None,\n    colormap_right=None,\n    opacity_left=1.0,\n    opacity_right=1.0,\n    **kwargs,\n):\n    \"\"\"\n    Adds a split map with one or both sides displaying a raster GeoTIFF, with independent colormaps.\n\n    Args:\n        left (str or TileClient): Left map layer (Tile URL, basemap name, or GeoTIFF path).\n        right (str or TileClient): Right map layer (Tile URL, basemap name, or GeoTIFF path).\n        name_left (str, optional): Name for the left raster layer. Defaults to \"Left Raster\".\n        name_right (str, optional): Name for the right raster layer. Defaults to \"Right Raster\".\n        colormap_left (str, optional): Colormap for the left raster. Defaults to None.\n        colormap_right (str, optional): Colormap for the right raster. Defaults to None.\n        opacity_left (float, optional): Opacity of the left raster. Defaults to 1.0.\n        opacity_right (float, optional): Opacity of the right raster. Defaults to 1.0.\n        **kwargs: Additional arguments for the tile layers.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Convert left layer if it's a raster file/URL\n    if isinstance(left, str) and left.endswith(\".tif\"):\n        client_left = TileClient(left)\n        left_layer = get_folium_tile_layer(\n            client_left,\n            name=name_left,\n            colormap=colormap_left,\n            opacity=opacity_left,\n            **kwargs,\n        )\n    else:\n        left_layer = folium.TileLayer(left, overlay=True, **kwargs)\n\n    # Convert right layer if it's a raster file/URL\n    if isinstance(right, str) and right.endswith(\".tif\"):\n        client_right = TileClient(right)\n        right_layer = get_folium_tile_layer(\n            client_right,\n            name=name_right,\n            colormap=colormap_right,\n            opacity=opacity_right,\n            **kwargs,\n        )\n    else:\n        right_layer = folium.TileLayer(right, overlay=True, **kwargs)\n\n    # Add layers to the map\n    left_layer.add_to(self)\n    right_layer.add_to(self)\n\n    # Create split-screen effect\n    split_map = folium.plugins.SideBySideLayers(left_layer, right_layer)\n    split_map.add_to(self)\n</code></pre>"},{"location":"foliummap/#ecospat.foliummap.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/foliummap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install ecospat, run this command in your terminal:</p> <pre><code>pip install ecospat\n</code></pre> <p>This is the preferred method to install ecospat, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install ecospat from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/anytko/ecospat\n</code></pre>"},{"location":"mapping/","title":"ipyleaflet_mapping module","text":"<p>This module provides a custom Map class that extends ipyleaflet.Map</p>"},{"location":"mapping/#ecospat.mapping.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>ecospat/mapping.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n        Available basemaps:\n            - \"OpenTopoMap\": A topographic map.\n            - \"OpenStreetMap.Mapnik\": A standard street map.\n            - \"Esri.WorldImagery\": Satellite imagery.\n            - \"Esri.WorldTerrain\": Terrain map from Esri.\n            - \"Esri.WorldStreetMap\": Street map from Esri.\n            - \"CartoDB.Positron\": A light, minimalist map style.\n            - \"CartoDB.DarkMatter\": A dark-themed map style.\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n        Params:\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a basemap from the provided options.\n            - The close button removes the widget from the map.\n\n        Event Handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes and removes the widget from the map.\n            - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n        Returns:\n            None\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"Esri.WorldTerrain\",\n                \"Esri.WorldStreetMap\",\n                \"CartoDB.DarkMatter\",\n                \"CartoDB.Positron\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to add.\n            position (str, optional): Position of the widget. Defaults to \"topright\".\n            **kwargs: Additional keyword arguments for the WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_shp_from_url(self, url, **kwargs):\n        \"\"\"Adds a shapefile from a URL to the map.\n        Adds a shapefile from a URL to the map.\n\n        This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n        in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n        then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n        the CRS to be EPSG:4326 (WGS84).\n\n        Args:\n            url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                    the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n            **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                    configuring the GeoJSON layer on the map.\n        \"\"\"\n        try:\n            base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n                \"blob/\", \"\"\n            )\n            shp_url = base_url + \".shp\"\n            shx_url = base_url + \".shx\"\n            dbf_url = base_url + \".dbf\"\n\n            temp_dir = tempfile.mkdtemp()\n\n            shp_file = requests.get(shp_url).content\n            shx_file = requests.get(shx_url).content\n            dbf_file = requests.get(dbf_url).content\n\n            with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n                f.write(shp_file)\n            with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n                f.write(shx_file)\n            with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n                f.write(dbf_file)\n\n            gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n            geojson = gdf.__geo_interface__\n\n            self.add_geojson(geojson, **kwargs)\n\n            shutil.rmtree(temp_dir)\n\n        except Exception:\n            pass\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n\n    def add_raster(self, url, name=None, colormap=None, opacity=1.0, **kwargs):\n        \"\"\"Adds an raster to the map.\n\n        Args:\n            url (str): The url or file path to the raster.\n            name (str, optional): The name for the raster layer. Defaults to None.\n            colormap (str, optional): The colormap to use for the raster. Defaults to None.\n            opacity (float, optional): The opacity of the raster layer. Defaults to 1.0.\n            **kwargs: Additional keyword arguments for the raster layer.\n        \"\"\"\n\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(url)\n        tile_layer = get_leaflet_tile_layer(\n            client, name=name, colormap=colormap, opacity=opacity, **kwargs\n        )\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, url, bounds=None, opacity=1.0, **kwargs):\n        \"\"\"Adds an image to the map.\n\n        Args:\n            url (str): The URL of the image to overlay on the map.\n            bounds (list): The bounds for the image.\n            opacity (float, optional): The opacity of the image overlay. Defaults to 1.0.\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n\n        if bounds is None or not bounds:\n            raise ValueError(\"Bounds must be specified for the image overlay.\")\n        overlay = ipyleaflet.ImageOverlay(\n            url=url, bounds=bounds, opacity=opacity, **kwargs\n        )\n        self.add(overlay)\n\n    def add_video(self, url, bounds=None, opacity=1.0, **kwargs):\n        \"\"\"Adds a video to the map.\n\n        Args:\n            url (str): The file path to the video.\n            bounds (list, required): The bounds for the video.\n            opacity (float, optional): The opacity of the video overlay. Defaults to 1.0.\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n        \"\"\"\n\n        if bounds is None or not bounds:\n            raise ValueError(\"Bounds must be specified for the video overlay.\")\n        overlay = ipyleaflet.VideoOverlay(\n            url=url, bounds=bounds, opacity=opacity, **kwargs\n        )\n        self.add(overlay)\n\n    def add_wms_layer(\n        self, url, layers, name, format=\"image/png\", transparent=True, **kwargs\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): The WMS service URL.\n            layers (str): The layers to display.\n            name (str): The name for the WMS layer.\n            format (str, optional): The format of the image. Defaults to \"image/png\".\n            transparent (bool, optional): Whether to use transparency. Defaults to True.\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n        \"\"\"\n        layer = ipyleaflet.WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            format=format,\n            transparent=transparent,\n            **kwargs,\n        )\n        self.add(layer)\n\n    def add_markers(self, coordinates, **kwargs):\n        \"\"\"Adds one or more markers to the map at the specified coordinates.\n\n        Args:\n            coordinates (list of tuples): List of (latitude, longitude) coordinates for markers.\n            popup (str, optional): The popup text to display when the marker is clicked. Defaults to None.\n            **kwargs: Additional keyword arguments for the Marker object.\n\n        Returns:\n            None\n        \"\"\"\n        for coord in coordinates:\n            marker = Marker(location=coord, **kwargs)\n\n            self.add(marker)\n\n    def add_search_control(\n        self,\n        url: str,\n        marker: Optional[ipyleaflet.Marker] = None,\n        zoom: Optional[int] = None,\n        position: Optional[str] = \"topleft\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Adds a search control to the map.\n\n        Args:\n            url (str): The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".\n            marker (ipyleaflet.Marker, optional): The marker to be used for the search result. Defaults to None.\n            zoom (int, optional): The zoom level to be used for the search result. Defaults to None.\n            position (str, optional): The position of the search control. Defaults to \"topleft\".\n            kwargs (dict, optional): Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html\n        \"\"\"\n        if marker is None:\n            marker = ipyleaflet.Marker(\n                icon=ipyleaflet.AwesomeIcon(\n                    name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n                )\n            )\n        search_control = ipyleaflet.SearchControl(\n            position=position,\n            url=url,\n            zoom=zoom,\n            marker=marker,\n        )\n        self.add(search_control)\n        self.search_control = search_control\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> <p>Available basemaps:     - \"OpenTopoMap\": A topographic map.     - \"OpenStreetMap.Mapnik\": A standard street map.     - \"Esri.WorldImagery\": Satellite imagery.     - \"Esri.WorldTerrain\": Terrain map from Esri.     - \"Esri.WorldStreetMap\": Street map from Esri.     - \"CartoDB.Positron\": A light, minimalist map style.     - \"CartoDB.DarkMatter\": A dark-themed map style.</p> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n    Available basemaps:\n        - \"OpenTopoMap\": A topographic map.\n        - \"OpenStreetMap.Mapnik\": A standard street map.\n        - \"Esri.WorldImagery\": Satellite imagery.\n        - \"Esri.WorldTerrain\": Terrain map from Esri.\n        - \"Esri.WorldStreetMap\": Street map from Esri.\n        - \"CartoDB.Positron\": A light, minimalist map style.\n        - \"CartoDB.DarkMatter\": A dark-themed map style.\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for dynamically changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a basemap from the provided options.</li> <li>The close button removes the widget from the map.</li> </ul> <p>Event Handlers:     - <code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.     - <code>on_button_click</code>: Closes and removes the widget from the map.     - <code>on_dropdown_change</code>: Updates the map's basemap when a new option is selected.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n    Params:\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a basemap from the provided options.\n        - The close button removes the widget from the map.\n\n    Event Handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes and removes the widget from the map.\n        - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n    Returns:\n        None\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.WorldTerrain\",\n            \"Esri.WorldStreetMap\",\n            \"CartoDB.DarkMatter\",\n            \"CartoDB.Positron\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_image","title":"<code>add_image(self, url, bounds=None, opacity=1.0, **kwargs)</code>","text":"<p>Adds an image to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the image to overlay on the map.</p> required <code>bounds</code> <code>list</code> <p>The bounds for the image.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the image overlay. Defaults to 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_image(self, url, bounds=None, opacity=1.0, **kwargs):\n    \"\"\"Adds an image to the map.\n\n    Args:\n        url (str): The URL of the image to overlay on the map.\n        bounds (list): The bounds for the image.\n        opacity (float, optional): The opacity of the image overlay. Defaults to 1.0.\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n\n    if bounds is None or not bounds:\n        raise ValueError(\"Bounds must be specified for the image overlay.\")\n    overlay = ipyleaflet.ImageOverlay(\n        url=url, bounds=bounds, opacity=opacity, **kwargs\n    )\n    self.add(overlay)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_markers","title":"<code>add_markers(self, coordinates, **kwargs)</code>","text":"<p>Adds one or more markers to the map at the specified coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>list of tuples</code> <p>List of (latitude, longitude) coordinates for markers.</p> required <code>popup</code> <code>str</code> <p>The popup text to display when the marker is clicked. Defaults to None.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the Marker object.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_markers(self, coordinates, **kwargs):\n    \"\"\"Adds one or more markers to the map at the specified coordinates.\n\n    Args:\n        coordinates (list of tuples): List of (latitude, longitude) coordinates for markers.\n        popup (str, optional): The popup text to display when the marker is clicked. Defaults to None.\n        **kwargs: Additional keyword arguments for the Marker object.\n\n    Returns:\n        None\n    \"\"\"\n    for coord in coordinates:\n        marker = Marker(location=coord, **kwargs)\n\n        self.add(marker)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_raster","title":"<code>add_raster(self, url, name=None, colormap=None, opacity=1.0, **kwargs)</code>","text":"<p>Adds an raster to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url or file path to the raster.</p> required <code>name</code> <code>str</code> <p>The name for the raster layer. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The colormap to use for the raster. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the raster layer. Defaults to 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for the raster layer.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_raster(self, url, name=None, colormap=None, opacity=1.0, **kwargs):\n    \"\"\"Adds an raster to the map.\n\n    Args:\n        url (str): The url or file path to the raster.\n        name (str, optional): The name for the raster layer. Defaults to None.\n        colormap (str, optional): The colormap to use for the raster. Defaults to None.\n        opacity (float, optional): The opacity of the raster layer. Defaults to 1.0.\n        **kwargs: Additional keyword arguments for the raster layer.\n    \"\"\"\n\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(url)\n    tile_layer = get_leaflet_tile_layer(\n        client, name=name, colormap=colormap, opacity=opacity, **kwargs\n    )\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_search_control","title":"<code>add_search_control(self, url, marker=None, zoom=None, position='topleft', **kwargs)</code>","text":"<p>Adds a search control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".</p> required <code>marker</code> <code>ipyleaflet.Marker</code> <p>The marker to be used for the search result. Defaults to None.</p> <code>None</code> <code>zoom</code> <code>int</code> <p>The zoom level to be used for the search result. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the search control. Defaults to \"topleft\".</p> <code>'topleft'</code> <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_search_control(\n    self,\n    url: str,\n    marker: Optional[ipyleaflet.Marker] = None,\n    zoom: Optional[int] = None,\n    position: Optional[str] = \"topleft\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Adds a search control to the map.\n\n    Args:\n        url (str): The url to the search API. For example, \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\".\n        marker (ipyleaflet.Marker, optional): The marker to be used for the search result. Defaults to None.\n        zoom (int, optional): The zoom level to be used for the search result. Defaults to None.\n        position (str, optional): The position of the search control. Defaults to \"topleft\".\n        kwargs (dict, optional): Additional keyword arguments to be passed to the search control. See https://ipyleaflet.readthedocs.io/en/latest/api_reference/search_control.html\n    \"\"\"\n    if marker is None:\n        marker = ipyleaflet.Marker(\n            icon=ipyleaflet.AwesomeIcon(\n                name=\"check\", marker_color=\"green\", icon_color=\"darkred\"\n            )\n        )\n    search_control = ipyleaflet.SearchControl(\n        position=position,\n        url=url,\n        zoom=zoom,\n        marker=marker,\n    )\n    self.add(search_control)\n    self.search_control = search_control\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_shp_from_url","title":"<code>add_shp_from_url(self, url, **kwargs)</code>","text":"<p>Adds a shapefile from a URL to the map. Adds a shapefile from a URL to the map.</p> <p>This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes the CRS to be EPSG:4326 (WGS84).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the shapefile's location. The URL should be a raw GitHub link to     the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>add_geojson</code> method for styling and     configuring the GeoJSON layer on the map.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_shp_from_url(self, url, **kwargs):\n    \"\"\"Adds a shapefile from a URL to the map.\n    Adds a shapefile from a URL to the map.\n\n    This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n    in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n    then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n    the CRS to be EPSG:4326 (WGS84).\n\n    Args:\n        url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n        **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                configuring the GeoJSON layer on the map.\n    \"\"\"\n    try:\n        base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n        shp_url = base_url + \".shp\"\n        shx_url = base_url + \".shx\"\n        dbf_url = base_url + \".dbf\"\n\n        temp_dir = tempfile.mkdtemp()\n\n        shp_file = requests.get(shp_url).content\n        shx_file = requests.get(shx_url).content\n        dbf_file = requests.get(dbf_url).content\n\n        with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n            f.write(shp_file)\n        with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n            f.write(shx_file)\n        with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n            f.write(dbf_file)\n\n        gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(geojson, **kwargs)\n\n        shutil.rmtree(temp_dir)\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_video","title":"<code>add_video(self, url, bounds=None, opacity=1.0, **kwargs)</code>","text":"<p>Adds a video to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The file path to the video.</p> required <code>bounds</code> <code>list, required</code> <p>The bounds for the video.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the video overlay. Defaults to 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_video(self, url, bounds=None, opacity=1.0, **kwargs):\n    \"\"\"Adds a video to the map.\n\n    Args:\n        url (str): The file path to the video.\n        bounds (list, required): The bounds for the video.\n        opacity (float, optional): The opacity of the video overlay. Defaults to 1.0.\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n    \"\"\"\n\n    if bounds is None or not bounds:\n        raise ValueError(\"Bounds must be specified for the video overlay.\")\n    overlay = ipyleaflet.VideoOverlay(\n        url=url, bounds=bounds, opacity=opacity, **kwargs\n    )\n    self.add(overlay)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_widget","title":"<code>add_widget(self, widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>Position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for the WidgetControl.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to add.\n        position (str, optional): Position of the widget. Defaults to \"topright\".\n        **kwargs: Additional keyword arguments for the WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"mapping/#ecospat.mapping.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The WMS service URL.</p> required <code>layers</code> <code>str</code> <p>The layers to display.</p> required <code>name</code> <code>str</code> <p>The name for the WMS layer.</p> required <code>format</code> <code>str</code> <p>The format of the image. Defaults to \"image/png\".</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to use transparency. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> Source code in <code>ecospat/mapping.py</code> <pre><code>def add_wms_layer(\n    self, url, layers, name, format=\"image/png\", transparent=True, **kwargs\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): The WMS service URL.\n        layers (str): The layers to display.\n        name (str): The name for the WMS layer.\n        format (str, optional): The format of the image. Defaults to \"image/png\".\n        transparent (bool, optional): Whether to use transparency. Defaults to True.\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n    \"\"\"\n    layer = ipyleaflet.WMSLayer(\n        url=url,\n        layers=layers,\n        name=name,\n        format=format,\n        transparent=transparent,\n        **kwargs,\n    )\n    self.add(layer)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use ecospat in a project:</p> <pre><code>import ecospat\n</code></pre>"},{"location":"examples/interactive_leafmap/","title":"Interactive leafmap","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\nimport leafmap\n</pre> import ecospat.mapping as ecospat_ipyleaflet import leafmap In\u00a0[2]: Copied! <pre>interactive_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\n\nurl = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\ninteractive_map.add_search_control(url, zoom=10, position=\"topleft\")\ninteractive_map\n</pre> interactive_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")  url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\" interactive_map.add_search_control(url, zoom=10, position=\"topleft\") interactive_map Out[2]: In\u00a0[3]: Copied! <pre>legend_map = leafmap.Map(center=[40, -100], zoom=4, height=\"500px\")\nwms_url = \"https://services.terrascope.be/wms/v2?\"\nwms_layer = \"WORLDCOVER_2021_MAP\"\n\n# Add the ESA WorldCover layer\nlegend_map.add_wms_layer(\n    url=wms_url,\n    layers=wms_layer,\n    name=\"ESA WorldCover 2021\",\n    attribution=\"ESA/Terrascope\",\n    format=\"image/png\",\n    transparent=True,\n    shown=True,\n)\n\nlegend_map.add_legend(\n    title=\"ESA WorldCover\", legend_dict=leafmap.builtin_legends[\"ESA_WorldCover\"]\n)\n\nlegend_map\n</pre> legend_map = leafmap.Map(center=[40, -100], zoom=4, height=\"500px\") wms_url = \"https://services.terrascope.be/wms/v2?\" wms_layer = \"WORLDCOVER_2021_MAP\"  # Add the ESA WorldCover layer legend_map.add_wms_layer(     url=wms_url,     layers=wms_layer,     name=\"ESA WorldCover 2021\",     attribution=\"ESA/Terrascope\",     format=\"image/png\",     transparent=True,     shown=True, )  legend_map.add_legend(     title=\"ESA WorldCover\", legend_dict=leafmap.builtin_legends[\"ESA_WorldCover\"] )  legend_map Out[3]: In\u00a0[4]: Copied! <pre>import geopandas as gpd\n\nurl = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"\n\n# Read the GeoJSON file\ngdf = gpd.read_file(url)\n\n# Add latitude and longitude columns from the geometry\ngdf[\"longitude\"] = gdf.geometry.x\ngdf[\"latitude\"] = gdf.geometry.y\n\nm = leafmap.Map(center=[47.654, -117.60], zoom=16)\nm.add_basemap(\"Google Satellite\")\nm.add_marker_cluster(gdf, x=\"longitude\", y=\"latitude\", layer_name=\"Buildings\")\nm\n</pre> import geopandas as gpd  url = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"  # Read the GeoJSON file gdf = gpd.read_file(url)  # Add latitude and longitude columns from the geometry gdf[\"longitude\"] = gdf.geometry.x gdf[\"latitude\"] = gdf.geometry.y  m = leafmap.Map(center=[47.654, -117.60], zoom=16) m.add_basemap(\"Google Satellite\") m.add_marker_cluster(gdf, x=\"longitude\", y=\"latitude\", layer_name=\"Buildings\") m Out[4]: In\u00a0[5]: Copied! <pre>m2 = leafmap.Map(center=[47.654, -117.60], zoom=16)\nm2.add_basemap(\"Google Satellite\")\nm2.add_circle_markers_from_xy(\n    gdf,\n    x=\"longitude\",\n    y=\"latitude\",\n    layer_name=\"Buildings\",\n    radius=5,\n    fill_color=\"yellow\",\n    fill_opacity=0.8,\n    color=\"red\",\n)\nm2\n</pre> m2 = leafmap.Map(center=[47.654, -117.60], zoom=16) m2.add_basemap(\"Google Satellite\") m2.add_circle_markers_from_xy(     gdf,     x=\"longitude\",     y=\"latitude\",     layer_name=\"Buildings\",     radius=5,     fill_color=\"yellow\",     fill_opacity=0.8,     color=\"red\", ) m2 Out[5]: In\u00a0[6]: Copied! <pre>m3 = leafmap.Map(center=[47.654, -117.60], zoom=16)\n\n\nstyle = {\"color\": \"red\"}\n\nm3.add_basemap(\"Google Satellite\")\nm3.add_vector(\n    \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\",\n    style=style,\n    layer_name=\"Building Outlines\",\n)\nm3\n</pre> m3 = leafmap.Map(center=[47.654, -117.60], zoom=16)   style = {\"color\": \"red\"}  m3.add_basemap(\"Google Satellite\") m3.add_vector(     \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\",     style=style,     layer_name=\"Building Outlines\", ) m3 Out[6]: In\u00a0[7]: Copied! <pre>m4 = leafmap.Map(center=[36.121, -115.205], zoom=17)\n\nstyle = {\n    \"color\": \"red\",  # outline color\n    \"weight\": 2,  # outline thickness    # fully transparent\n}\n\nm4.add_basemap(\"Google Satellite\")\nm4.add_vector(\n    \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\",\n    style=style,\n    layer_name=\"Las Vegas Roads\",\n)\nm4\n</pre> m4 = leafmap.Map(center=[36.121, -115.205], zoom=17)  style = {     \"color\": \"red\",  # outline color     \"weight\": 2,  # outline thickness    # fully transparent }  m4.add_basemap(\"Google Satellite\") m4.add_vector(     \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\",     style=style,     layer_name=\"Las Vegas Roads\", ) m4 Out[7]: In\u00a0[8]: Copied! <pre>m5 = leafmap.Map(center=[40, -100], zoom=4)\n\n\nurl = \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\"\ngdf = gpd.read_file(url)\n\n# Create the choropleth map based on the CENSUSAREA column\nm5.add_data(\n    gdf,\n    column=\"CENSUSAREA\",\n    cmap=\"Blues\",\n    layer_name=\"Census Area\",\n    legend_title=\"Census Area\",\n    legend=True,\n)\n\n# Display the map\nm5\n</pre> m5 = leafmap.Map(center=[40, -100], zoom=4)   url = \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\" gdf = gpd.read_file(url)  # Create the choropleth map based on the CENSUSAREA column m5.add_data(     gdf,     column=\"CENSUSAREA\",     cmap=\"Blues\",     layer_name=\"Census Area\",     legend_title=\"Census Area\",     legend=True, )  # Display the map m5 Out[8]: In\u00a0[9]: Copied! <pre>m6 = leafmap.Map()\nm6.add_basemap(\"Satellite\")\nimage1 = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\"\n)\nimage2 = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\"\n)\nm6.split_map(\n    image1,\n    image2,\n    left_label=\"Pre-event\",\n    right_label=\"Post-event\",\n)\nm6\n</pre> m6 = leafmap.Map() m6.add_basemap(\"Satellite\") image1 = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\" ) image2 = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\" ) m6.split_map(     image1,     image2,     left_label=\"Pre-event\",     right_label=\"Post-event\", ) m6 Out[9]:"},{"location":"examples/interactive_leafmap/#creating-an-interactive-map-with-ecospat-package","title":"Creating an interactive map with ecospat package\u00b6","text":""},{"location":"examples/interactive_leafmap/#adding-a-wms-layer-with-a-legend","title":"Adding a WMS layer with a legend\u00b6","text":""},{"location":"examples/interactive_leafmap/#creating-cluster-markers","title":"Creating cluster markers\u00b6","text":""},{"location":"examples/interactive_leafmap/#creating-circle-markers","title":"Creating circle markers\u00b6","text":""},{"location":"examples/interactive_leafmap/#visualizing-vector-data-polygons","title":"Visualizing vector data - polygons\u00b6","text":""},{"location":"examples/interactive_leafmap/#visualizing-vector-data-lines","title":"Visualizing vector data - lines\u00b6","text":""},{"location":"examples/interactive_leafmap/#visualizing-vector-data-data","title":"Visualizing vector data - data\u00b6","text":""},{"location":"examples/interactive_leafmap/#creating-a-split-map","title":"Creating a split map\u00b6","text":""},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\") <pre>Hello World!\n</pre>"},{"location":"examples/mapping/","title":"Mapping","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\nimport ecospat.foliummap as ecospat_foliummap\n</pre> import ecospat.mapping as ecospat_ipyleaflet import ecospat.foliummap as ecospat_foliummap In\u00a0[2]: Copied! <pre>simple_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nsimple_map\n</pre> simple_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") simple_map Out[2]: In\u00a0[3]: Copied! <pre>advanced_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nadvanced_map.add_basemap(\"OpenTopoMap\")\nurl = (\n    \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\"\n)\nadvanced_map.add_geojson(url, name=\"Cities\")\nadvanced_map.add_layer_control()\nadvanced_map\n</pre> advanced_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") advanced_map.add_basemap(\"OpenTopoMap\") url = (     \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\" ) advanced_map.add_geojson(url, name=\"Cities\") advanced_map.add_layer_control() advanced_map Out[3]: In\u00a0[4]: Copied! <pre>simple_folium = ecospat_foliummap.Map(center=[20, 0], zoom=2, tiles=\"OpenStreetMap\")\nsimple_folium.add_basemap(\"OpenTopoMap\")\nsimple_folium.add_layer_control()\nsimple_folium\n</pre> simple_folium = ecospat_foliummap.Map(center=[20, 0], zoom=2, tiles=\"OpenStreetMap\") simple_folium.add_basemap(\"OpenTopoMap\") simple_folium.add_layer_control() simple_folium Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[5]: Copied! <pre># new_map.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\")\n\n# Add a split map with a GeoTIFF on the left and a basemap on the right\nnew_map = ecospat_foliummap.Map(center=[20, 0], zoom=2)\n\n\n# Add split map with two GeoTIFFs on the left and right\nnew_map.add_split_map(\n    left=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",\n    right=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",\n    colormap_left=\"viridis\",\n    colormap_right=\"magma\",\n    opacity_left=0.9,\n    opacity_right=0.8,\n)\n\n# Add the LayerControl to toggle layers independently\nnew_map.add_layer_control()\n\nnew_map\n</pre> # new_map.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\")  # Add a split map with a GeoTIFF on the left and a basemap on the right new_map = ecospat_foliummap.Map(center=[20, 0], zoom=2)   # Add split map with two GeoTIFFs on the left and right new_map.add_split_map(     left=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",     right=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",     colormap_left=\"viridis\",     colormap_right=\"magma\",     opacity_left=0.9,     opacity_right=0.8, )  # Add the LayerControl to toggle layers independently new_map.add_layer_control()  new_map Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[6]: Copied! <pre>advanced_folium = ecospat_foliummap.Map(\n    center=[20, 0], zoom=2, tiles=\"CartoDB dark_matter\"\n)\nurl = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\nadvanced_folium.add_geojson(url, name=\"Countries\")\nadvanced_folium.add_layer_control()\nadvanced_folium\n</pre> advanced_folium = ecospat_foliummap.Map(     center=[20, 0], zoom=2, tiles=\"CartoDB dark_matter\" ) url = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" advanced_folium.add_geojson(url, name=\"Countries\") advanced_folium.add_layer_control() advanced_folium Out[6]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[7]: Copied! <pre>aus_rivers_ipyleaflet = ecospat_ipyleaflet.Map(\n    center=[-25, 135], zoom=4, height=\"300px\"\n)\naus_rivers_ipyleaflet.add_shp_from_url(\n    \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_rivers_australia\",\n    name=\"Rivers of Australia\",\n)\naus_rivers_ipyleaflet.add_layer_control()\naus_rivers_ipyleaflet\n</pre> aus_rivers_ipyleaflet = ecospat_ipyleaflet.Map(     center=[-25, 135], zoom=4, height=\"300px\" ) aus_rivers_ipyleaflet.add_shp_from_url(     \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_rivers_australia\",     name=\"Rivers of Australia\", ) aus_rivers_ipyleaflet.add_layer_control() aus_rivers_ipyleaflet Out[7]: In\u00a0[8]: Copied! <pre>world_lakes_folium = ecospat_foliummap.Map(\n    center=[39.8283, -98.5795], zoom=4, tiles=\"Esri.WorldImagery\"\n)\nworld_lakes_folium.add_shp_from_url(\n    \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_lakes\",\n    name=\"Lakes of Europe\",\n)\nworld_lakes_folium.add_layer_control()\nworld_lakes_folium\n</pre> world_lakes_folium = ecospat_foliummap.Map(     center=[39.8283, -98.5795], zoom=4, tiles=\"Esri.WorldImagery\" ) world_lakes_folium.add_shp_from_url(     \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_lakes\",     name=\"Lakes of Europe\", ) world_lakes_folium.add_layer_control() world_lakes_folium Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/mapping/#first-we-need-to-import-the-biospat-package-and-specify-the-modules-to-use-both-map-classes","title":"First, we need to import the biospat package and specify the modules to use both Map classes.\u00b6","text":""},{"location":"examples/mapping/#now-lets-create-a-basic-and-advanced-map-using-ipyleaflet","title":"Now, let's create a basic and advanced map using ipyleaflet.\u00b6","text":""},{"location":"examples/mapping/#a-simple-openstreetmap-with-ipyleaflet","title":"A simple OpenStreetMap with ipyleaflet\u00b6","text":""},{"location":"examples/mapping/#a-more-advanced-ipyleaflet-map-that-displays-world-topography-and-cities","title":"A more advanced ipyleaflet map that displays world topography and cities.\u00b6","text":""},{"location":"examples/mapping/#different-layers-basemaps-and-cities-can-be-toggled-on-and-off","title":"Different layers (basemaps and cities) can be toggled on and off.\u00b6","text":""},{"location":"examples/mapping/#now-lets-create-a-basic-and-advanced-map-using-folium","title":"Now let's create a basic and advanced map using Folium\u00b6","text":""},{"location":"examples/mapping/#a-simple-openstreetmap-and-opentopomap-with-folium-that-can-be-toggled","title":"A simple OpenStreetMap and OpenTopoMap with Folium that can be toggled.\u00b6","text":""},{"location":"examples/mapping/#a-more-advanced-folium-map-that-displays-world-cartography-in-dark-mode-with-outlined-countries","title":"A more advanced Folium map that displays world cartography (in dark mode) with outlined countries.\u00b6","text":""},{"location":"examples/mapping/#different-layers-basemaps-and-countries-can-be-toggled-on-and-off","title":"Different layers (basemaps and countries) can be toggled on and off.\u00b6","text":""},{"location":"examples/mapping/#we-can-also-add-shp-data-from-a-url-to-a-ipyleaflet-and-folium-map","title":"We can also add shp data from a URL to a ipyleaflet and Folium map.\u00b6","text":""},{"location":"examples/mapping/#for-example-we-can-examine-the-rivers-of-australia-using-ipyleaflet","title":"For example, we can examine the rivers of Australia using ipyleaflet.\u00b6","text":""},{"location":"examples/mapping/#or-we-can-examine-the-major-lakes-of-the-world-on-an-esri-imagery-map-using-folium","title":"Or, we can examine the major lakes of the world on an ESRI imagery map using Folium.\u00b6","text":""},{"location":"examples/raster/","title":"Raster","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\n</pre> import ecospat.mapping as ecospat_ipyleaflet In\u00a0[2]: Copied! <pre>url = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\"\n</pre> url = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\" In\u00a0[3]: Copied! <pre>ucayali_river_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nucayali_river_map.add_raster(url, name=\"Ucayali River\", colormap=\"viridis\", opacity=0.7)\nucayali_river_map\n</pre> ucayali_river_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") ucayali_river_map.add_raster(url, name=\"Ucayali River\", colormap=\"viridis\", opacity=0.7) ucayali_river_map <pre>WARNING:CPLE_AppDefined in vsicurl?url=https%3A%2F%2Fgithub.com%2Fopengeos%2Fdata%2Fblob%2Fmain%2Flandsat%2F2020.tif%3Fraw%3Dtrue&amp;use_head=no&amp;list_dir=no: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</pre> Out[3]: In\u00a0[4]: Copied! <pre>pucallpa_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\npucallpa_map.add_raster(url, name=\"Pucallpa Raster\", colormap=\"viridis\", opacity=0.7)\n\ncoordinates = [(-8.3802, -74.5467)]\n\npucallpa_map.add_markers(coordinates, name=\"Pucallpa\")\n\npucallpa_map.add_layer_control()\npucallpa_map\n</pre> pucallpa_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") pucallpa_map.add_raster(url, name=\"Pucallpa Raster\", colormap=\"viridis\", opacity=0.7)  coordinates = [(-8.3802, -74.5467)]  pucallpa_map.add_markers(coordinates, name=\"Pucallpa\")  pucallpa_map.add_layer_control() pucallpa_map Out[4]: In\u00a0[5]: Copied! <pre>raster_bands = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\"\n</pre> raster_bands = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\" In\u00a0[6]: Copied! <pre># All bands together\nall_bands_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nall_bands_map.add_raster(raster_bands, name=\"landsat\")\nall_bands_map.add_layer_control()  # Add layer control to the map\nall_bands_map\n</pre> # All bands together all_bands_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") all_bands_map.add_raster(raster_bands, name=\"landsat\") all_bands_map.add_layer_control()  # Add layer control to the map all_bands_map Out[6]: In\u00a0[7]: Copied! <pre>import rasterio\n\nsrc = rasterio.open(raster_bands)\nsrc.meta\n</pre> import rasterio  src = rasterio.open(raster_bands) src.meta Out[7]: <pre>{'driver': 'GTiff',\n 'dtype': 'uint8',\n 'nodata': 0.0,\n 'width': 697,\n 'height': 377,\n 'count': 4,\n 'crs': CRS.from_wkt('GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]'),\n 'transform': Affine(0.0008084837557075694, 0.0, -74.72249415376068,\n        0.0, -0.0008084837557075694, -8.282107593468341)}</pre> In\u00a0[8]: Copied! <pre># Only the infrared band (band 4) from the Landsat image\n\none_band_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\none_band_map.add_raster(\n    raster_bands,\n    indexes=4,\n    name=\"Infrared Band\",\n    opacity=0.7,\n)\none_band_map.add_layer_control()\none_band_map\n</pre> # Only the infrared band (band 4) from the Landsat image  one_band_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") one_band_map.add_raster(     raster_bands,     indexes=4,     name=\"Infrared Band\",     opacity=0.7, ) one_band_map.add_layer_control() one_band_map Out[8]: In\u00a0[9]: Copied! <pre>image_map = ecospat_ipyleaflet.Map(center=[39.8283, -98.5795], zoom=4, height=\"600px\")\nimage_map.add_image(\n    \"https://brand.utk.edu/wp-content/uploads/2019/02/University-CenteredLogo-RGB.png\",\n    bounds=[[30.2606, -88.5652], [38.9606, -79.2762]],\n    opacity=0.8,\n    name=\"UTK\",\n)\nimage_map.add_image(\n    \"https://github.com/anytko/anytko.github.io/blob/main/website_photo.png?raw=true\",\n    bounds=[[17, -145], [30, -136]],\n    name=\"Bio\",\n)\n\nimage_map.add_layer_control()\nimage_map\n</pre> image_map = ecospat_ipyleaflet.Map(center=[39.8283, -98.5795], zoom=4, height=\"600px\") image_map.add_image(     \"https://brand.utk.edu/wp-content/uploads/2019/02/University-CenteredLogo-RGB.png\",     bounds=[[30.2606, -88.5652], [38.9606, -79.2762]],     opacity=0.8,     name=\"UTK\", ) image_map.add_image(     \"https://github.com/anytko/anytko.github.io/blob/main/website_photo.png?raw=true\",     bounds=[[17, -145], [30, -136]],     name=\"Bio\", )  image_map.add_layer_control() image_map Out[9]: In\u00a0[10]: Copied! <pre>video_map = ecospat_ipyleaflet.Map(center=(-40.9006, 174.8860), zoom=5, height=\"600px\")\nvideo_url = \"https://github.com/rocksdanister/weather/blob/main/resources/hero.mp4\"\n\nvideo_map.add_image(video_url, bounds=[[-40, 178], [-45, 182]], name=\"Weather App\")\nvideo_map.add_layer_control()\nvideo_map\n</pre> video_map = ecospat_ipyleaflet.Map(center=(-40.9006, 174.8860), zoom=5, height=\"600px\") video_url = \"https://github.com/rocksdanister/weather/blob/main/resources/hero.mp4\"  video_map.add_image(video_url, bounds=[[-40, 178], [-45, 182]], name=\"Weather App\") video_map.add_layer_control() video_map Out[10]: In\u00a0[11]: Copied! <pre>wms_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"600px\")\nwms_url = \"https://nowcoast.noaa.gov/arcgis/services/nowcoast/radar_meteo_imagery_nexrad_time/MapServer/WMSServer?\"\nwms_map.add_wms_layer(\n    url=wms_url,\n    layers=\"NLCD_Canopy\",\n    name=\"Canopy Cover\",\n    format=\"image/png\",\n    transparent=True,\n    opacity=0.7,\n)\nwms_map.add_layer_control()\nwms_map\n</pre> wms_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"600px\") wms_url = \"https://nowcoast.noaa.gov/arcgis/services/nowcoast/radar_meteo_imagery_nexrad_time/MapServer/WMSServer?\" wms_map.add_wms_layer(     url=wms_url,     layers=\"NLCD_Canopy\",     name=\"Canopy Cover\",     format=\"image/png\",     transparent=True,     opacity=0.7, ) wms_map.add_layer_control() wms_map Out[11]:"},{"location":"examples/raster/#adding-raster-data-to-a-map","title":"Adding Raster Data to a Map\u00b6","text":""},{"location":"examples/raster/#incorporating-different-raster-bands","title":"Incorporating Different Raster Bands\u00b6","text":""},{"location":"examples/raster/#adding-an-image-to-a-map","title":"Adding an Image to a Map\u00b6","text":""},{"location":"examples/raster/#adding-a-video-to-a-map","title":"Adding a Video to a Map\u00b6","text":""},{"location":"examples/raster/#adding-a-web-mapping-service-wms-layer-to-a-map","title":"Adding a Web Mapping Service (WMS) Layer to a Map\u00b6","text":""},{"location":"examples/split_map/","title":"Split map","text":"In\u00a0[1]: Copied! <pre>import ecospat.foliummap as ecospat_foliummap\n</pre> import ecospat.foliummap as ecospat_foliummap In\u00a0[2]: Copied! <pre>split_map_base = ecospat_foliummap.Map(center=[40, -100], zoom=4)\nsplit_map_base.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\")\nsplit_map_base.add_layer_control()\nsplit_map_base\n</pre> split_map_base = ecospat_foliummap.Map(center=[40, -100], zoom=4) split_map_base.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\") split_map_base.add_layer_control() split_map_base Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>split_map_r_b = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=8)\nsplit_map_r_b.add_split_map(\n    left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",\n    right=\"OpenTopoMap\",\n    colormap_left=\"viridis\",\n    opacity_left=0.7,\n)\nsplit_map_r_b.add_layer_control()\nsplit_map_r_b\n</pre> split_map_r_b = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=8) split_map_r_b.add_split_map(     left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",     right=\"OpenTopoMap\",     colormap_left=\"viridis\",     opacity_left=0.7, ) split_map_r_b.add_layer_control() split_map_r_b <pre>WARNING:CPLE_AppDefined in vsicurl?url=https%3A%2F%2Fraw.githubusercontent.com%2Fopengeos%2Fdata%2Fmain%2Flandsat%2F2020.tif&amp;use_head=no&amp;list_dir=no: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</pre> Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>split_map_raster = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=10)\nsplit_map_raster.add_split_map(\n    left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",\n    right=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",\n    colormap_left=\"viridis\",\n    colormap_right=\"magma\",\n    opacity_left=0.9,\n    opacity_right=0.5,\n)\nsplit_map_raster.add_layer_control()\nsplit_map_raster\n</pre> split_map_raster = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=10) split_map_raster.add_split_map(     left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",     right=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",     colormap_left=\"viridis\",     colormap_right=\"magma\",     opacity_left=0.9,     opacity_right=0.5, ) split_map_raster.add_layer_control() split_map_raster Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/widgets/","title":"Widgets","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\n</pre> import ecospat.mapping as ecospat_ipyleaflet In\u00a0[2]: Copied! <pre>widget_map = ecospat_ipyleaflet.Map()\nwidget_map.add_basemap_gui()\nwidget_map\n</pre> widget_map = ecospat_ipyleaflet.Map() widget_map.add_basemap_gui() widget_map Out[2]:"}]}