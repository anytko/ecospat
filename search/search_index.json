{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ecospat","text":"<p>A python package to o characterize the range dynamics and shifts of North American tree species.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://anytko.github.io/ecospat</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#ecospat.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>ecospat/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/anytko/ecospat/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>ecospat could always use more documentation, whether as part of the official ecospat docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/anytko/ecospat/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up ecospat for local development.</p> <ol> <li> <p>Fork the ecospat repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/ecospat.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv ecospat\n$ cd ecospat/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 ecospat tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/anytko/ecospat/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"ecospat/","title":"ecospat module","text":"<p>This module provides a custom Map class that extends ipyleaflet.Map to visualize range edge dynamics.</p>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map","title":"<code> GBIF_Map            (HistoricalMap)         </code>","text":"Source code in <code>ecospat/ecospat.py</code> <pre><code>class GBIF_Map(HistoricalMap):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n    def add_gbif_polygons(self, polygons_gdf):\n        \"\"\"Add polygons from a GeoDataFrame to the ipyleaflet map.\"\"\"\n        if not isinstance(polygons_gdf, gpd.GeoDataFrame):\n            raise TypeError(\"Input must be a GeoDataFrame.\")\n        if \"geometry\" not in polygons_gdf:\n            raise ValueError(\"GeoDataFrame must have a 'geometry' column.\")\n\n        gbif_polygons = GeoData(\n            geo_dataframe=polygons_gdf,\n            style={\"color\": \"blue\", \"opacity\": 1, \"weight\": 2, \"fillOpacity\": 0.4},\n        )\n\n        self.add_layer(gbif_polygons)\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n        Available basemaps:\n            - \"OpenTopoMap\": A topographic map.\n            - \"OpenStreetMap.Mapnik\": A standard street map.\n            - \"Esri.WorldImagery\": Satellite imagery.\n            - \"Esri.WorldTerrain\": Terrain map from Esri.\n            - \"Esri.WorldStreetMap\": Street map from Esri.\n            - \"CartoDB.Positron\": A light, minimalist map style.\n            - \"CartoDB.DarkMatter\": A dark-themed map style.\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n        Params:\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a basemap from the provided options.\n            - The close button removes the widget from the map.\n\n        Event Handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes and removes the widget from the map.\n            - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n        Returns:\n            None\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"Esri.WorldTerrain\",\n                \"Esri.WorldStreetMap\",\n                \"CartoDB.DarkMatter\",\n                \"CartoDB.Positron\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to add.\n            position (str, optional): Position of the widget. Defaults to \"topright\".\n            **kwargs: Additional keyword arguments for the WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_shp_from_url(self, url, **kwargs):\n        \"\"\"Adds a shapefile from a URL to the map.\n        Adds a shapefile from a URL to the map.\n\n        This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n        in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n        then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n        the CRS to be EPSG:4326 (WGS84).\n\n        Args:\n            url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                    the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n            **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                    configuring the GeoJSON layer on the map.\n        \"\"\"\n        try:\n            base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n                \"blob/\", \"\"\n            )\n            shp_url = base_url + \".shp\"\n            shx_url = base_url + \".shx\"\n            dbf_url = base_url + \".dbf\"\n\n            temp_dir = tempfile.mkdtemp()\n\n            shp_file = requests.get(shp_url).content\n            shx_file = requests.get(shx_url).content\n            dbf_file = requests.get(dbf_url).content\n\n            with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n                f.write(shp_file)\n            with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n                f.write(shx_file)\n            with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n                f.write(dbf_file)\n\n            gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n            geojson = gdf.__geo_interface__\n\n            self.add_geojson(geojson, **kwargs)\n\n            shutil.rmtree(temp_dir)\n\n        except Exception:\n            pass\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> <p>Available basemaps:     - \"OpenTopoMap\": A topographic map.     - \"OpenStreetMap.Mapnik\": A standard street map.     - \"Esri.WorldImagery\": Satellite imagery.     - \"Esri.WorldTerrain\": Terrain map from Esri.     - \"Esri.WorldStreetMap\": Street map from Esri.     - \"CartoDB.Positron\": A light, minimalist map style.     - \"CartoDB.DarkMatter\": A dark-themed map style.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n    Available basemaps:\n        - \"OpenTopoMap\": A topographic map.\n        - \"OpenStreetMap.Mapnik\": A standard street map.\n        - \"Esri.WorldImagery\": Satellite imagery.\n        - \"Esri.WorldTerrain\": Terrain map from Esri.\n        - \"Esri.WorldStreetMap\": Street map from Esri.\n        - \"CartoDB.Positron\": A light, minimalist map style.\n        - \"CartoDB.DarkMatter\": A dark-themed map style.\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for dynamically changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a basemap from the provided options.</li> <li>The close button removes the widget from the map.</li> </ul> <p>Event Handlers:     - <code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.     - <code>on_button_click</code>: Closes and removes the widget from the map.     - <code>on_dropdown_change</code>: Updates the map's basemap when a new option is selected.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n    Params:\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a basemap from the provided options.\n        - The close button removes the widget from the map.\n\n    Event Handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes and removes the widget from the map.\n        - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n    Returns:\n        None\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.WorldTerrain\",\n            \"Esri.WorldStreetMap\",\n            \"CartoDB.DarkMatter\",\n            \"CartoDB.Positron\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_gbif_polygons","title":"<code>add_gbif_polygons(self, polygons_gdf)</code>","text":"<p>Add polygons from a GeoDataFrame to the ipyleaflet map.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_gbif_polygons(self, polygons_gdf):\n    \"\"\"Add polygons from a GeoDataFrame to the ipyleaflet map.\"\"\"\n    if not isinstance(polygons_gdf, gpd.GeoDataFrame):\n        raise TypeError(\"Input must be a GeoDataFrame.\")\n    if \"geometry\" not in polygons_gdf:\n        raise ValueError(\"GeoDataFrame must have a 'geometry' column.\")\n\n    gbif_polygons = GeoData(\n        geo_dataframe=polygons_gdf,\n        style={\"color\": \"blue\", \"opacity\": 1, \"weight\": 2, \"fillOpacity\": 0.4},\n    )\n\n    self.add_layer(gbif_polygons)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_shp_from_url","title":"<code>add_shp_from_url(self, url, **kwargs)</code>","text":"<p>Adds a shapefile from a URL to the map. Adds a shapefile from a URL to the map.</p> <p>This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes the CRS to be EPSG:4326 (WGS84).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the shapefile's location. The URL should be a raw GitHub link to     the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>add_geojson</code> method for styling and     configuring the GeoJSON layer on the map.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp_from_url(self, url, **kwargs):\n    \"\"\"Adds a shapefile from a URL to the map.\n    Adds a shapefile from a URL to the map.\n\n    This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n    in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n    then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n    the CRS to be EPSG:4326 (WGS84).\n\n    Args:\n        url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n        **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                configuring the GeoJSON layer on the map.\n    \"\"\"\n    try:\n        base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n        shp_url = base_url + \".shp\"\n        shx_url = base_url + \".shx\"\n        dbf_url = base_url + \".dbf\"\n\n        temp_dir = tempfile.mkdtemp()\n\n        shp_file = requests.get(shp_url).content\n        shx_file = requests.get(shx_url).content\n        dbf_file = requests.get(dbf_url).content\n\n        with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n            f.write(shp_file)\n        with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n            f.write(shx_file)\n        with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n            f.write(dbf_file)\n\n        gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(geojson, **kwargs)\n\n        shutil.rmtree(temp_dir)\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.GBIF_Map.add_widget","title":"<code>add_widget(self, widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>Position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for the WidgetControl.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to add.\n        position (str, optional): Position of the widget. Defaults to \"topright\".\n        **kwargs: Additional keyword arguments for the WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap","title":"<code> HistoricalMap            (Map)         </code>","text":"Source code in <code>ecospat/ecospat.py</code> <pre><code>class HistoricalMap(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n        self.github_historic_url = (\n            \"https://raw.githubusercontent.com/wpetry/USTreeAtlas/main/geojson\"\n        )\n        self.github_state_url = \"https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/10m_cultural\"\n        self.gdfs = {}\n        self.references = REFERENCES\n\n    def shorten_name(self, species_name):\n        \"\"\"Helper to shorten the species name.\"\"\"\n        return (species_name.split()[0][:4] + species_name.split()[1][:4]).lower()\n\n    def load_historic_data(self, species_name):\n        # Create the short name (first 4 letters of each word, lowercase)\n        short_name = self.shorten_name(species_name)\n\n        # Build the URL\n        geojson_url = f\"{self.github_historic_url}/{short_name}.geojson\"\n\n        try:\n            # Download the GeoJSON file\n            response = requests.get(geojson_url)\n            response.raise_for_status()\n\n            # Read it into a GeoDataFrame\n            species_range = gpd.read_file(BytesIO(response.content))\n\n            # Reproject to WGS84\n            species_range = species_range.to_crs(epsg=4326)\n\n            # Save it internally\n            self.gdfs[short_name] = species_range\n\n            # No prints, no plots - clean loading!\n\n        except Exception as e:\n            print(f\"Error loading {geojson_url}: {e}\")\n\n    def remove_lakes(self, polygons_gdf):\n        \"\"\"\n        Removes lakes from range polygons and returns the resulting GeoDataFrame.\n        All operations in EPSG:3395 for consistency.\n        \"\"\"\n\n        lakes_url = \"https://raw.githubusercontent.com/anytko/biospat_large_files/main/lakes_na.geojson\"\n\n        lakes_gdf = gpd.read_file(lakes_url)\n\n        # Ensure valid geometries\n        polygons_gdf = polygons_gdf[polygons_gdf.geometry.is_valid]\n        lakes_gdf = lakes_gdf[lakes_gdf.geometry.is_valid]\n\n        # Force both to have a CRS if missing\n        if polygons_gdf.crs is None:\n            polygons_gdf = polygons_gdf.set_crs(\"EPSG:4326\")\n        if lakes_gdf.crs is None:\n            lakes_gdf = lakes_gdf.set_crs(\"EPSG:4326\")\n\n        # Reproject to EPSG:3395 for spatial ops\n        polygons_proj = polygons_gdf.to_crs(epsg=3395)\n        lakes_proj = lakes_gdf.to_crs(epsg=3395)\n\n        # Perform spatial difference\n        polygons_no_lakes_proj = gpd.overlay(\n            polygons_proj, lakes_proj, how=\"difference\"\n        )\n\n        # Remove empty geometries\n        polygons_no_lakes_proj = polygons_no_lakes_proj[\n            ~polygons_no_lakes_proj.geometry.is_empty\n        ]\n\n        # Stay in EPSG:3395 (no reprojecting back to 4326)\n        return polygons_no_lakes_proj\n\n    def load_states(self):\n        # URLs for the shapefile components (shp, shx, dbf)\n        shp_url = f\"{self.github_state_url}/ne_10m_admin_1_states_provinces.shp\"\n        shx_url = f\"{self.github_state_url}/ne_10m_admin_1_states_provinces.shx\"\n        dbf_url = f\"{self.github_state_url}/ne_10m_admin_1_states_provinces.dbf\"\n\n        try:\n            # Download all components of the shapefile\n            shp_response = requests.get(shp_url)\n            shx_response = requests.get(shx_url)\n            dbf_response = requests.get(dbf_url)\n\n            shp_response.raise_for_status()\n            shx_response.raise_for_status()\n            dbf_response.raise_for_status()\n\n            # Create a temporary directory to store the shapefile components in memory\n            with open(\"/tmp/ne_10m_admin_1_states_provinces.shp\", \"wb\") as shp_file:\n                shp_file.write(shp_response.content)\n            with open(\"/tmp/ne_10m_admin_1_states_provinces.shx\", \"wb\") as shx_file:\n                shx_file.write(shx_response.content)\n            with open(\"/tmp/ne_10m_admin_1_states_provinces.dbf\", \"wb\") as dbf_file:\n                dbf_file.write(dbf_response.content)\n\n            # Now load the shapefile using geopandas\n            state_gdf = gpd.read_file(\"/tmp/ne_10m_admin_1_states_provinces.shp\")\n\n            # Store it in the class as an attribute\n            self.states = state_gdf\n\n            print(\"Lakes data loaded successfully\")\n\n        except Exception as e:\n            print(f\"Error loading lakes shapefile: {e}\")\n\n    def get_historic_date(self, species_name):\n        # Helper function to easily fetch the reference\n        short_name = (species_name.split()[0][:4] + species_name.split()[1][:4]).lower()\n        return self.references.get(short_name, \"Reference not found\")\n\n    def add_basemap(self, basemap=\"OpenTopoMap\"):\n        \"\"\"Add basemap to the map.\n\n        Args:\n            basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n        Available basemaps:\n            - \"OpenTopoMap\": A topographic map.\n            - \"OpenStreetMap.Mapnik\": A standard street map.\n            - \"Esri.WorldImagery\": Satellite imagery.\n            - \"Esri.WorldTerrain\": Terrain map from Esri.\n            - \"Esri.WorldStreetMap\": Street map from Esri.\n            - \"CartoDB.Positron\": A light, minimalist map style.\n            - \"CartoDB.DarkMatter\": A dark-themed map style.\n        \"\"\"\n\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(layer)\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n        Params:\n            options (list, optional): A list of basemap options to display in the dropdown.\n                Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n            position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n        Behavior:\n            - A toggle button is used to show or hide the dropdown and close button.\n            - The dropdown allows users to select a basemap from the provided options.\n            - The close button removes the widget from the map.\n\n        Event Handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes and removes the widget from the map.\n            - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n        Returns:\n            None\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"Esri.WorldTerrain\",\n                \"Esri.WorldStreetMap\",\n                \"CartoDB.DarkMatter\",\n                \"CartoDB.Positron\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap:\",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"Add a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to add.\n            position (str, optional): Position of the widget. Defaults to \"topright\".\n            **kwargs: Additional keyword arguments for the WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_google_map(self, map_type=\"ROADMAP\"):\n        \"\"\"Add Google Map to the map.\n\n        Args:\n            map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n        self.add(layer)\n\n    def add_geojson(\n        self,\n        data,\n        zoom_to_layer=True,\n        hover_style=None,\n        **kwargs,\n    ):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n            hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if hover_style is None:\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n        layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n        self.add_layer(layer)\n\n        if zoom_to_layer:\n            bounds = gdf.total_bounds\n            self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_shp_from_url(self, url, **kwargs):\n        \"\"\"Adds a shapefile from a URL to the map.\n        Adds a shapefile from a URL to the map.\n\n        This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n        in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n        then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n        the CRS to be EPSG:4326 (WGS84).\n\n        Args:\n            url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                    the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n            **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                    configuring the GeoJSON layer on the map.\n        \"\"\"\n        try:\n            base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n                \"blob/\", \"\"\n            )\n            shp_url = base_url + \".shp\"\n            shx_url = base_url + \".shx\"\n            dbf_url = base_url + \".dbf\"\n\n            temp_dir = tempfile.mkdtemp()\n\n            shp_file = requests.get(shp_url).content\n            shx_file = requests.get(shx_url).content\n            dbf_file = requests.get(dbf_url).content\n\n            with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n                f.write(shp_file)\n            with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n                f.write(shx_file)\n            with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n                f.write(dbf_file)\n\n            gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n            if gdf.crs is None:\n                gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n            geojson = gdf.__geo_interface__\n\n            self.add_geojson(geojson, **kwargs)\n\n            shutil.rmtree(temp_dir)\n\n        except Exception:\n            pass\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenTopoMap')</code>","text":"<p>Add basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Defaults to \"OpenTopoMap\".</p> <code>'OpenTopoMap'</code> <p>Available basemaps:     - \"OpenTopoMap\": A topographic map.     - \"OpenStreetMap.Mapnik\": A standard street map.     - \"Esri.WorldImagery\": Satellite imagery.     - \"Esri.WorldTerrain\": Terrain map from Esri.     - \"Esri.WorldStreetMap\": Street map from Esri.     - \"CartoDB.Positron\": A light, minimalist map style.     - \"CartoDB.DarkMatter\": A dark-themed map style.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap(self, basemap=\"OpenTopoMap\"):\n    \"\"\"Add basemap to the map.\n\n    Args:\n        basemap (str, optional): Basemap name. Defaults to \"OpenTopoMap\".\n\n    Available basemaps:\n        - \"OpenTopoMap\": A topographic map.\n        - \"OpenStreetMap.Mapnik\": A standard street map.\n        - \"Esri.WorldImagery\": Satellite imagery.\n        - \"Esri.WorldTerrain\": Terrain map from Esri.\n        - \"Esri.WorldStreetMap\": Street map from Esri.\n        - \"CartoDB.Positron\": A light, minimalist map style.\n        - \"CartoDB.DarkMatter\": A dark-themed map style.\n    \"\"\"\n\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a graphical user interface (GUI) for dynamically changing basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>A list of basemap options to display in the dropdown. Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the widget on the map. Defaults to \"topright\".</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button is used to show or hide the dropdown and close button.</li> <li>The dropdown allows users to select a basemap from the provided options.</li> <li>The close button removes the widget from the map.</li> </ul> <p>Event Handlers:     - <code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.     - <code>on_button_click</code>: Closes and removes the widget from the map.     - <code>on_dropdown_change</code>: Updates the map's basemap when a new option is selected.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"Adds a graphical user interface (GUI) for dynamically changing basemaps.\n\n    Params:\n        options (list, optional): A list of basemap options to display in the dropdown.\n            Defaults to [\"OpenStreetMap.Mapnik\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.WorldTerrain\", \"Esri.WorldStreetMap\", \"CartoDB.DarkMatter\", \"CartoDB.Positron\"].\n        position (str, optional): The position of the widget on the map. Defaults to \"topright\".\n\n    Behavior:\n        - A toggle button is used to show or hide the dropdown and close button.\n        - The dropdown allows users to select a basemap from the provided options.\n        - The close button removes the widget from the map.\n\n    Event Handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes and removes the widget from the map.\n        - `on_dropdown_change`: Updates the map's basemap when a new option is selected.\n\n    Returns:\n        None\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.WorldTerrain\",\n            \"Esri.WorldStreetMap\",\n            \"CartoDB.DarkMatter\",\n            \"CartoDB.Positron\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap:\",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_geojson","title":"<code>add_geojson(self, data, zoom_to_layer=True, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the layer's bounds. Defaults to True.</p> <code>True</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_geojson(\n    self,\n    data,\n    zoom_to_layer=True,\n    hover_style=None,\n    **kwargs,\n):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        zoom_to_layer (bool, optional): Whether to zoom to the layer's bounds. Defaults to True.\n        hover_style (dict, optional): Style to apply when hovering over features. Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2}.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if hover_style is None:\n        hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n    layer = ipyleaflet.GeoJSON(data=geojson, hover_style=hover_style, **kwargs)\n    self.add_layer(layer)\n\n    if zoom_to_layer:\n        bounds = gdf.total_bounds\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_google_map","title":"<code>add_google_map(self, map_type='ROADMAP')</code>","text":"<p>Add Google Map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Map type. Defaults to \"ROADMAP\".</p> <code>'ROADMAP'</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_google_map(self, map_type=\"ROADMAP\"):\n    \"\"\"Add Google Map to the map.\n\n    Args:\n        map_type (str, optional): Map type. Defaults to \"ROADMAP\".\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Map\")\n    self.add(layer)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_shp_from_url","title":"<code>add_shp_from_url(self, url, **kwargs)</code>","text":"<p>Adds a shapefile from a URL to the map. Adds a shapefile from a URL to the map.</p> <p>This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes the CRS to be EPSG:4326 (WGS84).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the shapefile's location. The URL should be a raw GitHub link to     the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the <code>add_geojson</code> method for styling and     configuring the GeoJSON layer on the map.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_shp_from_url(self, url, **kwargs):\n    \"\"\"Adds a shapefile from a URL to the map.\n    Adds a shapefile from a URL to the map.\n\n    This function downloads the shapefile components (.shp, .shx, .dbf) from the specified URL, stores them\n    in a temporary directory, reads the shapefile using Geopandas, converts it to GeoJSON format, and\n    then adds it to the map. If the shapefile's coordinate reference system (CRS) is not set, it assumes\n    the CRS to be EPSG:4326 (WGS84).\n\n    Args:\n        url (str): The URL pointing to the shapefile's location. The URL should be a raw GitHub link to\n                the shapefile components (e.g., \".shp\", \".shx\", \".dbf\").\n        **kwargs: Additional keyword arguments to pass to the `add_geojson` method for styling and\n                configuring the GeoJSON layer on the map.\n    \"\"\"\n    try:\n        base_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n        shp_url = base_url + \".shp\"\n        shx_url = base_url + \".shx\"\n        dbf_url = base_url + \".dbf\"\n\n        temp_dir = tempfile.mkdtemp()\n\n        shp_file = requests.get(shp_url).content\n        shx_file = requests.get(shx_url).content\n        dbf_file = requests.get(dbf_url).content\n\n        with open(os.path.join(temp_dir, \"data.shp\"), \"wb\") as f:\n            f.write(shp_file)\n        with open(os.path.join(temp_dir, \"data.shx\"), \"wb\") as f:\n            f.write(shx_file)\n        with open(os.path.join(temp_dir, \"data.dbf\"), \"wb\") as f:\n            f.write(dbf_file)\n\n        gdf = gpd.read_file(os.path.join(temp_dir, \"data.shp\"))\n\n        if gdf.crs is None:\n            gdf.set_crs(\"EPSG:4326\", allow_override=True, inplace=True)\n\n        geojson = gdf.__geo_interface__\n\n        self.add_geojson(geojson, **kwargs)\n\n        shutil.rmtree(temp_dir)\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.add_widget","title":"<code>add_widget(self, widget, position='topright', **kwargs)</code>","text":"<p>Add a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to add.</p> required <code>position</code> <code>str</code> <p>Position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for the WidgetControl.</p> <code>{}</code> Source code in <code>ecospat/ecospat.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"Add a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to add.\n        position (str, optional): Position of the widget. Defaults to \"topright\".\n        **kwargs: Additional keyword arguments for the WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.remove_lakes","title":"<code>remove_lakes(self, polygons_gdf)</code>","text":"<p>Removes lakes from range polygons and returns the resulting GeoDataFrame. All operations in EPSG:3395 for consistency.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def remove_lakes(self, polygons_gdf):\n    \"\"\"\n    Removes lakes from range polygons and returns the resulting GeoDataFrame.\n    All operations in EPSG:3395 for consistency.\n    \"\"\"\n\n    lakes_url = \"https://raw.githubusercontent.com/anytko/biospat_large_files/main/lakes_na.geojson\"\n\n    lakes_gdf = gpd.read_file(lakes_url)\n\n    # Ensure valid geometries\n    polygons_gdf = polygons_gdf[polygons_gdf.geometry.is_valid]\n    lakes_gdf = lakes_gdf[lakes_gdf.geometry.is_valid]\n\n    # Force both to have a CRS if missing\n    if polygons_gdf.crs is None:\n        polygons_gdf = polygons_gdf.set_crs(\"EPSG:4326\")\n    if lakes_gdf.crs is None:\n        lakes_gdf = lakes_gdf.set_crs(\"EPSG:4326\")\n\n    # Reproject to EPSG:3395 for spatial ops\n    polygons_proj = polygons_gdf.to_crs(epsg=3395)\n    lakes_proj = lakes_gdf.to_crs(epsg=3395)\n\n    # Perform spatial difference\n    polygons_no_lakes_proj = gpd.overlay(\n        polygons_proj, lakes_proj, how=\"difference\"\n    )\n\n    # Remove empty geometries\n    polygons_no_lakes_proj = polygons_no_lakes_proj[\n        ~polygons_no_lakes_proj.geometry.is_empty\n    ]\n\n    # Stay in EPSG:3395 (no reprojecting back to 4326)\n    return polygons_no_lakes_proj\n</code></pre>"},{"location":"ecospat/#ecospat.ecospat.HistoricalMap.shorten_name","title":"<code>shorten_name(self, species_name)</code>","text":"<p>Helper to shorten the species name.</p> Source code in <code>ecospat/ecospat.py</code> <pre><code>def shorten_name(self, species_name):\n    \"\"\"Helper to shorten the species name.\"\"\"\n    return (species_name.split()[0][:4] + species_name.split()[1][:4]).lower()\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install ecospat, run this command in your terminal:</p> <pre><code>pip install ecospat\n</code></pre> <p>This is the preferred method to install ecospat, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install ecospat from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/anytko/ecospat\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use ecospat in a project:</p> <pre><code>import ecospat\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\") <pre>Hello World!\n</pre>"},{"location":"examples/mapping/","title":"Mapping","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\nimport ecospat.foliummap as ecospat_foliummap\n</pre> import ecospat.mapping as ecospat_ipyleaflet import ecospat.foliummap as ecospat_foliummap In\u00a0[2]: Copied! <pre>simple_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nsimple_map\n</pre> simple_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") simple_map Out[2]: In\u00a0[3]: Copied! <pre>advanced_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nadvanced_map.add_basemap(\"OpenTopoMap\")\nurl = (\n    \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\"\n)\nadvanced_map.add_geojson(url, name=\"Cities\")\nadvanced_map.add_layer_control()\nadvanced_map\n</pre> advanced_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") advanced_map.add_basemap(\"OpenTopoMap\") url = (     \"https://github.com/opengeos/datasets/releases/download/world/world_cities.geojson\" ) advanced_map.add_geojson(url, name=\"Cities\") advanced_map.add_layer_control() advanced_map Out[3]: In\u00a0[4]: Copied! <pre>simple_folium = ecospat_foliummap.Map(center=[20, 0], zoom=2, tiles=\"OpenStreetMap\")\nsimple_folium.add_basemap(\"OpenTopoMap\")\nsimple_folium.add_layer_control()\nsimple_folium\n</pre> simple_folium = ecospat_foliummap.Map(center=[20, 0], zoom=2, tiles=\"OpenStreetMap\") simple_folium.add_basemap(\"OpenTopoMap\") simple_folium.add_layer_control() simple_folium Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[5]: Copied! <pre># new_map.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\")\n\n# Add a split map with a GeoTIFF on the left and a basemap on the right\nnew_map = ecospat_foliummap.Map(center=[20, 0], zoom=2)\n\n\n# Add split map with two GeoTIFFs on the left and right\nnew_map.add_split_map(\n    left=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",\n    right=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",\n    colormap_left=\"viridis\",\n    colormap_right=\"magma\",\n    opacity_left=0.9,\n    opacity_right=0.8,\n)\n\n# Add the LayerControl to toggle layers independently\nnew_map.add_layer_control()\n\nnew_map\n</pre> # new_map.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\")  # Add a split map with a GeoTIFF on the left and a basemap on the right new_map = ecospat_foliummap.Map(center=[20, 0], zoom=2)   # Add split map with two GeoTIFFs on the left and right new_map.add_split_map(     left=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",     right=\"https://raw.githubusercontent.com/kgjenkins/ophz/master/tif/ophz-us48.tif\",     colormap_left=\"viridis\",     colormap_right=\"magma\",     opacity_left=0.9,     opacity_right=0.8, )  # Add the LayerControl to toggle layers independently new_map.add_layer_control()  new_map <pre>/home/runner/.local/lib/python3.11/site-packages/rio_tiler/io/rasterio.py:135: NoOverviewWarning: The dataset has no Overviews. rio-tiler performances might be impacted.\n  warnings.warn(\n</pre> Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[6]: Copied! <pre>advanced_folium = ecospat_foliummap.Map(\n    center=[20, 0], zoom=2, tiles=\"CartoDB dark_matter\"\n)\nurl = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\nadvanced_folium.add_geojson(url, name=\"Countries\")\nadvanced_folium.add_layer_control()\nadvanced_folium\n</pre> advanced_folium = ecospat_foliummap.Map(     center=[20, 0], zoom=2, tiles=\"CartoDB dark_matter\" ) url = \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" advanced_folium.add_geojson(url, name=\"Countries\") advanced_folium.add_layer_control() advanced_folium Out[6]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[7]: Copied! <pre>aus_rivers_ipyleaflet = ecospat_ipyleaflet.Map(\n    center=[-25, 135], zoom=4, height=\"300px\"\n)\naus_rivers_ipyleaflet.add_shp_from_url(\n    \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_rivers_australia\",\n    name=\"Rivers of Australia\",\n)\naus_rivers_ipyleaflet.add_layer_control()\naus_rivers_ipyleaflet\n</pre> aus_rivers_ipyleaflet = ecospat_ipyleaflet.Map(     center=[-25, 135], zoom=4, height=\"300px\" ) aus_rivers_ipyleaflet.add_shp_from_url(     \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_rivers_australia\",     name=\"Rivers of Australia\", ) aus_rivers_ipyleaflet.add_layer_control() aus_rivers_ipyleaflet Out[7]: In\u00a0[8]: Copied! <pre>world_lakes_folium = ecospat_foliummap.Map(\n    center=[39.8283, -98.5795], zoom=4, tiles=\"Esri.WorldImagery\"\n)\nworld_lakes_folium.add_shp_from_url(\n    \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_lakes\",\n    name=\"Lakes of Europe\",\n)\nworld_lakes_folium.add_layer_control()\nworld_lakes_folium\n</pre> world_lakes_folium = ecospat_foliummap.Map(     center=[39.8283, -98.5795], zoom=4, tiles=\"Esri.WorldImagery\" ) world_lakes_folium.add_shp_from_url(     \"https://github.com/nvkelso/natural-earth-vector/blob/master/10m_physical/ne_10m_lakes\",     name=\"Lakes of Europe\", ) world_lakes_folium.add_layer_control() world_lakes_folium Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/mapping/#first-we-need-to-import-the-biospat-package-and-specify-the-modules-to-use-both-map-classes","title":"First, we need to import the biospat package and specify the modules to use both Map classes.\u00b6","text":""},{"location":"examples/mapping/#now-lets-create-a-basic-and-advanced-map-using-ipyleaflet","title":"Now, let's create a basic and advanced map using ipyleaflet.\u00b6","text":""},{"location":"examples/mapping/#a-simple-openstreetmap-with-ipyleaflet","title":"A simple OpenStreetMap with ipyleaflet\u00b6","text":""},{"location":"examples/mapping/#a-more-advanced-ipyleaflet-map-that-displays-world-topography-and-cities","title":"A more advanced ipyleaflet map that displays world topography and cities.\u00b6","text":""},{"location":"examples/mapping/#different-layers-basemaps-and-cities-can-be-toggled-on-and-off","title":"Different layers (basemaps and cities) can be toggled on and off.\u00b6","text":""},{"location":"examples/mapping/#now-lets-create-a-basic-and-advanced-map-using-folium","title":"Now let's create a basic and advanced map using Folium\u00b6","text":""},{"location":"examples/mapping/#a-simple-openstreetmap-and-opentopomap-with-folium-that-can-be-toggled","title":"A simple OpenStreetMap and OpenTopoMap with Folium that can be toggled.\u00b6","text":""},{"location":"examples/mapping/#a-more-advanced-folium-map-that-displays-world-cartography-in-dark-mode-with-outlined-countries","title":"A more advanced Folium map that displays world cartography (in dark mode) with outlined countries.\u00b6","text":""},{"location":"examples/mapping/#different-layers-basemaps-and-countries-can-be-toggled-on-and-off","title":"Different layers (basemaps and countries) can be toggled on and off.\u00b6","text":""},{"location":"examples/mapping/#we-can-also-add-shp-data-from-a-url-to-a-ipyleaflet-and-folium-map","title":"We can also add shp data from a URL to a ipyleaflet and Folium map.\u00b6","text":""},{"location":"examples/mapping/#for-example-we-can-examine-the-rivers-of-australia-using-ipyleaflet","title":"For example, we can examine the rivers of Australia using ipyleaflet.\u00b6","text":""},{"location":"examples/mapping/#or-we-can-examine-the-major-lakes-of-the-world-on-an-esri-imagery-map-using-folium","title":"Or, we can examine the major lakes of the world on an ESRI imagery map using Folium.\u00b6","text":""},{"location":"examples/raster/","title":"Raster","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\n</pre> import ecospat.mapping as ecospat_ipyleaflet In\u00a0[2]: Copied! <pre>url = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\"\n</pre> url = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\" In\u00a0[3]: Copied! <pre>ucayali_river_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nucayali_river_map.add_raster(url, name=\"Ucayali River\", colormap=\"viridis\", opacity=0.7)\nucayali_river_map\n</pre> ucayali_river_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") ucayali_river_map.add_raster(url, name=\"Ucayali River\", colormap=\"viridis\", opacity=0.7) ucayali_river_map <pre>WARNING:CPLE_AppDefined in vsicurl?url=https%3A%2F%2Fgithub.com%2Fopengeos%2Fdata%2Fblob%2Fmain%2Flandsat%2F2020.tif%3Fraw%3Dtrue&amp;use_head=no&amp;list_dir=no: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</pre> Out[3]: In\u00a0[4]: Copied! <pre>pucallpa_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\npucallpa_map.add_raster(url, name=\"Pucallpa Raster\", colormap=\"viridis\", opacity=0.7)\n\ncoordinates = [(-8.3802, -74.5467)]\n\npucallpa_map.add_markers(coordinates, name=\"Pucallpa\")\n\npucallpa_map.add_layer_control()\npucallpa_map\n</pre> pucallpa_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") pucallpa_map.add_raster(url, name=\"Pucallpa Raster\", colormap=\"viridis\", opacity=0.7)  coordinates = [(-8.3802, -74.5467)]  pucallpa_map.add_markers(coordinates, name=\"Pucallpa\")  pucallpa_map.add_layer_control() pucallpa_map Out[4]: In\u00a0[5]: Copied! <pre>raster_bands = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\"\n</pre> raster_bands = \"https://github.com/opengeos/data/blob/main/landsat/2020.tif?raw=true\" In\u00a0[6]: Copied! <pre># All bands together\nall_bands_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\nall_bands_map.add_raster(raster_bands, name=\"landsat\")\nall_bands_map.add_layer_control()  # Add layer control to the map\nall_bands_map\n</pre> # All bands together all_bands_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") all_bands_map.add_raster(raster_bands, name=\"landsat\") all_bands_map.add_layer_control()  # Add layer control to the map all_bands_map Out[6]: In\u00a0[7]: Copied! <pre>import rasterio\n\nsrc = rasterio.open(raster_bands)\nsrc.meta\n</pre> import rasterio  src = rasterio.open(raster_bands) src.meta Out[7]: <pre>{'driver': 'GTiff',\n 'dtype': 'uint8',\n 'nodata': 0.0,\n 'width': 697,\n 'height': 377,\n 'count': 4,\n 'crs': CRS.from_wkt('GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]'),\n 'transform': Affine(0.0008084837557075694, 0.0, -74.72249415376068,\n        0.0, -0.0008084837557075694, -8.282107593468341)}</pre> In\u00a0[8]: Copied! <pre># Only the infrared band (band 4) from the Landsat image\n\none_band_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\")\none_band_map.add_raster(\n    raster_bands,\n    indexes=4,\n    name=\"Infrared Band\",\n    opacity=0.7,\n)\none_band_map.add_layer_control()\none_band_map\n</pre> # Only the infrared band (band 4) from the Landsat image  one_band_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"300px\") one_band_map.add_raster(     raster_bands,     indexes=4,     name=\"Infrared Band\",     opacity=0.7, ) one_band_map.add_layer_control() one_band_map Out[8]: In\u00a0[9]: Copied! <pre>image_map = ecospat_ipyleaflet.Map(center=[39.8283, -98.5795], zoom=4, height=\"600px\")\nimage_map.add_image(\n    \"https://brand.utk.edu/wp-content/uploads/2019/02/University-CenteredLogo-RGB.png\",\n    bounds=[[30.2606, -88.5652], [38.9606, -79.2762]],\n    opacity=0.8,\n    name=\"UTK\",\n)\nimage_map.add_image(\n    \"https://github.com/anytko/anytko.github.io/blob/main/website_photo.png?raw=true\",\n    bounds=[[17, -145], [30, -136]],\n    name=\"Bio\",\n)\n\nimage_map.add_layer_control()\nimage_map\n</pre> image_map = ecospat_ipyleaflet.Map(center=[39.8283, -98.5795], zoom=4, height=\"600px\") image_map.add_image(     \"https://brand.utk.edu/wp-content/uploads/2019/02/University-CenteredLogo-RGB.png\",     bounds=[[30.2606, -88.5652], [38.9606, -79.2762]],     opacity=0.8,     name=\"UTK\", ) image_map.add_image(     \"https://github.com/anytko/anytko.github.io/blob/main/website_photo.png?raw=true\",     bounds=[[17, -145], [30, -136]],     name=\"Bio\", )  image_map.add_layer_control() image_map Out[9]: In\u00a0[10]: Copied! <pre>video_map = ecospat_ipyleaflet.Map(center=(-40.9006, 174.8860), zoom=5, height=\"600px\")\nvideo_url = \"https://github.com/rocksdanister/weather/blob/main/resources/hero.mp4\"\n\nvideo_map.add_image(video_url, bounds=[[-40, 178], [-45, 182]], name=\"Weather App\")\nvideo_map.add_layer_control()\nvideo_map\n</pre> video_map = ecospat_ipyleaflet.Map(center=(-40.9006, 174.8860), zoom=5, height=\"600px\") video_url = \"https://github.com/rocksdanister/weather/blob/main/resources/hero.mp4\"  video_map.add_image(video_url, bounds=[[-40, 178], [-45, 182]], name=\"Weather App\") video_map.add_layer_control() video_map Out[10]: In\u00a0[11]: Copied! <pre>wms_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"600px\")\nwms_url = \"https://nowcoast.noaa.gov/arcgis/services/nowcoast/radar_meteo_imagery_nexrad_time/MapServer/WMSServer?\"\nwms_map.add_wms_layer(\n    url=wms_url,\n    layers=\"NLCD_Canopy\",\n    name=\"Canopy Cover\",\n    format=\"image/png\",\n    transparent=True,\n    opacity=0.7,\n)\nwms_map.add_layer_control()\nwms_map\n</pre> wms_map = ecospat_ipyleaflet.Map(center=[40, -100], zoom=4, height=\"600px\") wms_url = \"https://nowcoast.noaa.gov/arcgis/services/nowcoast/radar_meteo_imagery_nexrad_time/MapServer/WMSServer?\" wms_map.add_wms_layer(     url=wms_url,     layers=\"NLCD_Canopy\",     name=\"Canopy Cover\",     format=\"image/png\",     transparent=True,     opacity=0.7, ) wms_map.add_layer_control() wms_map Out[11]:"},{"location":"examples/raster/#adding-raster-data-to-a-map","title":"Adding Raster Data to a Map\u00b6","text":""},{"location":"examples/raster/#incorporating-different-raster-bands","title":"Incorporating Different Raster Bands\u00b6","text":""},{"location":"examples/raster/#adding-an-image-to-a-map","title":"Adding an Image to a Map\u00b6","text":""},{"location":"examples/raster/#adding-a-video-to-a-map","title":"Adding a Video to a Map\u00b6","text":""},{"location":"examples/raster/#adding-a-web-mapping-service-wms-layer-to-a-map","title":"Adding a Web Mapping Service (WMS) Layer to a Map\u00b6","text":""},{"location":"examples/split_map/","title":"Split map","text":"In\u00a0[1]: Copied! <pre>import ecospat.foliummap as ecospat_foliummap\n</pre> import ecospat.foliummap as ecospat_foliummap In\u00a0[2]: Copied! <pre>split_map_base = ecospat_foliummap.Map(center=[40, -100], zoom=4)\nsplit_map_base.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\")\nsplit_map_base.add_layer_control()\nsplit_map_base\n</pre> split_map_base = ecospat_foliummap.Map(center=[40, -100], zoom=4) split_map_base.add_split_map(left=\"Esri.WorldImagery\", right=\"cartodbpositron\") split_map_base.add_layer_control() split_map_base Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>split_map_r_b = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=8)\nsplit_map_r_b.add_split_map(\n    left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",\n    right=\"OpenTopoMap\",\n    colormap_left=\"viridis\",\n    opacity_left=0.7,\n)\nsplit_map_r_b.add_layer_control()\nsplit_map_r_b\n</pre> split_map_r_b = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=8) split_map_r_b.add_split_map(     left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",     right=\"OpenTopoMap\",     colormap_left=\"viridis\",     opacity_left=0.7, ) split_map_r_b.add_layer_control() split_map_r_b <pre>WARNING:CPLE_AppDefined in vsicurl?url=https%3A%2F%2Fraw.githubusercontent.com%2Fopengeos%2Fdata%2Fmain%2Flandsat%2F2020.tif&amp;use_head=no&amp;list_dir=no: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</pre> Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre>split_map_raster = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=10)\nsplit_map_raster.add_split_map(\n    left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",\n    right=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",\n    colormap_left=\"viridis\",\n    colormap_right=\"magma\",\n    opacity_left=0.9,\n    opacity_right=0.5,\n)\nsplit_map_raster.add_layer_control()\nsplit_map_raster\n</pre> split_map_raster = ecospat_foliummap.Map(center=[-8.3793, -74.5357], zoom=10) split_map_raster.add_split_map(     left=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",     right=\"https://raw.githubusercontent.com/opengeos/data/main/landsat/2020.tif\",     colormap_left=\"viridis\",     colormap_right=\"magma\",     opacity_left=0.9,     opacity_right=0.5, ) split_map_raster.add_layer_control() split_map_raster Out[4]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/widgets/","title":"Widgets","text":"In\u00a0[1]: Copied! <pre>import ecospat.mapping as ecospat_ipyleaflet\n</pre> import ecospat.mapping as ecospat_ipyleaflet In\u00a0[2]: Copied! <pre>widget_map = ecospat_ipyleaflet.Map()\nwidget_map.add_basemap_gui()\nwidget_map\n</pre> widget_map = ecospat_ipyleaflet.Map() widget_map.add_basemap_gui() widget_map Out[2]:"}]}